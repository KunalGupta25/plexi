{"docstore/metadata": {"1GRqTJ1K_6Jg3zJQTDFcyRn3xqlmm4oLp": {"doc_hash": "cf23a7c4236ea29f20a15be9cafe9407fafe1a7c978afa1a55cb54dc9f4b4915"}, "1XpIYm1w1k_HA9YNe-I4jRjCBJl6s7McY": {"doc_hash": "f0d871625f58cc001f53010056415c52466ab9d173f308c57b4007414671c34d"}, "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA": {"doc_hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d"}, "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq": {"doc_hash": "f68e1d9c6c2e99facfe0c536aab504aeb2e9a13a72f60b2749fba90b41210d38"}, "1zuWV9VpZX1hpyXkAk6JbMQL1kH_6rCT7": {"doc_hash": "9dfd7ba72c731bfa9f06334e6d9aefe432a36544a8886430d8fe2770c1e30dd4"}, "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4": {"doc_hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97"}, "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk": {"doc_hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de"}, "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO": {"doc_hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3"}, "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3": {"doc_hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc"}, "1v8qSwjR0XHZVzUGqi3-8KQXxMAIAab1z": {"doc_hash": "ad746661805d58b6f2e19811e6c77769908ebabad061c05117a922c4bcabd342"}, "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD": {"doc_hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25"}, "1DLoy0AfL96-C7zsCj5PdHQXErpLYF4cb": {"doc_hash": "a0c2ddfabfa98a4325b5d0694c5e9846dffb6d519a7f82e30d8295c7d69ce968"}, "1fvTkHdyCfMHyA1s-UZCVOQ3LG9L3Fbgp": {"doc_hash": "55cdd7bbb277e0cbfbe678fc659383251a96496c8de6914cd1794d027cc42391"}, "1_S2NDuSdATGgkSztCXjSbV1ISkRtfr0L": {"doc_hash": "351fe4e5b3084975dbe89977c7ce2792b6a5fa032efd5215b630ce41cb2416fa"}, "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q": {"doc_hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3"}, "1BFPy-GLIB6IwW27gg1PyXr9FRD_E7VjX": {"doc_hash": "2f05a5a7051b8c486d46cad48ee3f4d232f1c55a1edea5c952272bfe061b55cc"}, "1y5BKWh5PJ0Rjnwnd8WaFUTggdxvJ7a7U": {"doc_hash": "1bd7bade67cfe3841ecb9548d6dad05f04a30393ca8d97678de01a3d4a6fa62e"}, "1lBC_u8KS2OgVW2Vty9KWwdSLlJ2N7iXC": {"doc_hash": "5b2dc6fe60861071b0d879679572356097f1953b3a0d161ab6ab623158843218"}, "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw": {"doc_hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1"}, "18R8yKqzrNvRvGbr0t1NqcqFCKuV1_drC": {"doc_hash": "f0d871625f58cc001f53010056415c52466ab9d173f308c57b4007414671c34d"}, "1TMdwwLSTkuoQx3FzCL6psqndi2mi905r": {"doc_hash": "b2fde2939c8af2388e334cf78b787f3d5015de6dab931543f55cd140e4638eeb"}, "1t55p_gzM0o8Mn59Ie7kGy_5tfgWfu2Rj": {"doc_hash": "1590320091c0b9a784488f90f2904a4350a8af1c4698e9bad58d7ced97c78150"}, "1rrXAzl7sUuQxB92hu79t-TEIECl9m03S": {"doc_hash": "4e3fd4f94d1c73937185e96f41b4d0b6418205cdaa61c9912818e07f3d76d323"}, "1TRXFu5vEtdfL1AFq8xcJlnGLufSBx6KY": {"doc_hash": "46eba87f92a6b5418059373a63b08d2b8ee410fcc7641b1c1a4c480f27c2d5c6"}, "12euCEx8S2H9bVeyf9lllhl_b-6S_R9zq": {"doc_hash": "65f485a472300c56ffcfe1d03f835768bcf0dbaeb01d4d4eea9123b29ef71c35"}, "1g0HXmmom8Ge3D12GQ8xzAWZRgAOztlld": {"doc_hash": "822204096fdb9a763f95fdca5a78199ff7564a3a03646946dcfd572ae307bbee"}, "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE": {"doc_hash": "eb0386bd4c2b207144d51f0ff964333123f877925ef3e3ad8d0f2b9fcd1bc4d8"}, "1bXz7sOPBKMffadkn10eBX4rosgaafaR9": {"doc_hash": "db7e6da0714fe30737fc23a8c181c856286e537edf3857190c31c6a62f6c7ab1"}, "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4": {"doc_hash": "3496a81807420226245be3194c9571f38e589f17b0b7dfa3a64ad6d406066bb0"}, "1QVRbvrNOHuzYH0CuDpjq3dgfL5dQ6jRL": {"doc_hash": "d6f179dcc8d53c813dbc25704b6b737028d427d7b31c989b98a00539bc2d4908"}, "1t1piaiKQMfJFypnF7GJmbonCIqXMqaPK": {"doc_hash": "c3a3d532b3c3875b5ab8275577d8fce03d188c8bbd15c81d19279efb78a467d0"}, "1CBP3gQl7LyYFBjWz7F-hqDqiW4JPic5s": {"doc_hash": "5f473b125027cafec6efb56011fe8dfc7f7163ff1648f6631b2804edcc5530df"}, "10J2vVm2LE41eftDu5yK7q2V0RU7E5S-Q": {"doc_hash": "1ee1d6a2a80358f1c12290dc8e89cdf8159139baddb56f902bb57850b17c7e90"}, "1_anc6tvWYiW_riht29MJIE7A8RFTlgG3": {"doc_hash": "352c88ab0fba1e15bae9cf798689dabb4768cdcb7de3199ae0c4aa27f1de8cff"}, "17HMsm94p5WZC3m1TeEDvbLJoaBWeXALS": {"doc_hash": "8ccd05824d5b76940e3a1d3d48537187930e3f171d5ebe277e97fc5efb7d8236"}, "1djsyCOgYW8lqSoHC1pF0EVROt3dchlVu": {"doc_hash": "8d570453c142fc44205c6c33b282929720b772055b214397a2325b556b58c465"}, "1RXuqgHQTCBMWEIRDb_TQdLegEyLPOCn4": {"doc_hash": "94f052acd618ead900f15797be6f61563fd1523c74dfa8bdc08351cad96c6eb9"}, "16bWDrtClrCDT-CzkoFfFFsrdjijKrg4H": {"doc_hash": "3d672810af2658df6d445530c2aaff90d1df76d00ce4003144dd58600cc51b02"}, "1z2bbwA6M0GCtEoDsmKnNBGrDHN1g9_m9": {"doc_hash": "ec5a729ef7e3cc1c85641edad56df1caa2cfe1a343d8a894483ee83ac52264d1"}, "1YXeDuj80R6YrxEiB7hEx8qZnoDlXP0e-": {"doc_hash": "282211713cc1e9fb81e55ece6b81e66474ab8c02d00a49727504eae94c135fb5"}, "1SPPojHd2sYla__ZMZ9i1G_BLO_lFU7tJ": {"doc_hash": "d6400b780fe25c9ca5093b259beeb3a8709753e12a4ab4e54a06950538950c3f"}, "12JpJVK0Nlxyee94mrp308YBzZOEJY1_W": {"doc_hash": "c8e6b51f28eafc0a91273b534d0a6e1bfd7a65458eec68921a3971cf4d5e5ce0"}, "1riXFQ2vV22GV8q2GIjQZf3dekx5yNX6c": {"doc_hash": "fb98614a6eae6e59b7333ee32b12b056ccfe4ea3ed358da14e19ba3d4b7605fe"}, "1iDQ-xjguFUR69Oi-egq8gOOyfy1OqE0z": {"doc_hash": "d08b5647e246d97282e242c1f7e0fba26fdc2958478e1be9101e4743cd9dda36"}, "1MytvHkA9kpAK7XEnHq1FdOp7Gs-2ZY4I": {"doc_hash": "43947c406fc2e80f63d17c0af58bea7cc4cc2c8cb9cb511dc5974e902cb6b8fd"}, "1Ks294UdSygCSC69ZStPwn_MK1hEqaTHJ": {"doc_hash": "370fdf773799eea14544dc6f167d939d5bdd2b32694daaae8ecef752588a3c45"}, "1UdzW7tbP0u6OxgDAWp1ZTXyxaw_kB8fG": {"doc_hash": "9081a76e6ee56cfb9af450f8403d7de04b0b0d7c6c2a0c64db8a799452d25d6d"}, "1yuiFL8iDBWMLijHQRgEpXVYNT3OyRfAa": {"doc_hash": "ac375b27f7836b1f0e28de87002c51ee26e51dfab0cf663b5e870da2d3d96d6a"}, "1pasibODDKv9HEVClYghx9bAaQ8CXjICm": {"doc_hash": "2dfb398dc44cfcb602b4ec19d5cb02a11e3457dcc646575a1fbca70efc3df10a"}, "1cX2ONBT9K6zdbFitoF52TTgRB0BcBxul": {"doc_hash": "81cbb5d067aa564a441075dd183d8909d23f2b52f5f9d59edfa37064d0125e6d"}, "1vJNRWl68wKXevBTH7WpeB2DkcSLTaYDz": {"doc_hash": "1739700216efb852cb7eebd0a3bb270be95b7aa70982757c68f6cfd406b74212"}, "12I7aQKuBsQgLABEE2iiG5eTb9ca3T0rZ": {"doc_hash": "451f2ff3ffe7a9d427848d17adae7324e00f5db2876f5a56cc6fa09b39258378"}, "1wYuB4bqDH9kqGlPjwg81z8YkMf3sglzE": {"doc_hash": "63fbce185119cbef9c837da8d5c46d4a6185a3a647793fd884ffae049fc803ee"}, "1pz9Tj__OP_x5r7BYajHMjxiUbTCzyJ43": {"doc_hash": "cf3991691f99909ff672d7c0d7ea246983389e962382cbe92af10a2e9af6feaa"}, "1KSE2Q708areAAjdbn6iH8HOmw8cWgnWN": {"doc_hash": "7147074154bed83fd495e96736f30a53ff99f3eb51230291cf6cb932f6afe45f"}, "1ODAs1Osx55qxzcOuGEBU8PnV2AQAnx_z": {"doc_hash": "dae9c65944896c8ea3174ab84e70b6af5ba2aa0dfa64866a9d49233b0d813b41"}, "1hX8-Ai2RPVyKXPL_M415ii2av6wHFG8V": {"doc_hash": "95725a28de5d813d9316248580b7517f94329c8a8a9d45554c94243c70f79f31"}, "6a8cef05-1b68-47bc-806f-f4c9ea813de3": {"doc_hash": "3352cb4657b99c5cddc95b1a43391499e7fb03ed22279c5a46d8136e7ec5f63b", "ref_doc_id": "1GRqTJ1K_6Jg3zJQTDFcyRn3xqlmm4oLp"}, "170ee425-823a-4ac3-91d2-7ba34a785a12": {"doc_hash": "eae60f835f5880f60a81fb81f4174db4079da221bb685ef94a87b06db92d562f", "ref_doc_id": "1GRqTJ1K_6Jg3zJQTDFcyRn3xqlmm4oLp"}, "0a58b0c4-9de6-4495-93a4-e27940cd72e5": {"doc_hash": "65431af21a306fb90c12ddce815419c922952173fd2b6969204542c046638f36", "ref_doc_id": "1XpIYm1w1k_HA9YNe-I4jRjCBJl6s7McY"}, "f4bc24b1-8fdb-429e-9e5f-b56fa86cae2c": {"doc_hash": "abf5c846c757e13cb3a5eedc6d9df1b20cb0fec503d63bce5c1a715be92fdb46", "ref_doc_id": "1XpIYm1w1k_HA9YNe-I4jRjCBJl6s7McY"}, "56ae3c85-2b02-4434-a67e-754b92821ecc": {"doc_hash": "b80e148bbd496571136279ed8463850d014665aa28f7e255de049914d7ead72d", "ref_doc_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA"}, "15d37b78-8198-4345-9f01-6a1a28c02e39": {"doc_hash": "bdd95c19a2daa38d61975b4db5dbea14d6ce508f5b72bffc3fe71ebf8152097c", "ref_doc_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA"}, "a2e0df8f-e819-4804-ab18-989900685a1f": {"doc_hash": "d66bf6954762820ebdfc1da997a2907d30bcb7060d9e4ef99e3ecad98d19b30a", "ref_doc_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA"}, "20281860-2860-4665-a888-e9362554ca14": {"doc_hash": "5208cd50700b61fb939de3a351133fa30742b660b376acc1cc1ba7551526d662", "ref_doc_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA"}, "73a6d9fe-a90e-49bd-9d4f-98816f5b6d17": {"doc_hash": "cf63080785918c9ddcf991ed66496c1dc8b7caeb3bcd02e3112d1d1765b43c07", "ref_doc_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA"}, "e07e5462-eb3d-47e5-8956-ca5207e9b906": {"doc_hash": "2be5d78203f8cc167939771d404337bbb087854095556023373a822747a4fb6f", "ref_doc_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA"}, "ae55c952-1e92-416e-9b17-b2f0666e6c97": {"doc_hash": "ff01dbe52f50f34a4c4e5ff4e440779b8a5d3ba2c20dce2e95b2198b0369354d", "ref_doc_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq"}, "f7fe5985-fd90-4d63-889a-e9b6a2ec7f69": {"doc_hash": "ba6e6aaec7dcbe0194c72fe3d93cef2b431880ad1a64bf889cf142ac4bd8c7fa", "ref_doc_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq"}, "29740bbf-d6bd-4e0b-84e5-b1f8b96549fb": {"doc_hash": "72a73d0ca212d1317d6473ce9ddf966af381bd7686bda519c1f7a6b710863202", "ref_doc_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq"}, "30c0d51f-03e4-4e46-a799-8c97076516b6": {"doc_hash": "978ce2ae63623d961b6de47b34e784024040f331862cfb2c8aeeb72cbacdf4ef", "ref_doc_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq"}, "bb155286-d56f-4af4-b594-c9774f83e975": {"doc_hash": "3193b1bc6534029932f3bdfd6e8419949a26cd67c26d2251228106f38163a59c", "ref_doc_id": "1zuWV9VpZX1hpyXkAk6JbMQL1kH_6rCT7"}, "77a14b47-d23f-49a3-878f-3854f100be56": {"doc_hash": "ec19eba8f014eed1605f620afc6f61f35da4e1ed68ae9d19bf1c7f23429a0a3d", "ref_doc_id": "1zuWV9VpZX1hpyXkAk6JbMQL1kH_6rCT7"}, "8396bf4f-9cf0-4d3c-83d8-c69224bda401": {"doc_hash": "f9b0d4d70a6cf14964e02a6e6398a5518be5a825a717a16888590753cffbb939", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "5fdcf6e7-3c1f-4bc4-bad2-ca7b37d944b2": {"doc_hash": "64e8252b236db35a21281f18072f9b2b7df6c33de2b5b4cbde1f2422bc66aa43", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "c73961ec-0397-49a5-b3b2-d02252a31a00": {"doc_hash": "55edd634f816730f8629df8a9c02bb1fb4d0483773ad2366ba6602902c2407dc", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "073631f1-213b-4ee1-a318-a903a2494c31": {"doc_hash": "10fffd0bba7001ad8e3701dc2220162d86f260956c71f793140bf7e72066d245", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "188c649b-3eeb-444d-a728-d8adf8af1a75": {"doc_hash": "7e377e2387d939660db2c4741688dad0849540a3e9daa7484c179e2ba6633838", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "52823b2d-9779-49d9-b3c3-cccd40fafaf0": {"doc_hash": "e99dab747097c6b1406da25cf310c375eaeb699beb7cc4dc032c72db0a2b5e61", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "ff7d59fa-9ce2-42b9-b0df-307804b381cd": {"doc_hash": "abdf96bb77b1ec770c39168e03fd143bcedc45f4debf11482c4edf39d28b6400", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "264aaabd-da2c-41c3-ae64-139c6fe74359": {"doc_hash": "e6111c2f132b20ed458f827322d481778369d93a34b3d08599ce5e5d388e81ce", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "17fd34e9-5202-4259-bfef-a0843d8e214a": {"doc_hash": "e6016f6513b3fe6def09b8ff645056bcd8b938133660adf40782cf92facdfd75", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "6b2335b1-0ebf-4a6e-9afa-05059b11e8c0": {"doc_hash": "5405384f56bcb70ae2f39a913e2d68203587d69b89389b750e8674c5ac9cfe08", "ref_doc_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4"}, "7234f23f-5691-4a7a-b2a7-a9d731977d07": {"doc_hash": "091820c9827d1e5f86c03d4864f206cd7de39a4b73ae8b3f35712f8092153802", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "91911b4d-ccdc-45e1-85dd-9a061f824623": {"doc_hash": "2030c61d65355807c670873dfe1e010dea0a1c7a1006e89b8bbae34681c38248", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "c4fdeabc-49b2-4b33-93a8-c3bb38e009d8": {"doc_hash": "78162b6dbca3ddcc9e493fc47d605326f19d16edbeb060cf341235e714354157", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "83ead083-016c-47b1-a6b4-d54873893114": {"doc_hash": "8b8d31b1157e1f41ec09a2a8674346536822962822dbe02a7f7020c592caa5c3", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "31e0fcdf-e2a1-4e6b-8178-0d391ca4b968": {"doc_hash": "9188090a8ed1be249c069c1f3978c5f9ab880bfb36c57936468b0f88f5b33988", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "349b6e8c-9853-4943-be9f-3b667da614d0": {"doc_hash": "781684e8f24a965965b59da092ed8b9ae280124f0f31629fd9cad5e8cc8aabfe", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "f30d4ce1-9e6b-4456-8834-addd4ff4b0e1": {"doc_hash": "cfc3c7c3cf214e91a877cabcacf627742e1aacdc93af5bba8e2476004d4f9e5e", "ref_doc_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk"}, "471b4b16-9050-4d04-b804-e5cedf48d274": {"doc_hash": "dd63b4d7ccae7d0fe60fcb4b327ea2bfb4593e86fd2057faba5fc6c46e5dfd24", "ref_doc_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO"}, "474097ba-98c1-4d53-8baa-d9fa59d81e21": {"doc_hash": "03ac3d2a661a1d95107a23e3a49843240b2521dd452bd42db50c13c269d3d8de", "ref_doc_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO"}, "9c9b1b05-978b-4f7f-8fd2-eec55ed4b572": {"doc_hash": "dbb6adf030e36d9bf0e84e7593d18ee08b7700a45f276f182b978a1f29e96479", "ref_doc_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO"}, "e6c9a876-19cf-4c0f-ae67-64a8357c058d": {"doc_hash": "0fc17997ca94b2a27f89594c69ad57bbbc5bb205ba86947824b72e2182d8c735", "ref_doc_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO"}, "befea919-9995-4fa5-adf1-6442946beb59": {"doc_hash": "1a83717a3a82fa047f63795c53ca8036ff03227a5495a4ab8c9e566bdbf8d2fa", "ref_doc_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO"}, "b6b55756-074c-42ba-b0bb-f76a364d60a6": {"doc_hash": "210f4f5cbed8ae9bcadab0098bd2061d46d6e03a09e37aa509b7008d710a49a8", "ref_doc_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO"}, "61f93aad-a4d3-4d8e-9420-52d245615a9a": {"doc_hash": "b59d1741e6c99f8fc789c5a305752025a01665e4d81b689025e553a4154f1a66", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "27aa38d8-be5c-495a-a4b4-0ea363b871ed": {"doc_hash": "b048cb2025f5ded95baf187bc5037c1e80f32df955c6acf8a530bf2897417186", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "3656cd17-b055-4e24-809b-26808b7132a0": {"doc_hash": "e12d67f478beabed2ffc1b1d753e4082c41b8c1c522fd1d46f5cc001e097605d", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "a7aa49b6-b984-41e2-b837-beeea0e9befb": {"doc_hash": "4f49dcc9385f9a3abf81f8e6f03f84f75e228c8c9924e84c65e3442a34060cb9", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "801e1b8c-445d-4ac7-b67a-058e45d8706d": {"doc_hash": "ab6eec8c07acf9a2fb3fee4c96300cf167d5b0ec592a7bb9efca8865bbdf8f72", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "39c656e3-1237-41c8-afb1-94a247c6e73d": {"doc_hash": "6840b8af2485231c31b56e79b0a2db28486877e58762d6ee7e692af179fead94", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "53831b68-db71-4ad5-b97c-b8c14a240c07": {"doc_hash": "ae5ca504b28a1b707a553ba6befe8191ecaf82c14a3768edeee96e6bf54e6d5f", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "8ba30654-25ec-4b4f-8de7-3ed5f0026a87": {"doc_hash": "2cf56aef919fec6faf5599bc4eeffc95982206808a4654b4c8d7277d4ff4001c", "ref_doc_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3"}, "f35240c5-57ae-46c0-87e0-cdd3b9eeb67f": {"doc_hash": "822e4f662022d2ea4271b34c678b9dc42a41e64285efcf1e748c31db90cb7ce4", "ref_doc_id": "1v8qSwjR0XHZVzUGqi3-8KQXxMAIAab1z"}, "ba1fe4b5-3746-4b80-8d6d-6c284497a113": {"doc_hash": "0cee99696d0965166b93a118d5678ae0eb63a971c70be5f990f75db9386c2752", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "08db533c-e978-468b-ac88-64537e566cd6": {"doc_hash": "b7eb741bb146bef3595c6498559fd1abf859b04bcb59dc5f8312cda5c9bfa2e0", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "4652e6ee-e95e-4c65-9836-8ec61a518cca": {"doc_hash": "bcdd002dfb358e6dfe54b8ab15299f43cb0e16e5833d8e459909c7dd76e2447a", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "5cf9c845-93f8-4b8c-a5a0-99311af1b76f": {"doc_hash": "454b7c16d615828a80d202cd91f6ae21664f33c6905f8104b3cb745f655b46b5", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "7300b9b4-b4a5-412d-b334-67426e72651b": {"doc_hash": "15fa317be725ed16fc6ff53e8159099271e9893a4aa7067437ecc2d9decf062f", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "2a25230f-1f65-4046-859e-ae468afb24b9": {"doc_hash": "3675046093996c9fad964211e572aa2f07e9576e85ba95e92bd67d1146ef95ea", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "cbae03db-0e84-435c-a6eb-78e5dd785883": {"doc_hash": "1013d3ed5745c73256e3211ca8215815160535e60fd028047268f116616ef6c1", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "8c1d31e9-f3e2-4ff1-a19b-7081436bea60": {"doc_hash": "8c73fa7f3b82e8ca0deaaa3deb89ca0980321c7e7ebbe21145cbc686aaea59f3", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "1595030f-423a-4445-b8c8-1226894bfacb": {"doc_hash": "7a557ce2927c160b6ffea321c8783aaaf017e70a5849488e3375e1dfaa438a2c", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "8d7a7e88-09a3-4e59-a88c-f116e961039e": {"doc_hash": "d82fc64406dbda4ee222c12466f816e8c92959cad5a5cd69c153d189d246a6f0", "ref_doc_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD"}, "75215201-ad11-4b0a-88bf-154b660b0716": {"doc_hash": "bd9e17508f252678bc85d81fbb53c82a7044b266ceffb0243bf31a52101fac2e", "ref_doc_id": "1DLoy0AfL96-C7zsCj5PdHQXErpLYF4cb"}, "e7984d62-c668-4c29-a7ca-61eb00c560ae": {"doc_hash": "e70f3f71783dbdca6ba168c30864791f39d7dcd5946e6a05f549350d36d7188f", "ref_doc_id": "1fvTkHdyCfMHyA1s-UZCVOQ3LG9L3Fbgp"}, "6d700159-07c5-4510-8ed1-6bc57142c0c1": {"doc_hash": "5efefffd1f137d8500760b2ff3965d0da3ee0e96fcf2bf0a8ecddcc374af1d90", "ref_doc_id": "1fvTkHdyCfMHyA1s-UZCVOQ3LG9L3Fbgp"}, "4b7e3973-523f-48d8-a8cb-d0316c5a468c": {"doc_hash": "79144008126cbcbd7a850202c4e7846178c5c087d64af7132dc63265174071ec", "ref_doc_id": "1_S2NDuSdATGgkSztCXjSbV1ISkRtfr0L"}, "01bbab79-dcbd-416a-b6a6-df14d812c9c4": {"doc_hash": "226ab24d9c91805a0f928a4cc891a39fbc274d72e0814255f47436f5e21d04b5", "ref_doc_id": "1_S2NDuSdATGgkSztCXjSbV1ISkRtfr0L"}, "bcf697f9-d514-4cc8-8ac0-22181326e37e": {"doc_hash": "e7105be957517a4f6998f3396523ac6c7c68b62b26d3a28b02088d992cb9a6e4", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "24c60fb8-d91e-4f8c-8a7a-4e39a8edbfc6": {"doc_hash": "65e5215231545ea417609c99bbb66461c3ea98ca19016978b6393157bd41f3a4", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "d85977d6-6f3a-410e-a5bc-6cb60183cdb9": {"doc_hash": "a9f1cebf2f76600b511c51f573e3f0a8c73b6505aa50e21fcead6aa506cd079e", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "2b514464-b8ce-474a-9147-ce94d4aa5301": {"doc_hash": "07aea5000aa6e3dc082c622a5c88e9caa0e6f1d3e1ef2d5278e488b99897b2c6", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "edfc7015-bc4c-440f-91c4-ad69148e5daf": {"doc_hash": "01eefb09394b09ff884a9721512dc51850f7b8722c97ad773fb3233cdbea0a2b", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "ef3ac94b-69df-4b1b-a820-0f7b82cf71c0": {"doc_hash": "ca6b5fb71eda69901adb8e936a6ddeeeffc64645dc91ec1037ef379329d8d871", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "a0053a03-aa02-4e76-90f4-54435f9b90e7": {"doc_hash": "c7a2e74e5ca5bdba5c4849e1212e1af4d36d63151f6dbc877fc66cf5ea920330", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "37ad3b6d-7a5c-41b2-b8ba-d9465253165b": {"doc_hash": "cc30bb1623aca29c392ec79106de88d6ec3b4468291d676b251064db9bd14dd7", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "b0d40a68-05a8-40db-bb83-d9b3b0fc87ab": {"doc_hash": "7713067db5b445c1b594fd08e4e10cbd5b43ce3f7c2bb54171ca3156bb3e43ce", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "5e686433-3ec5-4267-8393-421d5c659ff1": {"doc_hash": "8f4a24200b08e9254cc2616315f06aca6049cb925c5def1b0e88cd92210cbf60", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "7eb92e06-26dd-4c4c-8584-6358f51ef161": {"doc_hash": "69fb110f51568c00400b8fc3eb255b54475ef5a8b3bb08e2d67e07983956f2fa", "ref_doc_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q"}, "b4193740-18da-49cf-99d2-1083b744b643": {"doc_hash": "fcdf0208bff39bc060565ec45932734676fbe170ff8fa1f403dab8bd8da4dbc9", "ref_doc_id": "1BFPy-GLIB6IwW27gg1PyXr9FRD_E7VjX"}, "7fd9acd6-83e5-430e-8027-c46850cff6d2": {"doc_hash": "1a60a6300a3d0f53f98593e963a6ca80dfcc1ee18e3ce148fe041c2ac9c7616b", "ref_doc_id": "1y5BKWh5PJ0Rjnwnd8WaFUTggdxvJ7a7U"}, "aeece331-a7ae-438d-956f-bb8481c57f23": {"doc_hash": "eb9ce20245cd7c62559cbeb9eecf313d8c000b0f323e292b7cc66b25df35faff", "ref_doc_id": "1lBC_u8KS2OgVW2Vty9KWwdSLlJ2N7iXC"}, "70183aae-20df-436d-b07a-349f350e8a33": {"doc_hash": "f2630bc6d8462401cb5ff2f6c4419b9eb4538232914343b35c20240116c2b874", "ref_doc_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw"}, "b1680562-982f-492b-9729-3b1a1d96984a": {"doc_hash": "565d3d2b2b2ba1256295eff3dd5a7cd5608b77202094859a621b47b40a9a8d81", "ref_doc_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw"}, "1e51d6b0-5915-4a00-ac60-f47b9943bd7f": {"doc_hash": "c6cdfb29178351f4641c7a9680b8ac3b01c5c4602c176b4cf29046220fb03dfd", "ref_doc_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw"}, "54848d0b-c7af-4b68-a393-fe2cd74318a2": {"doc_hash": "84ebb7ae359c3eaf3b101a8098b7cdce65cba29e35e59b5f4236d66e5ffca55b", "ref_doc_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw"}, "979a31c1-c1ee-4cfd-998b-9f3c54746861": {"doc_hash": "e244497991f7a4afab499956a98efb99f3694a7b476f5cd02e532f252eaf6c85", "ref_doc_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw"}, "dd843e93-899f-47bd-a35e-959d531cf641": {"doc_hash": "2cbe9220f6d139471a8673f039261f63d94f735d0d8702f4d4af21905cf100b1", "ref_doc_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw"}, "99fe27e4-ad97-4b98-90a8-6a74a105a187": {"doc_hash": "65431af21a306fb90c12ddce815419c922952173fd2b6969204542c046638f36", "ref_doc_id": "18R8yKqzrNvRvGbr0t1NqcqFCKuV1_drC"}, "3baa6dd8-732a-4641-bb20-2a9b1b0b0490": {"doc_hash": "abf5c846c757e13cb3a5eedc6d9df1b20cb0fec503d63bce5c1a715be92fdb46", "ref_doc_id": "18R8yKqzrNvRvGbr0t1NqcqFCKuV1_drC"}, "38584628-c8e4-454f-9e83-ff1306495cf3": {"doc_hash": "d9629ff75aa13804dbd569b8ea02cc9046e307d40bd5319d74501fb6502189bc", "ref_doc_id": "1TMdwwLSTkuoQx3FzCL6psqndi2mi905r"}, "ed59aec0-74ca-4ea8-91a0-fee9a1edcb0f": {"doc_hash": "a2f2f85b4de9c93c7385b79f9c17cf474df1338a7763cc1501853b2bd8b8da42", "ref_doc_id": "1TMdwwLSTkuoQx3FzCL6psqndi2mi905r"}, "4dd8126b-6010-4654-bb02-fa2d2efc3358": {"doc_hash": "29931a62c1fad8db24abb13951db78e7508e2d06fa41b643962257c9295a04e3", "ref_doc_id": "1t55p_gzM0o8Mn59Ie7kGy_5tfgWfu2Rj"}, "5fe7f664-78f8-4027-a331-fdccb3fc9042": {"doc_hash": "f64e97238290df9fb799ea9311d709268bbef7b81ef2aa49386f84b4e2c8f21a", "ref_doc_id": "1rrXAzl7sUuQxB92hu79t-TEIECl9m03S"}, "fc9b2d5a-95fe-4c40-a007-6d13d1e9780e": {"doc_hash": "3fcb1c7a8aba85bbb794a8e4983af873027c9a1064783bb0099ff7e5e0d6e755", "ref_doc_id": "1TRXFu5vEtdfL1AFq8xcJlnGLufSBx6KY"}, "2db2d2f0-c6f6-4195-b3b0-3dc59ea7ac8b": {"doc_hash": "c87e5ccbd2278ed41e1175049aa5760acdd59be77482a515cbfc91f4e89ba400", "ref_doc_id": "12euCEx8S2H9bVeyf9lllhl_b-6S_R9zq"}, "99eb0697-6ac5-40c3-8ee5-d2e42933ee76": {"doc_hash": "3e71a6b41c6bec11b10750faeab11f822815678c83d14387a725e2b3e660b484", "ref_doc_id": "1g0HXmmom8Ge3D12GQ8xzAWZRgAOztlld"}, "45526eaf-842e-4846-b66e-f3fd999e4aab": {"doc_hash": "4aa7ab504cd8988b0c13c4a6e9321f2626af34ba019c024d965e2e71e6c0ac7c", "ref_doc_id": "1g0HXmmom8Ge3D12GQ8xzAWZRgAOztlld"}, "1213d792-c8d3-4919-af63-31f65d7e74b9": {"doc_hash": "fdded3400c3fec51576ee0055e800451cc1dce9af0ed7ec49ac3f553a4c001ec", "ref_doc_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE"}, "40b90bba-307b-45fd-a76d-18f13b6fc778": {"doc_hash": "2b842bfb710c5f3f787ed18345ed11da760d6e17518c6ef9a061fa6cb3ba39bc", "ref_doc_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE"}, "50e0fb59-ded3-4db5-9c0e-e2774eacbfed": {"doc_hash": "ce83fa40770dc2ed192d87a257b03a97a58fad6a77fca398170dc64ae25a4a2a", "ref_doc_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE"}, "b5f5ead1-40b1-4335-90d9-e191cf130192": {"doc_hash": "af7ec35e7e3fdfbe1039e0978d54cc3110a875e108abe5bcc5ac838c5cdb56d0", "ref_doc_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE"}, "1f563a14-97b1-476b-bdca-6df43c08b366": {"doc_hash": "915b9d907ae94053f79f8b403032bd4946c73a10480c14752d1c9c269f7be570", "ref_doc_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9"}, "f359db91-4586-4829-8f61-06a133bd91d8": {"doc_hash": "8fd3007d196361a28fd0f32569f5678f0c8e2ba5c80bd2ffe37efc7be50bb6a0", "ref_doc_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9"}, "8a2238e7-e350-4289-a58b-c5e29689cb76": {"doc_hash": "5cda7d424855d2673632bd3dea93b4594abca58dbb44aa0b472c4c2f065b0484", "ref_doc_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9"}, "27c38ba3-43d0-4408-91df-391f2ce25746": {"doc_hash": "af4829cf3acff07f6c6c2c31a6dc6171d588239c71967eb81bbf61e1a705d3a9", "ref_doc_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9"}, "4da78344-86da-40aa-af18-00f5db737fe0": {"doc_hash": "47984a89a806d538249be5561a96ad881ad70fa35a5f984069df0d4d155175a0", "ref_doc_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4"}, "1e598a59-7f28-459e-8e30-c7a9c42fe6fb": {"doc_hash": "724806948b1f80e16dd3ada960f34e121cdeda9c0d23c5a09b96fd060763ba57", "ref_doc_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4"}, "9ad75fd1-8018-4764-b823-bf3c21acdd43": {"doc_hash": "63e269274f08a7b91419b5d78f597015c1dc9567312d927feaea0f27d233f399", "ref_doc_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4"}, "a0d72357-d55f-4b2b-a11f-763293803fb5": {"doc_hash": "ba0cee63b72a70527b0cf3f4b890ba72f7d245f66d7f5abf91edbe8b508172d7", "ref_doc_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4"}, "a110e3ab-067d-47bf-8752-3d2dfdb29f8b": {"doc_hash": "05752280d4962b4724c9c335e9cb70299b6243767f1593bd7296e1b6dad0da5c", "ref_doc_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4"}, "09490052-257f-4dc4-a554-955adb5ad279": {"doc_hash": "9e3bd30a887840a496265c6af04b382489d23b1856006d223cb7a5995912e82b", "ref_doc_id": "1QVRbvrNOHuzYH0CuDpjq3dgfL5dQ6jRL"}, "61938782-0715-4710-85a1-b61b46e205ae": {"doc_hash": "66d2103e898439a45459ec7cd3a36c52f4405ee3ca4f5e4b18da75df85665d1e", "ref_doc_id": "1QVRbvrNOHuzYH0CuDpjq3dgfL5dQ6jRL"}, "ce1e20f1-b556-48b8-bf4b-6a41824a09b6": {"doc_hash": "259128aeb92595c2fa0b6a2af4924b5b2c56cedb131993a6776da3f2fd520570", "ref_doc_id": "1t1piaiKQMfJFypnF7GJmbonCIqXMqaPK"}, "44995939-02e6-4575-a6df-fc734ec4609b": {"doc_hash": "9a35db287b20be2c998dd3f0f59cfa83cfd98aa3e295a08c7fb6eb10ed384e00", "ref_doc_id": "1CBP3gQl7LyYFBjWz7F-hqDqiW4JPic5s"}, "f57885be-126e-44d5-a179-1566c7e5fd2f": {"doc_hash": "f5ef3d1ea03a8be6f1a9ff118832289910f5b4fe518bf69bc7ec32c4d950f12c", "ref_doc_id": "10J2vVm2LE41eftDu5yK7q2V0RU7E5S-Q"}, "dfe652ad-fd39-47e1-99cb-eae8e0398d5b": {"doc_hash": "91ac98491d1cf76bd96f6178a1b8f7d4f8e23a9875be3a1fcfa621c22697c222", "ref_doc_id": "1_anc6tvWYiW_riht29MJIE7A8RFTlgG3"}, "8a53ca2a-c442-4007-bcca-3be344f55bfc": {"doc_hash": "6dc8ff14c8dcc1f74f783db12b32885508cefde68b0bb49be4391bf3511233d3", "ref_doc_id": "17HMsm94p5WZC3m1TeEDvbLJoaBWeXALS"}, "3d65d9ab-0a0c-490b-adf7-4d4d6f71eaa8": {"doc_hash": "4e112d48c3d677bbe51395d09797704ed1b5dc4b1698ba7c8677622230607eff", "ref_doc_id": "1djsyCOgYW8lqSoHC1pF0EVROt3dchlVu"}, "e07d455d-f870-4add-bc90-49e60edc18bc": {"doc_hash": "ec237c8a1a203c013ba1f2de4112d97357b7f73f32e5dfa09094fb4d4307a1ce", "ref_doc_id": "1RXuqgHQTCBMWEIRDb_TQdLegEyLPOCn4"}, "c7ab5284-206c-48c0-bc63-27fbf8952a65": {"doc_hash": "a24ee6146cf00e77503f714eae1de3aa11e723b5d8bf92d4b1675a91f8385253", "ref_doc_id": "16bWDrtClrCDT-CzkoFfFFsrdjijKrg4H"}, "93639858-14eb-4e59-b9fc-9e265d128dd5": {"doc_hash": "c67710ebb6e6a3a3c551c74d14af5cab1ea3a93caa3f88f0e13269e4a2fb245e", "ref_doc_id": "1z2bbwA6M0GCtEoDsmKnNBGrDHN1g9_m9"}, "483e7b1a-ba9b-4f67-84d7-11bd1137b918": {"doc_hash": "fb8a9dc9767c1f659023958185765e1300be54f9493f7a17edb20c0e07ff8964", "ref_doc_id": "1YXeDuj80R6YrxEiB7hEx8qZnoDlXP0e-"}, "03b765db-0707-4d64-939b-8aa3ad228fc5": {"doc_hash": "abe1d3bc745a34a7997a2a0c611808f54b8b9b1ffea7278b6a574ff550e74cdd", "ref_doc_id": "1YXeDuj80R6YrxEiB7hEx8qZnoDlXP0e-"}, "4115be13-ddb1-419a-8c6e-58af077f23f0": {"doc_hash": "461d4c63fc042823780432d479c51bdd15b72bd3b14e86efde7611f64f6dc97a", "ref_doc_id": "1SPPojHd2sYla__ZMZ9i1G_BLO_lFU7tJ"}, "89f64757-bb1e-44e5-b81c-246399329329": {"doc_hash": "bf41f89c86c901244593136701f1f2d4e17224d23645b22632b1a7a0bb5952f5", "ref_doc_id": "12JpJVK0Nlxyee94mrp308YBzZOEJY1_W"}, "43010053-9e38-48f9-b46b-a82bc92029c4": {"doc_hash": "e7edcfb529346ca2ba15c9c03a541539816ed5e8785c990ec2d042a62e41c2db", "ref_doc_id": "1riXFQ2vV22GV8q2GIjQZf3dekx5yNX6c"}, "a3474416-f847-4ae1-b27b-475c9ca9eeea": {"doc_hash": "d7304fc6b5f4b38b75a0ca3d231d74fbcde0da157bb51c4bd1390029b41592fc", "ref_doc_id": "1riXFQ2vV22GV8q2GIjQZf3dekx5yNX6c"}, "30889a60-50d3-42cd-a2be-f3c4383a7fad": {"doc_hash": "2b08cea5b7993a76cb4c7e8ee8969a35cd85feb28116f8b3f00369b1cf63f214", "ref_doc_id": "1iDQ-xjguFUR69Oi-egq8gOOyfy1OqE0z"}, "1e698d59-bb0d-4d5f-b128-e30ae75f14ec": {"doc_hash": "cbbbca6480efc136cdd0e15de3ad3a7802386695549816b64f52ce701284342e", "ref_doc_id": "1MytvHkA9kpAK7XEnHq1FdOp7Gs-2ZY4I"}, "1b8df65e-0984-4141-b72d-38962b16469d": {"doc_hash": "90d5ee19690aeaf871120f335b3b56175ed447a04ae9d5bde5744db4c0c99470", "ref_doc_id": "1Ks294UdSygCSC69ZStPwn_MK1hEqaTHJ"}, "b4db7039-71a5-4821-911c-7709922736fe": {"doc_hash": "12b01c150d5b4beb9d70286dffdaa173cd4c9388d44ad07146ba07a180aead83", "ref_doc_id": "1Ks294UdSygCSC69ZStPwn_MK1hEqaTHJ"}, "11fbd3ad-f31b-4b41-8cae-7b4f97605c85": {"doc_hash": "195882c22d7657141aa9251be6c7e048db7656501f120a74b52eb26f4c32a9a3", "ref_doc_id": "1UdzW7tbP0u6OxgDAWp1ZTXyxaw_kB8fG"}, "18a38475-8e38-4451-9197-bd745deb490b": {"doc_hash": "12417c30ad7ed7ba56ce5d1bacb18cb54df82468b16389905791f5804243710e", "ref_doc_id": "1yuiFL8iDBWMLijHQRgEpXVYNT3OyRfAa"}, "4e5ae694-6e18-4a8a-85b8-1219f633885e": {"doc_hash": "793bfc6b729845b66e673881b1ff1744365c3c0d302abe38086c8088f0bac77b", "ref_doc_id": "1pasibODDKv9HEVClYghx9bAaQ8CXjICm"}, "ca29a2af-d0e3-4b6b-ae09-e766a0206c62": {"doc_hash": "2a535373e5c6189d48e653d24d76a97fb60afd6f6e68f08f5b779239fcdb9e9e", "ref_doc_id": "1cX2ONBT9K6zdbFitoF52TTgRB0BcBxul"}, "31d9f59e-058b-4e91-833d-7def8bb1019a": {"doc_hash": "234fbedb780d3a37861932d402c59758f282785d719d46721a6d81a6cbb58e1b", "ref_doc_id": "1vJNRWl68wKXevBTH7WpeB2DkcSLTaYDz"}, "d297da2c-49e6-46ef-82f0-a1884f194087": {"doc_hash": "840aaf208421e1db719c0ab7fba3a6add5a955f1aa0b53abf70c407690360f2b", "ref_doc_id": "12I7aQKuBsQgLABEE2iiG5eTb9ca3T0rZ"}, "c6f163a2-99c1-4151-88e1-6d2921865730": {"doc_hash": "e2352b8b5521ce51090af3b8fdc4fc94c56a00caf95a0d799a977549865935d1", "ref_doc_id": "1wYuB4bqDH9kqGlPjwg81z8YkMf3sglzE"}, "8d4cfdf8-9b3c-4a92-9b03-3bceb68bb9b4": {"doc_hash": "9d5c1a5582e8c06b9dfaea9e939ce9aace407c933399b58bed4937f1c77faacb", "ref_doc_id": "1pz9Tj__OP_x5r7BYajHMjxiUbTCzyJ43"}, "92d843bc-c575-450c-a3db-ea3f71966690": {"doc_hash": "a126f1b1a400545fddf9928fa91717ca52922d9fab887d779f4778c5c0c73216", "ref_doc_id": "1KSE2Q708areAAjdbn6iH8HOmw8cWgnWN"}, "c543c9fc-2835-444f-88d9-2df16797c204": {"doc_hash": "410c06b90cbf3bc382db06a4ab1d29ee2b3affd1963eda25a4809d2336007870", "ref_doc_id": "1ODAs1Osx55qxzcOuGEBU8PnV2AQAnx_z"}, "0deb60d3-6704-43b0-a7af-7d2729780b5a": {"doc_hash": "fd176400d0e2aa1b65a9197e4f0a388bc6d2abb7c3b2f7b9557bc4a74e737d67", "ref_doc_id": "1hX8-Ai2RPVyKXPL_M415ii2av6wHFG8V"}}, "docstore/ref_doc_info": {"1GRqTJ1K_6Jg3zJQTDFcyRn3xqlmm4oLp": {"node_ids": ["6a8cef05-1b68-47bc-806f-f4c9ea813de3", "170ee425-823a-4ac3-91d2-7ba34a785a12"], "metadata": {}}, "1XpIYm1w1k_HA9YNe-I4jRjCBJl6s7McY": {"node_ids": ["0a58b0c4-9de6-4495-93a4-e27940cd72e5", "f4bc24b1-8fdb-429e-9e5f-b56fa86cae2c"], "metadata": {}}, "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA": {"node_ids": ["56ae3c85-2b02-4434-a67e-754b92821ecc", "15d37b78-8198-4345-9f01-6a1a28c02e39", "a2e0df8f-e819-4804-ab18-989900685a1f", "20281860-2860-4665-a888-e9362554ca14", "73a6d9fe-a90e-49bd-9d4f-98816f5b6d17", "e07e5462-eb3d-47e5-8956-ca5207e9b906"], "metadata": {}}, "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq": {"node_ids": ["ae55c952-1e92-416e-9b17-b2f0666e6c97", "f7fe5985-fd90-4d63-889a-e9b6a2ec7f69", "29740bbf-d6bd-4e0b-84e5-b1f8b96549fb", "30c0d51f-03e4-4e46-a799-8c97076516b6"], "metadata": {}}, "1zuWV9VpZX1hpyXkAk6JbMQL1kH_6rCT7": {"node_ids": ["bb155286-d56f-4af4-b594-c9774f83e975", "77a14b47-d23f-49a3-878f-3854f100be56"], "metadata": {}}, "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4": {"node_ids": ["8396bf4f-9cf0-4d3c-83d8-c69224bda401", "5fdcf6e7-3c1f-4bc4-bad2-ca7b37d944b2", "c73961ec-0397-49a5-b3b2-d02252a31a00", "073631f1-213b-4ee1-a318-a903a2494c31", "188c649b-3eeb-444d-a728-d8adf8af1a75", "52823b2d-9779-49d9-b3c3-cccd40fafaf0", "ff7d59fa-9ce2-42b9-b0df-307804b381cd", "264aaabd-da2c-41c3-ae64-139c6fe74359", "17fd34e9-5202-4259-bfef-a0843d8e214a", "6b2335b1-0ebf-4a6e-9afa-05059b11e8c0"], "metadata": {}}, "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk": {"node_ids": ["7234f23f-5691-4a7a-b2a7-a9d731977d07", "91911b4d-ccdc-45e1-85dd-9a061f824623", "c4fdeabc-49b2-4b33-93a8-c3bb38e009d8", "83ead083-016c-47b1-a6b4-d54873893114", "31e0fcdf-e2a1-4e6b-8178-0d391ca4b968", "349b6e8c-9853-4943-be9f-3b667da614d0", "f30d4ce1-9e6b-4456-8834-addd4ff4b0e1"], "metadata": {}}, "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO": {"node_ids": ["471b4b16-9050-4d04-b804-e5cedf48d274", "474097ba-98c1-4d53-8baa-d9fa59d81e21", "9c9b1b05-978b-4f7f-8fd2-eec55ed4b572", "e6c9a876-19cf-4c0f-ae67-64a8357c058d", "befea919-9995-4fa5-adf1-6442946beb59", "b6b55756-074c-42ba-b0bb-f76a364d60a6"], "metadata": {}}, "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3": {"node_ids": ["61f93aad-a4d3-4d8e-9420-52d245615a9a", "27aa38d8-be5c-495a-a4b4-0ea363b871ed", "3656cd17-b055-4e24-809b-26808b7132a0", "a7aa49b6-b984-41e2-b837-beeea0e9befb", "801e1b8c-445d-4ac7-b67a-058e45d8706d", "39c656e3-1237-41c8-afb1-94a247c6e73d", "53831b68-db71-4ad5-b97c-b8c14a240c07", "8ba30654-25ec-4b4f-8de7-3ed5f0026a87"], "metadata": {}}, "1v8qSwjR0XHZVzUGqi3-8KQXxMAIAab1z": {"node_ids": ["f35240c5-57ae-46c0-87e0-cdd3b9eeb67f"], "metadata": {}}, "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD": {"node_ids": ["ba1fe4b5-3746-4b80-8d6d-6c284497a113", "08db533c-e978-468b-ac88-64537e566cd6", "4652e6ee-e95e-4c65-9836-8ec61a518cca", "5cf9c845-93f8-4b8c-a5a0-99311af1b76f", "7300b9b4-b4a5-412d-b334-67426e72651b", "2a25230f-1f65-4046-859e-ae468afb24b9", "cbae03db-0e84-435c-a6eb-78e5dd785883", "8c1d31e9-f3e2-4ff1-a19b-7081436bea60", "1595030f-423a-4445-b8c8-1226894bfacb", "8d7a7e88-09a3-4e59-a88c-f116e961039e"], "metadata": {}}, "1DLoy0AfL96-C7zsCj5PdHQXErpLYF4cb": {"node_ids": ["75215201-ad11-4b0a-88bf-154b660b0716"], "metadata": {}}, "1fvTkHdyCfMHyA1s-UZCVOQ3LG9L3Fbgp": {"node_ids": ["e7984d62-c668-4c29-a7ca-61eb00c560ae", "6d700159-07c5-4510-8ed1-6bc57142c0c1"], "metadata": {}}, "1_S2NDuSdATGgkSztCXjSbV1ISkRtfr0L": {"node_ids": ["4b7e3973-523f-48d8-a8cb-d0316c5a468c", "01bbab79-dcbd-416a-b6a6-df14d812c9c4"], "metadata": {}}, "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q": {"node_ids": ["bcf697f9-d514-4cc8-8ac0-22181326e37e", "24c60fb8-d91e-4f8c-8a7a-4e39a8edbfc6", "d85977d6-6f3a-410e-a5bc-6cb60183cdb9", "2b514464-b8ce-474a-9147-ce94d4aa5301", "edfc7015-bc4c-440f-91c4-ad69148e5daf", "ef3ac94b-69df-4b1b-a820-0f7b82cf71c0", "a0053a03-aa02-4e76-90f4-54435f9b90e7", "37ad3b6d-7a5c-41b2-b8ba-d9465253165b", "b0d40a68-05a8-40db-bb83-d9b3b0fc87ab", "5e686433-3ec5-4267-8393-421d5c659ff1", "7eb92e06-26dd-4c4c-8584-6358f51ef161"], "metadata": {}}, "1BFPy-GLIB6IwW27gg1PyXr9FRD_E7VjX": {"node_ids": ["b4193740-18da-49cf-99d2-1083b744b643"], "metadata": {}}, "1y5BKWh5PJ0Rjnwnd8WaFUTggdxvJ7a7U": {"node_ids": ["7fd9acd6-83e5-430e-8027-c46850cff6d2"], "metadata": {}}, "1lBC_u8KS2OgVW2Vty9KWwdSLlJ2N7iXC": {"node_ids": ["aeece331-a7ae-438d-956f-bb8481c57f23"], "metadata": {}}, "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw": {"node_ids": ["70183aae-20df-436d-b07a-349f350e8a33", "b1680562-982f-492b-9729-3b1a1d96984a", "1e51d6b0-5915-4a00-ac60-f47b9943bd7f", "54848d0b-c7af-4b68-a393-fe2cd74318a2", "979a31c1-c1ee-4cfd-998b-9f3c54746861", "dd843e93-899f-47bd-a35e-959d531cf641"], "metadata": {}}, "18R8yKqzrNvRvGbr0t1NqcqFCKuV1_drC": {"node_ids": ["99fe27e4-ad97-4b98-90a8-6a74a105a187", "3baa6dd8-732a-4641-bb20-2a9b1b0b0490"], "metadata": {}}, "1TMdwwLSTkuoQx3FzCL6psqndi2mi905r": {"node_ids": ["38584628-c8e4-454f-9e83-ff1306495cf3", "ed59aec0-74ca-4ea8-91a0-fee9a1edcb0f"], "metadata": {}}, "1t55p_gzM0o8Mn59Ie7kGy_5tfgWfu2Rj": {"node_ids": ["4dd8126b-6010-4654-bb02-fa2d2efc3358"], "metadata": {}}, "1rrXAzl7sUuQxB92hu79t-TEIECl9m03S": {"node_ids": ["5fe7f664-78f8-4027-a331-fdccb3fc9042"], "metadata": {}}, "1TRXFu5vEtdfL1AFq8xcJlnGLufSBx6KY": {"node_ids": ["fc9b2d5a-95fe-4c40-a007-6d13d1e9780e"], "metadata": {}}, "12euCEx8S2H9bVeyf9lllhl_b-6S_R9zq": {"node_ids": ["2db2d2f0-c6f6-4195-b3b0-3dc59ea7ac8b"], "metadata": {}}, "1g0HXmmom8Ge3D12GQ8xzAWZRgAOztlld": {"node_ids": ["99eb0697-6ac5-40c3-8ee5-d2e42933ee76", "45526eaf-842e-4846-b66e-f3fd999e4aab"], "metadata": {}}, "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE": {"node_ids": ["1213d792-c8d3-4919-af63-31f65d7e74b9", "40b90bba-307b-45fd-a76d-18f13b6fc778", "50e0fb59-ded3-4db5-9c0e-e2774eacbfed", "b5f5ead1-40b1-4335-90d9-e191cf130192"], "metadata": {}}, "1bXz7sOPBKMffadkn10eBX4rosgaafaR9": {"node_ids": ["1f563a14-97b1-476b-bdca-6df43c08b366", "f359db91-4586-4829-8f61-06a133bd91d8", "8a2238e7-e350-4289-a58b-c5e29689cb76", "27c38ba3-43d0-4408-91df-391f2ce25746"], "metadata": {}}, "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4": {"node_ids": ["4da78344-86da-40aa-af18-00f5db737fe0", "1e598a59-7f28-459e-8e30-c7a9c42fe6fb", "9ad75fd1-8018-4764-b823-bf3c21acdd43", "a0d72357-d55f-4b2b-a11f-763293803fb5", "a110e3ab-067d-47bf-8752-3d2dfdb29f8b"], "metadata": {}}, "1QVRbvrNOHuzYH0CuDpjq3dgfL5dQ6jRL": {"node_ids": ["09490052-257f-4dc4-a554-955adb5ad279", "61938782-0715-4710-85a1-b61b46e205ae"], "metadata": {}}, "1t1piaiKQMfJFypnF7GJmbonCIqXMqaPK": {"node_ids": ["ce1e20f1-b556-48b8-bf4b-6a41824a09b6"], "metadata": {}}, "1CBP3gQl7LyYFBjWz7F-hqDqiW4JPic5s": {"node_ids": ["44995939-02e6-4575-a6df-fc734ec4609b"], "metadata": {}}, "10J2vVm2LE41eftDu5yK7q2V0RU7E5S-Q": {"node_ids": ["f57885be-126e-44d5-a179-1566c7e5fd2f"], "metadata": {}}, "1_anc6tvWYiW_riht29MJIE7A8RFTlgG3": {"node_ids": ["dfe652ad-fd39-47e1-99cb-eae8e0398d5b"], "metadata": {}}, "17HMsm94p5WZC3m1TeEDvbLJoaBWeXALS": {"node_ids": ["8a53ca2a-c442-4007-bcca-3be344f55bfc"], "metadata": {}}, "1djsyCOgYW8lqSoHC1pF0EVROt3dchlVu": {"node_ids": ["3d65d9ab-0a0c-490b-adf7-4d4d6f71eaa8"], "metadata": {}}, "1RXuqgHQTCBMWEIRDb_TQdLegEyLPOCn4": {"node_ids": ["e07d455d-f870-4add-bc90-49e60edc18bc"], "metadata": {}}, "16bWDrtClrCDT-CzkoFfFFsrdjijKrg4H": {"node_ids": ["c7ab5284-206c-48c0-bc63-27fbf8952a65"], "metadata": {}}, "1z2bbwA6M0GCtEoDsmKnNBGrDHN1g9_m9": {"node_ids": ["93639858-14eb-4e59-b9fc-9e265d128dd5"], "metadata": {}}, "1YXeDuj80R6YrxEiB7hEx8qZnoDlXP0e-": {"node_ids": ["483e7b1a-ba9b-4f67-84d7-11bd1137b918", "03b765db-0707-4d64-939b-8aa3ad228fc5"], "metadata": {}}, "1SPPojHd2sYla__ZMZ9i1G_BLO_lFU7tJ": {"node_ids": ["4115be13-ddb1-419a-8c6e-58af077f23f0"], "metadata": {}}, "12JpJVK0Nlxyee94mrp308YBzZOEJY1_W": {"node_ids": ["89f64757-bb1e-44e5-b81c-246399329329"], "metadata": {}}, "1riXFQ2vV22GV8q2GIjQZf3dekx5yNX6c": {"node_ids": ["43010053-9e38-48f9-b46b-a82bc92029c4", "a3474416-f847-4ae1-b27b-475c9ca9eeea"], "metadata": {}}, "1iDQ-xjguFUR69Oi-egq8gOOyfy1OqE0z": {"node_ids": ["30889a60-50d3-42cd-a2be-f3c4383a7fad"], "metadata": {}}, "1MytvHkA9kpAK7XEnHq1FdOp7Gs-2ZY4I": {"node_ids": ["1e698d59-bb0d-4d5f-b128-e30ae75f14ec"], "metadata": {}}, "1Ks294UdSygCSC69ZStPwn_MK1hEqaTHJ": {"node_ids": ["1b8df65e-0984-4141-b72d-38962b16469d", "b4db7039-71a5-4821-911c-7709922736fe"], "metadata": {}}, "1UdzW7tbP0u6OxgDAWp1ZTXyxaw_kB8fG": {"node_ids": ["11fbd3ad-f31b-4b41-8cae-7b4f97605c85"], "metadata": {}}, "1yuiFL8iDBWMLijHQRgEpXVYNT3OyRfAa": {"node_ids": ["18a38475-8e38-4451-9197-bd745deb490b"], "metadata": {}}, "1pasibODDKv9HEVClYghx9bAaQ8CXjICm": {"node_ids": ["4e5ae694-6e18-4a8a-85b8-1219f633885e"], "metadata": {}}, "1cX2ONBT9K6zdbFitoF52TTgRB0BcBxul": {"node_ids": ["ca29a2af-d0e3-4b6b-ae09-e766a0206c62"], "metadata": {}}, "1vJNRWl68wKXevBTH7WpeB2DkcSLTaYDz": {"node_ids": ["31d9f59e-058b-4e91-833d-7def8bb1019a"], "metadata": {}}, "12I7aQKuBsQgLABEE2iiG5eTb9ca3T0rZ": {"node_ids": ["d297da2c-49e6-46ef-82f0-a1884f194087"], "metadata": {}}, "1wYuB4bqDH9kqGlPjwg81z8YkMf3sglzE": {"node_ids": ["c6f163a2-99c1-4151-88e1-6d2921865730"], "metadata": {}}, "1pz9Tj__OP_x5r7BYajHMjxiUbTCzyJ43": {"node_ids": ["8d4cfdf8-9b3c-4a92-9b03-3bceb68bb9b4"], "metadata": {}}, "1KSE2Q708areAAjdbn6iH8HOmw8cWgnWN": {"node_ids": ["92d843bc-c575-450c-a3db-ea3f71966690"], "metadata": {}}, "1ODAs1Osx55qxzcOuGEBU8PnV2AQAnx_z": {"node_ids": ["c543c9fc-2835-444f-88d9-2df16797c204"], "metadata": {}}, "1hX8-Ai2RPVyKXPL_M415ii2av6wHFG8V": {"node_ids": ["0deb60d3-6704-43b0-a7af-7d2729780b5a"], "metadata": {}}}, "docstore/data": {"6a8cef05-1b68-47bc-806f-f4c9ea813de3": {"__data__": {"id_": "6a8cef05-1b68-47bc-806f-f4c9ea813de3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1GRqTJ1K_6Jg3zJQTDFcyRn3xqlmm4oLp", "node_type": "4", "metadata": {}, "hash": "cf23a7c4236ea29f20a15be9cafe9407fafe1a7c978afa1a55cb54dc9f4b4915", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "170ee425-823a-4ac3-91d2-7ba34a785a12", "node_type": "1", "metadata": {}, "hash": "eae60f835f5880f60a81fb81f4174db4079da221bb685ef94a87b06db92d562f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Semester:\n 5\nPrerequisite:\n Strong programming skills and a solid understanding of algorithms and their analysis are prerequisites for learning and \napplying Design and Analysis of Algorithms | 203105101 - Fundamentals of Programming\nRationale:\n Design and Analysis of Algorithms (DAA) is crucial for efficient problem-solving and algorithm development. It provides \ntools to measure algorithm performance and make informed decisions on choosing the best algorithms for specific tasks. DAA helps \noptimize time and space complexities, leading to improved computational efficiency.\nCourse Outcome\nAfter Learning the Course the students shall be able to:\n1\n. Develop the ability to design and implement efficient algorithms for fundamental problems.\n2\n. Cultivate critical thinking skills to analyze problem requirements and constraints, allowing for the selection and modification of \nappropriate algorithms to solve specific computational problems. \n3\n. Master the use of essential data structures such as arrays, matrices, graphs, and trees to efficiently store, manage, and \nmanipulate data within algorithm implementations.\n4\n. Learn techniques for optimizing algorithms to improve their efficiency and scalability, focusing on aspects such as time \ncomplexity, and space complexity,\nTeaching and Examination Scheme\nTeaching Scheme\nCredit\nExamination Scheme\nTotal\nLecture\nHrs/Week\nTutorial\nHrs/Week\nLab\nHrs/Week\nHrs/Week\nInternal Marks\nExternal Marks\nT\nP\nT\nP\n0\n0\n2\n0\n1\n-\n20\n-\n30\n50\nSEE\n - Semester End Examination, \nCIA\n - Continuous Internal Assessment (It consists of Assignments/Seminars/Presentations/MCQ Tests, etc.)\nCE\n-\nCourse:\n BTech\nPage 1 of 2\nPrinted on : 08-06-2024 10:39 AM\nSubject Syllabus \n303105219 - Design and Analysis of Algorithm Laboratory\n\nList of Practical\n1.\nwrite a program to determine whether the given number is Prime or not.\n2.\nGiven a sorted array and a target value,return the index if the target is found. If not,return the index where it would be if \nit were inserted in order.\n3.\nThere are N children standing in a line with some rating value. You want to distribute a minimum number of candies to \nthese children such that: Each child must have at least one candy. The children with higher ratings will have more candies \nthan their neighbours. You need to write a program to calculate the minimum candies you must give.\n4.\nThere is a new barn with N stalls and C cows. The stalls are located on a straight line at positions x1,xN (0 <= xi <= \n1,000,000,000). We want to assign the cows to the stalls, such that the minimum distance between any two of them is as \nlarge as possible. What is the largest minimum distance?\n5.\nGiven an undirected graph with V vertices and E edges, check whether it contains any cycle or not\n6.\nThere are n servers numbered from 0 to n \n\u2013 1 \nconnected by undirected server-to-server connections forming a network \nwhere connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers \ndirectly or indirectly through the network.A critical connection is a connection that, if removed, will make some servers \nunable to reach some other servers. Return all critical connections in the network in any order.\n7.\nGiven a grid of size NxM (N is the number of rows and M is the number of columns in the grid) consisting of \n\u20180\u2019\ns (Water) \nand \n\u20181\u2019\ns(Land). Find the number of islands.\n8.\nGiven a grid of dimension N x M where each cell in the grid can have values \n0\n, \n1\n, or \n2\n which has e \nfollowing meaning:\n0\n: Empty cell\n1\n: Cells have fres\n2\n. Cells have oran\nrotten oranges\nWe have to determine what is the minimum time required to rot all oranges. A rotten orange at index [i,j] can rot other fresh \noranges at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in unit time\n\u2019\n9.\nGiven two strings str1 and str2 and below operations that can be performed on str1. Find minimum number of edits \n(operations) required to convert \n\u2018\nstr1\n\u2019 \ninto \n\u2018\nstr2\n\u2019. \nInsert Remove Replace, All of the above operations are of equal cost.\n10.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4066, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "170ee425-823a-4ac3-91d2-7ba34a785a12": {"__data__": {"id_": "170ee425-823a-4ac3-91d2-7ba34a785a12", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1GRqTJ1K_6Jg3zJQTDFcyRn3xqlmm4oLp", "node_type": "4", "metadata": {}, "hash": "cf23a7c4236ea29f20a15be9cafe9407fafe1a7c978afa1a55cb54dc9f4b4915", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6a8cef05-1b68-47bc-806f-f4c9ea813de3", "node_type": "1", "metadata": {}, "hash": "3352cb4657b99c5cddc95b1a43391499e7fb03ed22279c5a46d8136e7ec5f63b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Cells have oran\nrotten oranges\nWe have to determine what is the minimum time required to rot all oranges. A rotten orange at index [i,j] can rot other fresh \noranges at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in unit time\n\u2019\n9.\nGiven two strings str1 and str2 and below operations that can be performed on str1. Find minimum number of edits \n(operations) required to convert \n\u2018\nstr1\n\u2019 \ninto \n\u2018\nstr2\n\u2019. \nInsert Remove Replace, All of the above operations are of equal cost.\n10.\nMinimum Path Sum\n\u201d \nsays that given a n x m grid consisting of non-negative integers and we need to find a path from top-\nleft to bottom right, which minimizes the sum of all numbers along the path.\n11.\nGiven string num representing a non-negative integer num, and an integer k, return the smallest possible integer after \nremoving k digits from num.\n12.\nThere is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]).The robot tries to \nmove to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in \ntime.Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the \nbottom-right corner.\nMiscellaneous\nExam Requirement\nIt consists of Assignments/Seminars/Presentations/Quizzes/Surprise Tests (Summative/MCQ) etc\nPage 2 of 2\nPrinted on : 08-06-2024 10:39 AM\nSubject Syllabus \n303105219 - Design and Analysis of Algorithm Laboratory", "mimetype": "text/plain", "start_char_idx": 3561, "end_char_idx": 5053, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0a58b0c4-9de6-4495-93a4-e27940cd72e5": {"__data__": {"id_": "0a58b0c4-9de6-4495-93a4-e27940cd72e5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XpIYm1w1k_HA9YNe-I4jRjCBJl6s7McY", "node_type": "4", "metadata": {}, "hash": "f0d871625f58cc001f53010056415c52466ab9d173f308c57b4007414671c34d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4bc24b1-8fdb-429e-9e5f-b56fa86cae2c", "node_type": "1", "metadata": {}, "hash": "abf5c846c757e13cb3a5eedc6d9df1b20cb0fec503d63bce5c1a715be92fdb46", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Semester:\n 5\nPrerequisite:\n Data structures, Fundamental of programming\nRationale:\n Analyze the asymptotic performance of algorithms. Write rigorous correctness proofs for algorithms. Demonstrate a \nfamiliarity with major algorithms and data structures. Apply important algorithmic design paradigms and methods of analysis. \nSynthesize efficient algorithms in common engineering design situations.\nTeaching and Examination Scheme\nTeaching Scheme\nCredit\nExamination Scheme\nTotal\nLecture\nHrs/Week\nTutorial\nHrs/Week\nLab\nHrs/Week\nHrs/Week\nInternal Marks\nExternal Marks\nT\nP\nT\nP\n3\n0\n0\n0\n3\n20\n-\n60\n-\n100\nSEE\n - Semester End Examination, \nCIA\n - Continuous Internal Assessment (It consists of Assignments/Seminars/Presentations/MCQ Tests, etc.)\nCE\n20\nCourse:\n BTech\nCourse Content\nW \n- Weightage (%) , \nT \n- Teaching hours\nSr.\nTopics\nW\nT\n1\nIntroduction and Analysis of Algorithms:\nAlgorithm: Definition, Properties, Types of Algorithms, Writing an Algorit\nAlgorithm Analysis: Parameters, Design \nTechniques of Algorithms\n \nAsymptotic Analysis: Big Oh, Big Omega & Big Theta Notations, Lower Bound, Upper Bound and Tight Bound, Best \nCase, Worst Case, Average Case\n \nAnalyzing control statement, Loop invariant and the correctness of the algorithm, Recurrences- substitution \nmethod, recursion tree method, master method. \n \nSorting Techniques with analysis: Bubble Sort, Selection Sort, Insertion sort. \n20\n10\n2\nDivide & Conquer Algorithms:\nStructure of divide-and-conquer algorithms, examples: Binary search, quick sort, Merge sort\n, \nStrassen \nMultiplication; Max-Min problem\n20\n6\n3\nGreedy Algorithms:\nIntroduction, Elements of Greedy Strategy\n \n- Minimum Spanning Tree: Kruskal's & Prim's Algorithm, Dijkstra\n\u2019\ns Algorithm, Knapsack Problem, Activity Selection \nProblem, Huffman Codes\n20\n8\n4\nDynamic Programming:\nPrincipal of Optimality, \n0/1\n Knapsack Problem, Making Change problem, Chain \nmatrix multiplication, Longest \nCommon Subsequence, All pair shortest paths: Warshall\n\u2019\ns and Floyd\n\u2019\ns algorithms\n20\n8\n5\nExploring Graphs:\nAn introduction using graphs and games, Undirected Graph, Directed Graph, Traversing Graphs, Depth First Search, \nBreath First Search, Topological sort\n5\n3\n6\nBacktracking and Branch & Bound:\nIntroduction to Backtracking, Introduction to Branch & Bound, \n0/1\n Knapsack Problem, N-Queens Problem, Travelling \nSalesman Problem\n5\n4\n7\nString Matching & NP Completeness:\nString Matching:\n \n- \nIntroduction to String Matching, \nNaive String Matching, Rabin-Karp Algorithm, Kruth-Morris-Pratt Algorithm, String \nMatching using Finite Automata\n \nNP Completeness:\n \n- Introduction to NP Completeness,  \nP class Problems, NP Class Problems, Hamiltonian Cycle\n10\n6\nPage 1 of 2\nPrinted on : 08-06-2024 10:38 AM\nSubject Syllabus \n303105218 - Design and Analysis of Algorithm\n\nCourse Outcome\nAfter Learning the Course the students shall be able to:\nCourse Outcome: After learning the course the students will be able to: \n1\n. Develop the ability to analyze the running time of any given algorithm using asymptotic analysis and prove the correctness of \nbasic algorithms.\n2\n. Design efficient algorithms for computational problems, using various algorithm design techniques taught in the course.\n3\n. Explain the major graph algorithms and their analyses. Employ graphs to model engineering problems, when appropriate.\n4\n. Analyze String matching algorithms.\n5\n. Explain the complexity classes P, NP, and NP-Complete, and demonstrate the NP-Completeness of a specific problems.\nReference Books\n1.\nIntroduction to Algorithms, \n4\nTH Edition, Thomas H Cormen, Charles E Lieserson, Ronald L Rivest and Clifford Stein, MIT \nPress/McGraw-Hill. (TextBook)\n2.\nFundamentals of Algorithms \n\u2013 \nE. Horowitz et al. (TextBook)\n3.\nAlgorithm Design, \n1\nST Edition, Jon Kleinberg and \u00c9vaTardos, Pearson\n4.\nAlgorithm Design: Foundations, Analysis, and Internet Examples, Second Edition, Michael T Goodrich and Roberto \nTamassia, Wiley.\n5.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3930, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f4bc24b1-8fdb-429e-9e5f-b56fa86cae2c": {"__data__": {"id_": "f4bc24b1-8fdb-429e-9e5f-b56fa86cae2c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XpIYm1w1k_HA9YNe-I4jRjCBJl6s7McY", "node_type": "4", "metadata": {}, "hash": "f0d871625f58cc001f53010056415c52466ab9d173f308c57b4007414671c34d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a58b0c4-9de6-4495-93a4-e27940cd72e5", "node_type": "1", "metadata": {}, "hash": "65431af21a306fb90c12ddce815419c922952173fd2b6969204542c046638f36", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3\n. Explain the major graph algorithms and their analyses. Employ graphs to model engineering problems, when appropriate.\n4\n. Analyze String matching algorithms.\n5\n. Explain the complexity classes P, NP, and NP-Complete, and demonstrate the NP-Completeness of a specific problems.\nReference Books\n1.\nIntroduction to Algorithms, \n4\nTH Edition, Thomas H Cormen, Charles E Lieserson, Ronald L Rivest and Clifford Stein, MIT \nPress/McGraw-Hill. (TextBook)\n2.\nFundamentals of Algorithms \n\u2013 \nE. Horowitz et al. (TextBook)\n3.\nAlgorithm Design, \n1\nST Edition, Jon Kleinberg and \u00c9vaTardos, Pearson\n4.\nAlgorithm Design: Foundations, Analysis, and Internet Examples, Second Edition, Michael T Goodrich and Roberto \nTamassia, Wiley.\n5.\nAlgorithms\n\u2014\nA Creative Approach,\n3\nRD Edition, UdiManber, Addison-Wesley, Reading, MA\nMiscellaneous\nExam Requirement\nIt consists of Assignments/Seminars/Presentations/Quizzes/Surprise Tests (Summative/MCQ) etc\nPage 2 of 2\nPrinted on : 08-06-2024 10:38 AM\nSubject Syllabus \n303105218 - Design and Analysis of Algorithm", "mimetype": "text/plain", "start_char_idx": 3207, "end_char_idx": 4249, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "56ae3c85-2b02-4434-a67e-754b92821ecc": {"__data__": {"id_": "56ae3c85-2b02-4434-a67e-754b92821ecc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA", "node_type": "4", "metadata": {}, "hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "15d37b78-8198-4345-9f01-6a1a28c02e39", "node_type": "1", "metadata": {}, "hash": "bdd95c19a2daa38d61975b4db5dbea14d6ce508f5b72bffc3fe71ebf8152097c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nString Matching & NP Completeness\nChapter -7\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.String Matching:\n\u2022Introduction to String Matching, \n\u2022Naive String Matching, \n\u2022Rabin -Karp Algorithm,\n2. Kruth -Morris -Pratt Algorithm, \n\u2022String Matching using Finite Automata\n3. NP Completeness:\n\u2022Introduction to NP Completeness, \n\u2022P class Problems, \n\u2022NP Class Problems, \n\u2022Hamiltonian CycleContent INDEX\nIntroduction to String Matching\n\u2022Text -editing programs frequently need tofind alloccurrences ofa\npattern inthetext.\n\u2022Efficient algorithms for this problem iscalled String -Matching\nAlgorithms .\n\u2022Among itsmany applications, \u201cString -Matching\u201d ishighly used in\nSearching forpatterns inDNA and Internet search engines .\n\u2022Assume that thetext isrepresented intheform ofanarray\ud835\udc7b[\ud835\udfcf\u2026\ud835\udc8f]and\nthepattern isanarray\ud835\udc77[\ud835\udfcf\u2026\ud835\udc8e].", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 885, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "15d37b78-8198-4345-9f01-6a1a28c02e39": {"__data__": {"id_": "15d37b78-8198-4345-9f01-6a1a28c02e39", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA", "node_type": "4", "metadata": {}, "hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "56ae3c85-2b02-4434-a67e-754b92821ecc", "node_type": "1", "metadata": {}, "hash": "b80e148bbd496571136279ed8463850d014665aa28f7e255de049914d7ead72d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a2e0df8f-e819-4804-ab18-989900685a1f", "node_type": "1", "metadata": {}, "hash": "d66bf6954762820ebdfc1da997a2907d30bcb7060d9e4ef99e3ecad98d19b30a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Kruth -Morris -Pratt Algorithm, \n\u2022String Matching using Finite Automata\n3. NP Completeness:\n\u2022Introduction to NP Completeness, \n\u2022P class Problems, \n\u2022NP Class Problems, \n\u2022Hamiltonian CycleContent INDEX\nIntroduction to String Matching\n\u2022Text -editing programs frequently need tofind alloccurrences ofa\npattern inthetext.\n\u2022Efficient algorithms for this problem iscalled String -Matching\nAlgorithms .\n\u2022Among itsmany applications, \u201cString -Matching\u201d ishighly used in\nSearching forpatterns inDNA and Internet search engines .\n\u2022Assume that thetext isrepresented intheform ofanarray\ud835\udc7b[\ud835\udfcf\u2026\ud835\udc8f]and\nthepattern isanarray\ud835\udc77[\ud835\udfcf\u2026\ud835\udc8e].\nabcabaabcabac\nabaaText T[1..13]\nPattern \nP[1..4]\nNaive String Matching\n\u2022The naive algorithm finds all valid shifts using a loop that checks the \ncondition P[1..m] = T[s+1..s+m]\nacaab\naab\ns = 0c acaab\naab\ns = 1c acaab\naab\ns = 2c\nacaab\naab\ns = 3c\nPattern matched with shift \n2\nP[1..m] = T[s+1..s+m]\nNaive String Matching\nacaab\naabc T[1..6]\nP[1..3] aabaabaab\ns = 0123\nPattern occurs with shift 2\n\nRabin -Karp Algorithm\nRABIN -KARP -MATCHER(T, P, d, q)\nn \u2190 length[T];\nm \u2190 length[P];\nh \u2190 dm-1mod q;\np\u2190 0;\nt0\u2190 0;\nfor i\u2190 1 to m do \np\u2190 (dp+ P[ i]) mod q\nt0\u2190 (dt0+ T[ i]) mod q\nfor s \u2190 0 to n \u2013m do \nif p== tsthen\nif P[1..m] == T[s+1..s+m] then \nprint \u201cpattern occurs with shift\u201d s\nif s < n -m then \nts+1\u2190 (d( ts\u2013T[s+1]h) + T[s+m+1]) mod qT31415926535\nP26d10 q11\nn11 m2 h10\np0 t00 p4 t09\n31415926535 Text T\nPattern P 26\nChoose a random prime number q = 11\nLet,   p = P mod q \n= 26 mod 11 = 4\nLet tsdenotes modulo qfor text of length m\n31415926535\ud835\udc61\ud835\udc600=31\ud835\udc5a\ud835\udc5c\ud835\udc51 11=9\n\ud835\udc61\ud835\udc601=14\ud835\udc5a\ud835\udc5c\ud835\udc51 11=3\n\ud835\udc61\ud835\udc602=41\ud835\udc5a\ud835\udc5c\ud835\udc51 11=8\n\ud835\udc61\ud835\udc603=15\ud835\udc5a\ud835\udc5c\ud835\udc51 11=4\n\ud835\udc61\ud835\udc604=59\ud835\udc5a\ud835\udc5c\ud835\udc51 11=4\n\ud835\udc61\ud835\udc605=92\ud835\udc5a\ud835\udc5c\ud835\udc51 11=4\n\ud835\udc61\ud835\udc606=26\ud835\udc5a\ud835\udc5c\ud835\udc51 11=4\n\ud835\udc61\ud835\udc607=65\ud835\udc5a\ud835\udc5c\ud835\udc51 11=10\n\ud835\udc61\ud835\udc608=53\ud835\udc5a\ud835\udc5c\ud835\udc51 11=9\n\ud835\udc61\ud835\udc609=35\ud835\udc5a\ud835\udc5c\ud835\udc51 11=2\nText TPattern \nP26p = P mod q = 26 mod 11 = 4\n31415926535\n93844441092\nif  ts== p\nif P[1..m] == T[s+1..s+m]\nprint \u201cpattern occurs with shift\u201d sts\nSpurious \nHitValid \nmatch26\n\u2022We can compute \ud835\udc61\ud835\udc60using following formula \nts+1 = 10(ts-10m-1T[s+1]) + T[s + m + 1]  \n31415926535\nFor m=2 and s=0 ts= 31\nWewish toremove higher order digit T[s+1]=3and bring the\nnew lower order digit T[s+m+ 1]=4\nts+1=10(31-10\u00b73)+4\n=10(1)+4=14\nts+2=10(14-10\u00b71)+1\n=10(4)+1=41\nString Matching with Finite Automata\n\u2022Finite automaton (FA) isasimple machine, used torecognize\npatterns .", "mimetype": "text/plain", "start_char_idx": 276, "end_char_idx": 2527, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a2e0df8f-e819-4804-ab18-989900685a1f": {"__data__": {"id_": "a2e0df8f-e819-4804-ab18-989900685a1f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA", "node_type": "4", "metadata": {}, "hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "15d37b78-8198-4345-9f01-6a1a28c02e39", "node_type": "1", "metadata": {}, "hash": "bdd95c19a2daa38d61975b4db5dbea14d6ce508f5b72bffc3fe71ebf8152097c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "20281860-2860-4665-a888-e9362554ca14", "node_type": "1", "metadata": {}, "hash": "5208cd50700b61fb939de3a351133fa30742b660b376acc1cc1ba7551526d662", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Ithasasetofstates and rules formoving from one state toanother .\n\u2022Ittakes the string ofsymbol asinput and changes itsstate\naccordingly .When the desired symbol isfound, then the transition\noccurs .\n\u2022Atthetime oftransition, theautomata can either move tothenext\nstate orstay inthesame state .\n\u2022When the input string isprocessed successfully, and the automata\nreached itsfinal state ,then itwillaccept theinput string .\n\u2022The string -matching automaton isvery efficient :itexamines each\ncharacter inthetext exactly once and reports allthevalid shifts .\nString Matching with Finite Automata\nA finite automaton M is a 5 -tuple, which consists of,\n(\ud835\udc78,\ud835\udc92\ud835\udfce,\ud835\udc68,\ud835\udf2e,\ud835\udf39)\n\ud835\udc78is a finite set of states ,\n\ud835\udc92\ud835\udfce\ud835\udedc\ud835\udc78is a start state ,\n\ud835\udc68\u2286\ud835\udc78set of accepting states ,\n\ud835\udebais a finite input alphabet ,\n\ud835\udf39is a transition function of M.\n\nString Matching with Finite Automata\n\u2022Suffix of a string is any number of trailing symbols of that string. If a string \n\ud835\udedais a suffix of a string \ud835\udc99then it is denoted by \ud835\udf4e\u2290\ud835\udc99.\n\ud835\udc43=\ud835\udc4e\ud835\udc4f\ud835\udc4e\ud835\udc4f\ud835\udc4e\n\ud835\udc431=\ud835\udc4e \ud835\udc77\ud835\udfcf\u2290\ud835\udc77\n\ud835\udc432=\ud835\udc4f\ud835\udc4e \ud835\udc77\ud835\udfd0\u2290\ud835\udc77\n\ud835\udc433=\ud835\udc4e\ud835\udc4f\ud835\udc4e \ud835\udc77\ud835\udfd1\u2290\ud835\udc77\n\ud835\udc434=\ud835\udc4f\ud835\udc4e\ud835\udc4f\ud835\udc4e \ud835\udc77\ud835\udfd2\u2290\ud835\udc77\n\ud835\udc435=\ud835\udc4e\ud835\udc4f\ud835\udc4e\ud835\udc4f\ud835\udc4e =\ud835\udc43 \ud835\udc77\ud835\udfd3\u2290\ud835\udc77\nCompute Transition Function\nCOMPUTE -TRANSITION -FUNCTION(P,  \u03a3 )\nm \u2190 length[P]\nfor q \u2190 0 to m do\nfor each character \u03b1 \u0404 \u03a3 do\nk \u2190 min(m + 1, q + 2)\nrepeat k \u2190 k \u20131 until Pk\u2290Pq\u03b1\n\u03b4(q, \u03b1) \u2190 k\nreturn \u03b4\nIntroduction & Programming with \nESP8266\nString Matching & NP Completeness\nChapter -7\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.String Matching:\n\u2022Introduction to String Matching, \n\u2022Naive String Matching, \n\u2022Rabin -Karp Algorithm,\n2. Kruth -Morris -Pratt Algorithm, \n\u2022String Matching using Finite Automata\n3. NP Completeness:\n\u2022Introduction to NP Completeness, \n\u2022P class Problems, \n\u2022NP Class Problems, \n\u2022Hamiltonian CycleContent INDEX\nKruth -Morris -Pratt Algorithm\n\u2022The KMP algorithm relies on prefix function (\u03c0).\n\u2022Proper prefix: All the characters in a string, with one or more cut off \nthe end. \u201cS\u201d, \u201cSn\u201d, \u201c Sna\u201d, and \u201cSnap\u201d are all the proper prefixes of \n\u201cSnape\u201d.\n\u2022Proper suffix: All the characters in a string, with one or more cut off \nthe beginning. \u201c agrid \u201d, \u201cgrid\u201d, \u201crid\u201d, \u201cid\u201d, and \u201cd\u201d are all proper \nsuffixes of \u201cHagrid\u201d.", "mimetype": "text/plain", "start_char_idx": 2528, "end_char_idx": 4647, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "20281860-2860-4665-a888-e9362554ca14": {"__data__": {"id_": "20281860-2860-4665-a888-e9362554ca14", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA", "node_type": "4", "metadata": {}, "hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a2e0df8f-e819-4804-ab18-989900685a1f", "node_type": "1", "metadata": {}, "hash": "d66bf6954762820ebdfc1da997a2907d30bcb7060d9e4ef99e3ecad98d19b30a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73a6d9fe-a90e-49bd-9d4f-98816f5b6d17", "node_type": "1", "metadata": {}, "hash": "cf63080785918c9ddcf991ed66496c1dc8b7caeb3bcd02e3112d1d1765b43c07", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Kruth -Morris -Pratt Algorithm, \n\u2022String Matching using Finite Automata\n3. NP Completeness:\n\u2022Introduction to NP Completeness, \n\u2022P class Problems, \n\u2022NP Class Problems, \n\u2022Hamiltonian CycleContent INDEX\nKruth -Morris -Pratt Algorithm\n\u2022The KMP algorithm relies on prefix function (\u03c0).\n\u2022Proper prefix: All the characters in a string, with one or more cut off \nthe end. \u201cS\u201d, \u201cSn\u201d, \u201c Sna\u201d, and \u201cSnap\u201d are all the proper prefixes of \n\u201cSnape\u201d.\n\u2022Proper suffix: All the characters in a string, with one or more cut off \nthe beginning. \u201c agrid \u201d, \u201cgrid\u201d, \u201crid\u201d, \u201cid\u201d, and \u201cd\u201d are all proper \nsuffixes of \u201cHagrid\u201d.\n\u2022KMP algorithm works as follows:\n\u2022Step -1: Calculate Prefix Function\n\u2022Step -2: Match Pattern with Text\nLongest Common Prefix and Suffix\n1234567\nPattern ababaca\nPrefix(\u03c0\n)0012301\nWe have no possible prefixes \nWe have no possible suffixes a\nab\nPossible prefix = a\nPossible suffix = b \naba\nPossible prefix = a, ab\nPossible suffix = a, baabab\nPossible prefix = a, ab, aba\nPossible suffix = b, ab, babababa\nPossible prefix = a, ab, aba, \nabab\nPossible suffix = a, ba, aba, \nbaba \nCalculate Prefix Function -Example\n1 2 3 4 5 6 7\nP a c a c a g t\n\u03c0 0 0 1 2 3 0 0\nq\n k+1\nInitially set \u03c0[1] = 0\nk is the longest prefix found\nq is the current index of \npatternq  = k  =  0\n23456712310\nk+1\n q\n\nKMP -Compute Prefix Function\nKMP -MATCHER(T, P)\nn \u2190 length[T]\nm \u2190 length[P]\n\u03c0 \u2190 COMPUTE -PREFIX -FUNCTION(P) \nq \u2190 0                          //Number of characters matched.\nfor i\u2190 1 to n                 //Scan the text from left to right. \nwhile q > 0 and P[q + 1] \u2260 T[ i]\nq \u2190 \u03c0[q]    //Next character does not match. \nif P[q + 1] == T[ i] then\nthen q \u2190 q + 1      //Next character matches.\nif q == m then           //Is all of P matched? \nprint \"Pattern occurs with shift\" i-m\nq \u2190 \u03c0[q]    //Look for the next match. \nKMP -Compute Prefix Function\nTacatacgacacagt\nacacagtMismatch ?\nCheck value in prefix \ntable We can skip 2 shifts\n(Skip unnecessary \nshifts) acacagt\nTacatacgacacagt\nacacagtMismatch ?\nCheck value in prefix \ntable\nTacatacgacacagt\nacacagtMismatch ?\nCheck value in prefix \ntable\n\nKMP -Compute Prefix Function\nTacatacgacacagt\nacacagtMismatch ?\nCheck value in prefix \ntableWe can skip 2 shifts\n(Skip unnecessary \nshifts) Tacatacgacacagt\nacacagt\nTacatacgacacagt\nacacagt\nPattern matches with shift  \ud835\udc56\u2212\n\nKMP -Compute Prefix Function\nKMP -MATCHER(T, P)\nn \u2190 length[T]\nm \u2190 length[P]\n\u03c0 \u2190 COMPUTE -PREFIX -FUNCTION(P) \nq \u2190 0                          //Number of characters matched.\nfor i\u2190 1 to n                 //Scan the text from left to right. \nwhile q > 0 and P[q + 1] \u2260 T[ i]\nq \u2190 \u03c0[q]    //Next character does not match. \nif P[q + 1] == T[ i] then\nthen q \u2190 q + 1      //Next character matches.\nif q == m then           //Is all of P matched? \nprint \"Pattern occurs with shift\" i-m\nq \u2190 \u03c0[q]    //Look for the next match. \nString Matching with Finite Automata\n\u2022Finite automaton (FA) isasimple machine, used torecognize\npatterns .\n\u2022Ithasasetofstates and rules formoving from one state toanother .\n\u2022Ittakes the string ofsymbol asinput and changes itsstate\naccordingly .When the desired symbol isfound, then the transition\noccurs .\n\u2022Atthetime oftransition, theautomata can either move tothenext\nstate orstay inthesame state .\n\u2022When the input string isprocessed successfully, and the automata\nreached itsfinal state ,then itwillaccept theinput string .", "mimetype": "text/plain", "start_char_idx": 4046, "end_char_idx": 7386, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73a6d9fe-a90e-49bd-9d4f-98816f5b6d17": {"__data__": {"id_": "73a6d9fe-a90e-49bd-9d4f-98816f5b6d17", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA", "node_type": "4", "metadata": {}, "hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "20281860-2860-4665-a888-e9362554ca14", "node_type": "1", "metadata": {}, "hash": "5208cd50700b61fb939de3a351133fa30742b660b376acc1cc1ba7551526d662", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e07e5462-eb3d-47e5-8956-ca5207e9b906", "node_type": "1", "metadata": {}, "hash": "2be5d78203f8cc167939771d404337bbb087854095556023373a822747a4fb6f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "if P[q + 1] == T[ i] then\nthen q \u2190 q + 1      //Next character matches.\nif q == m then           //Is all of P matched? \nprint \"Pattern occurs with shift\" i-m\nq \u2190 \u03c0[q]    //Look for the next match. \nString Matching with Finite Automata\n\u2022Finite automaton (FA) isasimple machine, used torecognize\npatterns .\n\u2022Ithasasetofstates and rules formoving from one state toanother .\n\u2022Ittakes the string ofsymbol asinput and changes itsstate\naccordingly .When the desired symbol isfound, then the transition\noccurs .\n\u2022Atthetime oftransition, theautomata can either move tothenext\nstate orstay inthesame state .\n\u2022When the input string isprocessed successfully, and the automata\nreached itsfinal state ,then itwillaccept theinput string .\n\u2022The string -matching automaton isvery efficient :itexamines each\ncharacter inthetext exactly once and reports allthevalid shifts .\nString Matching with Finite Automata\nA finite automaton M is a 5 -tuple, which consists of,\n(\ud835\udc78,\ud835\udc92\ud835\udfce,\ud835\udc68,\ud835\udf2e,\ud835\udf39)\n\ud835\udc78is a finite set of states ,\n\ud835\udc92\ud835\udfce\ud835\udedc\ud835\udc78is a start state ,\n\ud835\udc68\u2286\ud835\udc78set of accepting states ,\n\ud835\udebais a finite input alphabet ,\n\ud835\udf39is a transition function of M.\n\nString Matching with Finite Automata\n\u2022Suffix of a string is any number of trailing symbols of that string. If a string \n\ud835\udedais a suffix of a string \ud835\udc99then it is denoted by \ud835\udf4e\u2290\ud835\udc99.\n\ud835\udc43=\ud835\udc4e\ud835\udc4f\ud835\udc4e\ud835\udc4f\ud835\udc4e\n\ud835\udc431=\ud835\udc4e \ud835\udc77\ud835\udfcf\u2290\ud835\udc77\n\ud835\udc432=\ud835\udc4f\ud835\udc4e \ud835\udc77\ud835\udfd0\u2290\ud835\udc77\n\ud835\udc433=\ud835\udc4e\ud835\udc4f\ud835\udc4e \ud835\udc77\ud835\udfd1\u2290\ud835\udc77\n\ud835\udc434=\ud835\udc4f\ud835\udc4e\ud835\udc4f\ud835\udc4e \ud835\udc77\ud835\udfd2\u2290\ud835\udc77\n\ud835\udc435=\ud835\udc4e\ud835\udc4f\ud835\udc4e\ud835\udc4f\ud835\udc4e =\ud835\udc43 \ud835\udc77\ud835\udfd3\u2290\ud835\udc77\nCompute Transition Function\nCOMPUTE -TRANSITION -FUNCTION(P,  \u03a3 )\nm \u2190 length[P]\nfor q \u2190 0 to m do\nfor each character \u03b1 \u0404 \u03a3 do\nk \u2190 min(m + 1, q + 2)\nrepeat k \u2190 k \u20131 until Pk\u2290Pq\u03b1\n\u03b4(q, \u03b1) \u2190 k\nreturn \u03b4\nIntroduction & Programming with \nESP8266\nString Matching & NP Completeness\nChapter -7\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.String Matching:\n\u2022Introduction to String Matching, \n\u2022Naive String Matching, \n\u2022Rabin -Karp Algorithm,\n2. Kruth -Morris -Pratt Algorithm, \n\u2022String Matching using Finite Automata\n3. NP Completeness:\n\u2022Introduction to NP Completeness, \n\u2022P class Problems, \n\u2022NP Class Problems, \n\u2022Hamiltonian CycleContent INDEX\nNP completeness\n\u2022isafoundational concept incomputational complexity theory that\naddresses the classification ofproblems based ontheir solvability\nand theresources required tosolve them .\n\u2022This framework helps categorize problems into manageable classes\nand provides insight into thelimits ofalgorithmic solutions .\n\u2022The terms P,NP, and NP-complete arecritical inunderstanding this\ncomplex web ofcomputational challenges .\nThe Class P\n\u2022The class Pconsists ofthose problems that are solvable in\npolynomial time bydeterministic algorithms .\n\u2022More specifically, they are problems that can besolved intime\n\ud835\udc42(\ud835\udc5b^\ud835\udc58)forsome constant \ud835\udc58,where\ud835\udc5bisthesize oftheinput tothe\nproblem .\n\u2022For example, \ud835\udc42(\ud835\udc5b^3),\ud835\udc42(\ud835\udc5b^4),\ud835\udc42(\ud835\udc59\ud835\udc5c\ud835\udc54\ud835\udc5b),Fractional Knapsack, MST,\nSorting algorithms etc\u2026\n\u2022Pisacomplexity class that represents the set ofalldecision\nproblems that canbesolved inpolynomial time .\n\u2022That is,given aninstance oftheproblem, theanswer yesornocan\nbedecided inpolynomial time .\nThe NP class\n\u2022NPisNon -Deterministic polynomial time .", "mimetype": "text/plain", "start_char_idx": 6662, "end_char_idx": 9692, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e07e5462-eb3d-47e5-8956-ca5207e9b906": {"__data__": {"id_": "e07e5462-eb3d-47e5-8956-ca5207e9b906", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1XFFcKNmTrnPfDXe3oal8cjO2v0xoYPyA", "node_type": "4", "metadata": {}, "hash": "372c5a72479fc185daed5d07993f3f26506bb2c5930147c65f2b5d3384727b0d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73a6d9fe-a90e-49bd-9d4f-98816f5b6d17", "node_type": "1", "metadata": {}, "hash": "cf63080785918c9ddcf991ed66496c1dc8b7caeb3bcd02e3112d1d1765b43c07", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The Class P\n\u2022The class Pconsists ofthose problems that are solvable in\npolynomial time bydeterministic algorithms .\n\u2022More specifically, they are problems that can besolved intime\n\ud835\udc42(\ud835\udc5b^\ud835\udc58)forsome constant \ud835\udc58,where\ud835\udc5bisthesize oftheinput tothe\nproblem .\n\u2022For example, \ud835\udc42(\ud835\udc5b^3),\ud835\udc42(\ud835\udc5b^4),\ud835\udc42(\ud835\udc59\ud835\udc5c\ud835\udc54\ud835\udc5b),Fractional Knapsack, MST,\nSorting algorithms etc\u2026\n\u2022Pisacomplexity class that represents the set ofalldecision\nproblems that canbesolved inpolynomial time .\n\u2022That is,given aninstance oftheproblem, theanswer yesornocan\nbedecided inpolynomial time .\nThe NP class\n\u2022NPisNon -Deterministic polynomial time .\n\u2022The class NP consists ofthose problems that are verifiable in\npolynomial time .\n\u2022NPistheclass ofdecision problems forwhich itiseasy tocheck the\ncorrectness ofaclaimed answer, with the help ofalittle extra\ninformation .\n\u2022Hence, wearenot asking foraway tofind asolution, but only to\nverify that analleged solution really iscorrect .\n\u2022Every problem inthis class can besolved inexponential time using\nexhaustive search .\nP and NP Class Problems\n\u2022P = set of problems that can be solved in polynomial time\n\u2022NP = set of problems for which a solution can be verified in polynomial \ntime\n\u2022\ud835\udc43\uf0cd\ud835\udc41\ud835\udc43\n\nClassification of NP Problems \nNPComplete\n\u2022NP-complete problems areasetofproblems toeach ofwhich any\nother NP-problem can bereduced inpolynomial time, and whose\nsolution may stillbeverified inpolynomial time .\n\u2022No polynomial -time algorithm has been discovered for anNP-\nComplete problem .\n\u2022NP-Complete isacomplexity class which represents the setofall\nproblems XinNPforwhich itispossible toreduce any other NP\nproblem YtoXinpolynomial time .\nClassification of NP Problems \nNPHard\n\u2022NP-hard problems arethose atleast ashard asNPproblems, i.e.,all\nNPproblems canbereduced (inpolynomial time) tothem .\n\u2022NP-hard problems need not beinNP, i.e.,they need not have\nsolutions verifiable inpolynomial time .\n\u2022The precise definition here isthat aproblem XisNP-hard, ifthere is\nanNP-complete problem Y,such that Yisreducible toXinpolynomial\ntime .\nP, NP Complete and NP Hard\n\nHamiltonian Cycles\n\u2022Hamiltonian Path inanundirected graph isapath that visits each vertex\nexactly once .\n\u2022AHamiltonian cycle (orHamiltonian circuit) isaHamiltonian Path such\nthat there isanedge (inthegraph) from thelast vertex tothefirst vertex\noftheHamiltonian Path .\nThe graph has Hamiltonian cycles:\n1, 3, 4, 5, 6, 7, 8, 2, 1  and 1, 2, 8, 7, 6, 5, 4, 3, 1.\n\u2022Given alistofvertices and tocheck whether itforms aHamiltonian cycle\nornot:\n\u2022Counts thevertices tomake sure they areallthere, then checks that each\nisconnected tothenext byanedge, and that thelast isconnected tothe\nfirst.1 2 3 4\n8 7 6 5\nHamiltonian Cycles\n\u2022Ittakes time proportional to\ud835\udc5b,because there are\ud835\udc5bvertices tocount\nand\ud835\udc5bedges tocheck .\ud835\udc5bisapolynomial, sothe check runs in\npolynomial time .\n\u2022Tofind aHamiltonian cycle from the given graph :There are\ud835\udc5b!\ndifferent sequences ofvertices that might beHamiltonian paths ina\ngiven\ud835\udc5b-vertex graph, soabrute force search algorithm that tests all\npossible sequences cannotbesolved inpolynomial time .\n\u2022Inthetraveling salesman Problem ,asalesman must visits ncities .\n\u2022We can say that salesman wishes tomake atour orHamiltonian\ncycle ,visiting each cityexactly once and finishing atthecityhestarts\nfrom .", "mimetype": "text/plain", "start_char_idx": 9108, "end_char_idx": 12353, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ae55c952-1e92-416e-9b17-b2f0666e6c97": {"__data__": {"id_": "ae55c952-1e92-416e-9b17-b2f0666e6c97", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq", "node_type": "4", "metadata": {}, "hash": "f68e1d9c6c2e99facfe0c536aab504aeb2e9a13a72f60b2749fba90b41210d38", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f7fe5985-fd90-4d63-889a-e9b6a2ec7f69", "node_type": "1", "metadata": {}, "hash": "ba6e6aaec7dcbe0194c72fe3d93cef2b431880ad1a64bf889cf142ac4bd8c7fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nBacktracking and Branch & Bound:\nChapter -6\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Introduction to Backtracking, Introduction to \nBranch & Bound, 0/1 Knapsack Problem      \n2.N-Queens Problem, Travelling Salesman \nProblemContent INDEX\nIntroduction to Backtracking\n\u2022Backtracking canbedefined asageneral algorithmic technique that\nconsiders searching every possible combination inorder tosolve\nanoptimization problem .\n\u2022Itisarecursive technique .\n\u2022Itgenerates astate space tree forallpossible solutions .\n\u2022Ittraverse thestate space tree inthedepth first order .\n\u2022So,inabacktracking weattempt solving asub-problem, and ifwe\ndon't reach the desired solution, then undo whatever wedidfor\nsolving that sub-problem, and trysolving another sub-problem .\n\u2022Allthe solutions require aset ofconstraints divided into two\ncategories :explicit and implicit constraints .\nIntroduction to Branch & Bound\n\u2022The branch &bound approach isbased onthe principle that the\ntotal set offeasible solutions can bepartitioned into smaller\nsubsets ofsolutions .\n\u2022These smaller subsets can then beevaluated systematically until\nthebest solution isfound .\n\u2022Branch &bound isanalgorithm design approach which isgenerally\nused forsolving combinatorial optimization problems .\n\u2022These problems are typically exponential interms oftime\ncomplexity and may require exploring allpossible permutations in\nworst case .\n\u2022The Branch &Bound Algorithm technique solves these problems\nrelatively quickly .\n0/1 Knapsack Problem \u2013Introduction \n\u2022Letusconsider the0/1Knapsack problem tounderstand Branch &Bound .\n\u2022The Backtracking Solution can beoptimized ifweknow abound onbest\npossible solution subtree rooted with every node .\n\u2022Ifthebest insubtree isworse than current best, wecan simply ignore this\nnode and itssubtrees .\n\u2022So,wecompute bound (the best solution) forevery node and compare the\nbound with current best solution before exploring thenode .\n\u2022Wearegiven acertain number ofobjects and aknapsack .\n\u2022Instead ofsupposing that wehave nobjects available, weshall suppose that\nwehave ntypes ofobject ,and that anadequate number ofobjects ofeach\ntype areavailable .\n\u2022Our aim istofillthe knapsack inaway that maximizes the value ofthe\nincluded objects .\n\u2022Wemay take anobject orleave behind, butwemay nottake fraction ofan\nobject .\n0/1 Knapsack Problem using Branch & Bound \nInput:\nWeights: 1, 2, 3, 4\nProfits: 10, 20, 25, 70\nMaximum Weight Capacity: 7\nOutput:\nMaximum Profit = 100\n0/1 Knapsack Problem using Branch & Bound \nInput:\nWeights: 1, 2, 3, 4\nProfits: 10, 20, 25, 70\nMaximum Weight Capacity: 7\nOutput:\nMaximum Profit = 100\n0/1 Knapsack Problem using Branch & Bound \n\n0/1 Knapsack Algorithm \nfunction backpack( i, r)\n{Calculates the value of the best load that can be \nconstructed using items of type ito n and whose total \nweight does not exceed r}\nb \uf0df0\n{Try each allowed kind of item in turn}\nfork \uf0dfito n do\nifw[k] \u2264 r then\nb \uf0dfmax(b, v[k] + backpack (k, r \u2013w[k]))\nreturn b\nIntroduction & Programming with \nESP8266\nBacktracking and Branch & Bound:\nChapter -6\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Introduction to Backtracking, Introduction to \nBranch & Bound, 0/1 Knapsack Problem      \n2.N-Queens Problem, Travelling Salesman \nProblemContent INDEX\nN-Queens Problem\n\u2022The \ud835\udc41-queen is the problem of placing N chess queens on an \ud835\udc41\u00d7\ud835\udc41\nchessboard so that, no two queens attack each other.\n\u2022Two queens of same row, same column or the same diagonal can attack \neach other.\n\u2022K-Promising solution: A solution is called k -promising if it arranges the k -\nqueens in such a way that, they can not threat each other.\nQ\n1 -\nPromising \nSolution0 -\nPromising \nSolutionQ\nQ\n0 -\nPromising \nSolutionQ\nQ\n0 -\nPromising \nSolution\n4-Queens Problem -Example\n\u2022The 4 Queens Problem consists in placing four queens on a 4 x \n4chessboard so that no two queens attack each other.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3946, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f7fe5985-fd90-4d63-889a-e9b6a2ec7f69": {"__data__": {"id_": "f7fe5985-fd90-4d63-889a-e9b6a2ec7f69", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq", "node_type": "4", "metadata": {}, "hash": "f68e1d9c6c2e99facfe0c536aab504aeb2e9a13a72f60b2749fba90b41210d38", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae55c952-1e92-416e-9b17-b2f0666e6c97", "node_type": "1", "metadata": {}, "hash": "ff01dbe52f50f34a4c4e5ff4e440779b8a5d3ba2c20dce2e95b2198b0369354d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29740bbf-d6bd-4e0b-84e5-b1f8b96549fb", "node_type": "1", "metadata": {}, "hash": "72a73d0ca212d1317d6473ce9ddf966af381bd7686bda519c1f7a6b710863202", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Two queens of same row, same column or the same diagonal can attack \neach other.\n\u2022K-Promising solution: A solution is called k -promising if it arranges the k -\nqueens in such a way that, they can not threat each other.\nQ\n1 -\nPromising \nSolution0 -\nPromising \nSolutionQ\nQ\n0 -\nPromising \nSolutionQ\nQ\n0 -\nPromising \nSolution\n4-Queens Problem -Example\n\u2022The 4 Queens Problem consists in placing four queens on a 4 x \n4chessboard so that no two queens attack each other. That is, no \ntwo queens are allowed to be placed on the same row , the same \ncolumn or the same diagonal .\n\u2022We are going to look for the solution for n=4 on a 4 x 4 chessboard in \nthis article.\n\n4-Queens Problem -Example\n\u2022The 4 Queens Problem consists in placing four queens on a 4 x \n4chessboard so that no two queens attack each other. That is, no \ntwo queens are allowed to be placed on the same row , the same \ncolumn or the same diagonal .\n\u2022We are going to look for the solution for n=4 on a 4 x 4 chessboard in \nthis article.\n\n4-Queens Problem -Example\nStep 0: Initialize a 4 \u00d74 board.\n\n4-Queens Problem -Example\nStep 1:\n\u2022Put our first Queen (Q1) in the (0,0) cell .\n\u2022\u2018x\u2018 represents the cells which is not safe i.e. they are under attack by \nthe Queen (Q1).\n\u2022After this move to the next row [ 0 -> 1 ].\n\n4-Queens Problem -Example\nStep 1:\n\u2022Put our first Queen (Q1) in the (0,0) cell .\n\u2022\u2018x\u2018 represents the cells which is not safe i.e. they are under attack by \nthe Queen (Q1).\n\u2022After this move to the next row [ 0 -> 1 ].\n\n4-Queens Problem -Example\nStep 2:\n\u2022Put our next Queen ( Q2) in the (1,2) cell .\n\u2022After this move to the next row [ 1 -> 2 ].\n\n4-Queens Problem -Example\nStep 2:\n\u2022Put our next Queen ( Q2) in the (1,2) cell .\n\u2022After this move to the next row [ 1 -> 2 ].\n\n4-Queens Problem -Example\nStep 3:\nAt row 2 there is no cell which are safe to place Queen (Q3) . So, backtrack and remove \nqueen Q2 queen from cell ( 1, 2 ) .\nStep 4:\nThere is still a safe cell in the row 1 i.e. cell ( 1, 3 ).Put Queen ( Q2 ) at cell ( 1, 3).\n\n4-Queens Problem -Example\nStep 5:\n\u2022Put queen ( Q3 ) at cell ( 2, 1 ).\n\n4-Queens Problem -Example\nStep 5:\n\u2022Put queen ( Q3 ) at cell ( 2, 1 ).\n\n4-Queens Problem -Example\nStep 6:\n\u2022There is no any cell to place Queen ( Q4) at row 3.\n\u2022Backtrack and remove Queen ( Q3 ) from row 2.\n\u2022Again there is no other safe cell in row 2, So backtrack again and \nremove queen ( Q2) from row 1.\n\u2022Queen ( Q1 ) will be remove from cell (0,0) and move to next safe cell \ni.e.(0 , 1) .\n4-Queens Problem -Example\nStep 6:\n\u2022There is no any cell to place Queen ( Q4) at row 3.\n\u2022Backtrack and remove Queen ( Q3 ) from row 2.\n\u2022Again there is no other safe cell in row 2, So backtrack again and \nremove queen ( Q2) from row 1.\n\u2022Queen ( Q1 ) will be remove from cell (0,0) and move to next safe cell \ni.e.(0 , 1) .\n4-Queens Problem -Example\nStep 7:\n\u2022Place Queen Q1 at cell (0 , 1), and move to next row.\n\n4-Queens Problem -Example\nStep 8:\nPlace Queen Q2 at cell (1 , 3), and move to next row.\n\n4-Queens Problem -Example\nStep 9:\nPlace Queen Q3 at cell (2 , 0), and move to next row.\n\n4-Queens Problem -Example\nStep 10:\nPlace Queen Q4 at cell (3 , 2), and move to next row.", "mimetype": "text/plain", "start_char_idx": 3480, "end_char_idx": 6627, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "29740bbf-d6bd-4e0b-84e5-b1f8b96549fb": {"__data__": {"id_": "29740bbf-d6bd-4e0b-84e5-b1f8b96549fb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq", "node_type": "4", "metadata": {}, "hash": "f68e1d9c6c2e99facfe0c536aab504aeb2e9a13a72f60b2749fba90b41210d38", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f7fe5985-fd90-4d63-889a-e9b6a2ec7f69", "node_type": "1", "metadata": {}, "hash": "ba6e6aaec7dcbe0194c72fe3d93cef2b431880ad1a64bf889cf142ac4bd8c7fa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "30c0d51f-03e4-4e46-a799-8c97076516b6", "node_type": "1", "metadata": {}, "hash": "978ce2ae63623d961b6de47b34e784024040f331862cfb2c8aeeb72cbacdf4ef", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Backtrack and remove Queen ( Q3 ) from row 2.\n\u2022Again there is no other safe cell in row 2, So backtrack again and \nremove queen ( Q2) from row 1.\n\u2022Queen ( Q1 ) will be remove from cell (0,0) and move to next safe cell \ni.e.(0 , 1) .\n4-Queens Problem -Example\nStep 7:\n\u2022Place Queen Q1 at cell (0 , 1), and move to next row.\n\n4-Queens Problem -Example\nStep 8:\nPlace Queen Q2 at cell (1 , 3), and move to next row.\n\n4-Queens Problem -Example\nStep 9:\nPlace Queen Q3 at cell (2 , 0), and move to next row.\n\n4-Queens Problem -Example\nStep 10:\nPlace Queen Q4 at cell (3 , 2), and move to next row. This is one possible \nconfiguration of solution\n\nN-Queens Problem -Algorithm\nprocedure queens (k, col, diag45, diag135)\n{sol[1..k] is k -promising,\ncol = {sol[ i] | 1\u2264i\u2264k},\ndiag45 = {sol[ i]\u2013i+1 | 1\u2264i\u2264k}, and\ndiag135 = {sol[ i]+i\u20131 | 1\u2264i\u2264k}}\nifk = 4 then\nwrite sol\nelse\nforj \u2190 1 to4 do\nifj \u2209col and j \u2013k \u2209diag45  and j + k \u2209diag135 \nthen sol[k+1]\uf0dfj\nqueens(k + 1, col U {j}, diag45 U {j -k}, diag135 U {j + k})\nN-Queens Problem -Algorithm\nprocedure queens (k, col, diag45, diag135)\n{sol[1..k] is k -promising,\ncol = {sol[ i] | 1\u2264i\u2264k},\ndiag45 = {sol[ i]\u2013i+1 | 1\u2264i\u2264k}, and\ndiag135 = {sol[ i]+i\u20131 | 1\u2264i\u2264k}}\nifk = 8 then {an 8 -promising vector is a solution}\nwrite sol\nelse {explore (k+1) -promising extensions of sol }\nforj \u2190 1 to8 do\nifj \u2209col and j \u2013k \u2209diag45  and j + k \u2209diag135 \u2209sol[k+1] \u2190 j\nthen sol[k+1]\uf0dfj\n{sol[1..k+1] is (k+1) -promising}\nqueens(k + 1, col U {j}, diag45 U {j -k}, diag135 U {j + k})\nTravelling Salesman Problem\n\u2022A traveler needs to visit all the cities from a list, where distances \nbetween all the cities are known and each city should be visited just \nonce.\n\u2022So, the problem is to find the shortest possible route that visits each \ncity exactly once and returns to the starting point.\n\u2022Solution:\n\u2022Consider city 1 as the starting and ending point.\n\u2022Generate all (n -1)! Permutations of cities.\n\u2022Calculate cost of every permutation and keep track of minimum \ncost permutation.\n\u2022Return the permutation with minimum cost.\n\u2022Time Complexity is \ud835\udeaf(\ud835\udc8f!)", "mimetype": "text/plain", "start_char_idx": 6037, "end_char_idx": 8093, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "30c0d51f-03e4-4e46-a799-8c97076516b6": {"__data__": {"id_": "30c0d51f-03e4-4e46-a799-8c97076516b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1uHwbHrC2pnkXZoekZurBBU3gmmInX6rq", "node_type": "4", "metadata": {}, "hash": "f68e1d9c6c2e99facfe0c536aab504aeb2e9a13a72f60b2749fba90b41210d38", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29740bbf-d6bd-4e0b-84e5-b1f8b96549fb", "node_type": "1", "metadata": {}, "hash": "72a73d0ca212d1317d6473ce9ddf966af381bd7686bda519c1f7a6b710863202", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022So, the problem is to find the shortest possible route that visits each \ncity exactly once and returns to the starting point.\n\u2022Solution:\n\u2022Consider city 1 as the starting and ending point.\n\u2022Generate all (n -1)! Permutations of cities.\n\u2022Calculate cost of every permutation and keep track of minimum \ncost permutation.\n\u2022Return the permutation with minimum cost.\n\u2022Time Complexity is \ud835\udeaf(\ud835\udc8f!)\nTravelling Salesman Problem\n\u2022Travelling Salesman Problem (TSP) \u2013Introduction \n\nTSP using Branch & Bound\nA B\nC D1\n0\n88 51\n09\n9 676\nEA B C D E\nA -- 10 8 9 7\nB 10 -- 10 5 6\nC 8 10 -- 8 9\nD 9 5 8 -- 6\nE 7 6 9 6 --\n\u2022Here, total minimum distance = sum of row/column minimum = 31\n\u2022The upper bound = A \u27f6B\u27f6C\u27f6D\u27f6E\u27f6A =41\n\u2022Solution : [31\u202641]\nTSP using Branch & Bound\n\nTSP using Branch & Bound\n\nTSP using Branch & Bound\n\nTSP using Branch & Bound\n\nTSP using Branch & Bound\n\nDifference between Branch & Bound and Backtracking\nBranch & Bound Backtracking\nBranch -and-Bound is used to solve\noptimization problems .Backtracking isageneral algorithm for\nfinding all orsome solutions tothe\ncomputational problems\nAbranch -and-bound algorithm consists of\nasystematic enumeration ofcandidate\nsolutions .The setofcandidate solutions is\nthought ofasforming arooted tree, the\nalgorithm explores branches ofthis tree,\nwhich represent the subsets of the\nsolution set.Itincrementally builds candidates tothe\nsolutions, and backtracks assoon asit\ndetermines that the candidate cannot\npossibly becompleted toavalid solution .\nBranch -and-Bound traverse thetree inany\nmanner, DFS orBFS.It traverses the state space tree\nbyDFS(Depth First Search) manner .\nDifference between Branch & Bound and Backtracking\nBranch & Bound Backtracking\nBefore enumerating the candidate\nsolutions ofabranch, the branch is\nchecked against upper and lower\nestimated bounds ontheoptimal solution\nand isdiscarded ifitcannot produce a\nbetter solution than thebest one found so\nfarbythealgorithm .Itisanalgorithmic -technique forsolving\nproblems using recursive approach by\ntrying tobuild asolution incrementally,\none piece atatime, removing those\nsolutions that failtosatisfy theconstraints\noftheproblem atanypoint oftime .\nBranch -and-Bound involves a bounding \nfunctionBacktracking involves feasibility function.\nBranch -and-Bound is less efficient. Backtracking is more efficient.", "mimetype": "text/plain", "start_char_idx": 7708, "end_char_idx": 10020, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bb155286-d56f-4af4-b594-c9774f83e975": {"__data__": {"id_": "bb155286-d56f-4af4-b594-c9774f83e975", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1zuWV9VpZX1hpyXkAk6JbMQL1kH_6rCT7", "node_type": "4", "metadata": {}, "hash": "9dfd7ba72c731bfa9f06334e6d9aefe432a36544a8886430d8fe2770c1e30dd4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "77a14b47-d23f-49a3-878f-3854f100be56", "node_type": "1", "metadata": {}, "hash": "ec19eba8f014eed1605f620afc6f61f35da4e1ed68ae9d19bf1c7f23429a0a3d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nExploring Graphs:\nChapter -4\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.An introduction using graphs :    \nUndirected Graph\nDirected Graph\n2. Traversing Graphs\nDepth First Search,\nBreath First Search, \nTopological sortContent INDEX\nGraph -Definition\nAgraph\ud835\udc06=\u06e6\ud835\udc75,\u06e7\ud835\udc68consists ofanon-empty set\ud835\udc75called the setof\nnodes (vertices) ofthe graph, aset\ud835\udc68called the setofedges that also\nrepresents amapping from the set ofedges\ud835\udc68toaset ofpairs of\nelements \ud835\udc75.\nA\nFC\nBD\nE\nnodes\n(or vertices)edges\n(or links) \nDirected Graph\nDirected Graph :Agraph inwhich every edge isdirected from one\nnode toanother iscalled adirected graph ordigraph .\nCharacteristics :\nAsymmetrical :Anedge from vertex Atovertex Bdoes not imply a\nconnection back from BtoA.\nUse Cases :Webpage links (where one page links toanother), task\nscheduling .\nDirected Graph\nHere, the arrows indicate the direction of the relationships between vertices.\nUndirected Graph\nUndirected Graph :Agraph inwhich every edge isundirected and no\ndirection isassociated with them iscalled anundirected graph .\nCharacteristics :\nSymmetrical :Ifthere isanedge between vertex Aand vertex B,one\ncanmove from AtoBand from BtoA.\nUse Cases :Social networks, where relationships (like friendships) are\nmutual .\nUndirected Graph\nIn this undirected graph, connections between nodes are bidirectional.\nGraphs in Games\n\u2022Graphs can represent various aspects ofgames, particularly in\nstrategy and route planning .Here\u2019s how they areutilized :\n\u2022Strategy Games :Players can berepresented asvertices, with\npotential moves asedges .The strategies can beanalyzed based on\nconnectivity .\n\u2022Pathfinding Algorithms :Ingames, directing characters orunits from\npoint Atopoint Bcan bemodeled using directed graphs, utilizing\nalgorithms likeDijkstra's orA*.\n\u2022Social Dynamics :Collaboration and competition among players can\nbemodeled asundirected graphs, showing alliances orrivalries .\nIntroduction & Programming with \nESP8266\nExploring Graphs:\nChapter -4\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.An introduction using graphs :    \nUndirected Graph\nDirected Graph\n2. Traversing Graphs\nDepth First Search,\nBreath First Search, \nTopological sortContent INDEX\nTraversing Graph\nPreorder\ni.Visit the root .\nii.Traverse the left sub tree in preorder.\niii.Traverse the right sub tree in preorder.\nIn order\ni.Traverse the left sub tree in in order.\nii.Visit the root .\niii.Traverse the right sub tree in in order.\nPost order\ni.Traverse the left sub tree in post order.\nii.Traverse the right sub tree in post order.\niii.Visit the root.\nDepth -First Search / Traversal\n1\n3 2\n6 54\n8 7Select any node\ud835\udc63\u2208\ud835\udc41asstarting point\nmark that node asvisited\nSelect one ofthe unvisited adjacent of\ncurrent node .\nMake itnew starting point and mark itas\nvisited\nIfnew node has nounvisited adjacent\nthen move toparent and make itstarting\npoint\nVisited :12365478\nDFS \u2013Procedure \n\u2022Let\ud835\udc6e=(\ud835\udc75,\ud835\udc68)beanundirected graph allofwhose nodes wewish\ntovisit.\n\u2022Itissomehow possible tomark anode toshow ithasalready been\nvisited .\n\u2022Tocarry out adepth -first traversal ofthe graph, choose any node\n\ud835\udc63\u2208\ud835\udc41asthestarting point .\n\u2022Mark this node toshow ithasbeen visited .\n\u2022Ifthere isanode adjacent to\ud835\udc97that hasnotyetbeen visited, choose\nthis node asanew starting point and call the depth -first search\nprocedure recursively .\n\u2022When allthe nodes adjacent to\ud835\udc97are marked ,the search starting\nat\ud835\udc63isfinished .\n\u2022Ifthere remain any nodes of\ud835\udc3athat have not been visited ,choose\nany one ofthem asanew starting point ,and call the procedure\nagain .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3617, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "77a14b47-d23f-49a3-878f-3854f100be56": {"__data__": {"id_": "77a14b47-d23f-49a3-878f-3854f100be56", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1zuWV9VpZX1hpyXkAk6JbMQL1kH_6rCT7", "node_type": "4", "metadata": {}, "hash": "9dfd7ba72c731bfa9f06334e6d9aefe432a36544a8886430d8fe2770c1e30dd4", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bb155286-d56f-4af4-b594-c9774f83e975", "node_type": "1", "metadata": {}, "hash": "3193b1bc6534029932f3bdfd6e8419949a26cd67c26d2251228106f38163a59c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Itissomehow possible tomark anode toshow ithasalready been\nvisited .\n\u2022Tocarry out adepth -first traversal ofthe graph, choose any node\n\ud835\udc63\u2208\ud835\udc41asthestarting point .\n\u2022Mark this node toshow ithasbeen visited .\n\u2022Ifthere isanode adjacent to\ud835\udc97that hasnotyetbeen visited, choose\nthis node asanew starting point and call the depth -first search\nprocedure recursively .\n\u2022When allthe nodes adjacent to\ud835\udc97are marked ,the search starting\nat\ud835\udc63isfinished .\n\u2022Ifthere remain any nodes of\ud835\udc3athat have not been visited ,choose\nany one ofthem asanew starting point ,and call the procedure\nagain .\nDepth -First Search Algorithm\nprocedure dfsearch (G)\nfor each v \u0404 N do\nmark[v] \u2190 not -visited\nfor each v \u0404 N do \nif mark[v] \u2260 visited \nthen dfs(v)\nprocedure dfs(v)\n{Node v has not previously been visited}\nmark[v] \u2190 visited\nfor each node w adjacent to v do\nif mark[w] \u2260 visited \nthen dfs(w)\nDepth -First Search Algorithm1\n3 2\n6 54\n8 7\nprocedure dfs(v)\nmark[v] \u2190 visited\nfor each node w adjacent to v do\nif mark[w] \u2260 visited \nthen dfs(w)\n\nComparison of DFS and BFS\nDepth First Search (DFS) Breath First Search (BFS)\nDFS traverses according totree depth .\nDFS reaches up tothe bottom ofa\nsubtree, then backtracks .BFS traverses according totree level .BFS\nfinds theshortest path tothedestination .\nItuses astack tokeep track ofthe next\nlocation tovisit.Ituses aqueue tokeep track ofthenext\nlocation tovisit.\nDFS requires less memory since only\nnodes onthecurrent path arestored .BFS guarantees that thespace ofpossible\nmoves issystematically examined ;this\nsearch requires considerably more\nmemory resources .\nDoes not guarantee to find solution. \nBacktracking is required if wrong path is \nselected.Ifthere isasolution, BFS isguaranteed to\nfind it.\nComparison of DFS and BFS\nDepth First Search (DFS) Breath First Search (BFS)\nIftheselected path does notreach tothe\nsolution node, DFS gets stuck ortrapped\ninto aninfinite loops .BFS will not get trapped exploring an \ninfinite loops.\nThe Time complexity of both BFS and DFS will be O(V + E), \nwhere V is the number of vertices, and E is the number of \nEdges.\nTopological Sorting\n\u2022Atopological sort ortopological ordering ofadirected acyclic\ngraph isalinear ordering ofitsvertices such that forevery directed\nedge(\ud835\udc96,\ud835\udc97)from vertex\ud835\udc96tovertex\ud835\udc97,thevertex\ud835\udc96comes before\nthevertex\ud835\udc97intheordering .\n\u2022Topological Sorting foragraph isnotpossible ifthegraph isnot a\nDAG .\n\u2022InDFS, we print avertex and then recursively call DFS forits\nadjacent vertices .Intopological sorting, weneed toprint avertex\nbefore itsadjacent vertices .\n\u2022Few important applications oftopological sort are-\n\u2022Scheduling jobs from thegiven dependencies among jobs\n\u2022Instruction Scheduling\n\u2022Determining theorder ofcompilation tasks toperform inmakefiles\nTopological Sort -Example 1\nAB\nDC\nEFIdentify nodes having indegree \u20180\u2019\nSelect anode and delete itwith itsedges\nthen add node tooutput\nA B C D E FOutput:\nTopological Sort -Example 2\n25\n304\n1\n4 5 0 2 3 1Output:", "mimetype": "text/plain", "start_char_idx": 3049, "end_char_idx": 5983, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8396bf4f-9cf0-4d3c-83d8-c69224bda401": {"__data__": {"id_": "8396bf4f-9cf0-4d3c-83d8-c69224bda401", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5fdcf6e7-3c1f-4bc4-bad2-ca7b37d944b2", "node_type": "1", "metadata": {}, "hash": "64e8252b236db35a21281f18072f9b2b7df6c33de2b5b4cbde1f2422bc66aa43", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nDynamic Programming:\nChapter -4\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Principal of Optimality:\n\u20220/1 Knapsack Problem, \n\u2022Making Change Problem.\n2.Chain matrix multiplication, \nLongest   Common Subsequence.\n3. All pair shortest paths.Content INDEX\nPrincipal of Optimality\n\u2022Adynamic -programming algorithm solves every sub-problem just\nonce and then saves itsanswer inatable .\n\u2022Itavoids thework ofre-computing the answer every time the sub\nproblem isencountered .\n\u2022The dynamic programming algorithm obtains the solution using\nprinciple ofoptimality .\n\u2022The principle ofoptimality states that \u201cinanoptimal sequence of\ndecisions orchoices, each subsequence must also beoptimal .\n\u2022Ifitisnot possible toapply the principle ofoptimality then itis\nalmost impossible toobtain the solution using the dynamic\nprogramming approach .\nPrincipal of Optimality\n\u2022Adynamic -programming algorithm solves every sub-problem just\nonce and then saves itsanswer inatable .\n\u2022Itavoids thework ofre-computing the answer every time the sub\nproblem isencountered .\n\u2022The dynamic programming algorithm obtains the solution using\nprinciple ofoptimality .\n\u2022The principle ofoptimality states that \u201cinanoptimal sequence of\ndecisions orchoices, each subsequence must also beoptimal .\n\u2022Ifitisnot possible toapply the principle ofoptimality then itis\nalmost impossible toobtain the solution using the dynamic\nprogramming approach .\n0/1 Knapsack Problem -Dynamic Programming Solution\n\u2022Solve the following knapsack problem using dynamic programming \ntechnique.\n1.W=11and \ud835\udc5b=5\nObject \ud835\udc56 1 2 3 4 5\n\ud835\udc63\ud835\udc56 1 6 18 22 28\n\ud835\udc64\ud835\udc56 1 2 5 6 7\n0/1 Knapsack Problem -Dynamic Programming Solution\n\u2022We need to generate table \ud835\udc49(1\u2026\ud835\udc5b,0\u2026\ud835\udc4a)\n1.where, \ud835\udc5b=number ofobjects .\n2.\ud835\udc4a=capacity ofknapsack.\nTo generate table \ud835\udc49[\ud835\udc56][\ud835\udc57]use following steps:\nStep-1: Make \ud835\udc49[\ud835\udc56][0]=0\ud835\udc53\ud835\udc5c\ud835\udc5f 0<\ud835\udc56\u2264\ud835\udc5b\nStep-2: if \ud835\udc57<\ud835\udc64\ud835\udc56then \n\ud835\udc49\ud835\udc56\ud835\udc57=\ud835\udc49[\ud835\udc56\u22121][\ud835\udc57]\nStep-3: if \ud835\udc57\u2265\ud835\udc64\ud835\udc56then \n\ud835\udc49[\ud835\udc56][\ud835\udc57]=max (\ud835\udc49[\ud835\udc56\u22121][\ud835\udc57],\ud835\udc49[\ud835\udc56\u22121][\ud835\udc57\u2212\ud835\udc64\ud835\udc56]+\ud835\udc63\ud835\udc56)\n0/1 Knapsack Problem -Dynamic Programming Solution\nProblem Statement \u2212Athief isrobbing astore and cancarry amaximal\nweight ofWinto hisknapsack .There arenitems and weight ofithitem\niswiand theprofit ofselecting this item ispi.What items should the\nthief take?\nLet ibe the highest -numbered item in an optimal\nsolution SforWdollars .Then S=S{i}isanoptimal solution forW\nwidollars and thevalue tothesolution SisViplus thevalue ofthesub-\nproblem .\nWe can express this fact inthefollowing formula :define c[i,w]tobe\nthesolution foritems 1,2,,iand themaximum weight w.\n0/1 Knapsack Problem -Dynamic Programming Solution\nThe algorithm takes thefollowing inputs :\n\u2022The maximum weight W\n\u2022The number ofitems n\n\u2022The two sequences v=<v1,v2,,vn>and w=<w1,w2,,wn>\nThe setofitems totake canbededuced from thetable, starting atc[n,\nw]and tracing backwards where theoptimal values came from .\nIfc[i,w]=c[i-1,w],then item iisnot part ofthe solution, and we\ncontinue tracing with c[i-1,w].Otherwise, item iispart ofthesolution,\nand wecontinue tracing with c[i-1,w-W].", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3037, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5fdcf6e7-3c1f-4bc4-bad2-ca7b37d944b2": {"__data__": {"id_": "5fdcf6e7-3c1f-4bc4-bad2-ca7b37d944b2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8396bf4f-9cf0-4d3c-83d8-c69224bda401", "node_type": "1", "metadata": {}, "hash": "f9b0d4d70a6cf14964e02a6e6398a5518be5a825a717a16888590753cffbb939", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c73961ec-0397-49a5-b3b2-d02252a31a00", "node_type": "1", "metadata": {}, "hash": "55edd634f816730f8629df8a9c02bb1fb4d0483773ad2366ba6602902c2407dc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We can express this fact inthefollowing formula :define c[i,w]tobe\nthesolution foritems 1,2,,iand themaximum weight w.\n0/1 Knapsack Problem -Dynamic Programming Solution\nThe algorithm takes thefollowing inputs :\n\u2022The maximum weight W\n\u2022The number ofitems n\n\u2022The two sequences v=<v1,v2,,vn>and w=<w1,w2,,wn>\nThe setofitems totake canbededuced from thetable, starting atc[n,\nw]and tracing backwards where theoptimal values came from .\nIfc[i,w]=c[i-1,w],then item iisnot part ofthe solution, and we\ncontinue tracing with c[i-1,w].Otherwise, item iispart ofthesolution,\nand wecontinue tracing with c[i-1,w-W].\n0/1 Knapsack Problem -Algorithm\nDynamic -0-1-knapsack (v,w,n,W)\nforw=0toWdo\nc[0,w]=0\nfori=1tondo\nc[i,0]=0\nforw=1toWdo\nifwiwthen\nifvi+c[i-1,w-wi]then\nc[i,w]=vi+c[i-1,w-wi]\nelse c[i,w]=c[i-1,w]\nelse\nc[i,w]=c[i-1,w]\n0/1 Knapsack Problem -Example\nLet us consider that the capacity of the knapsack is W = 8 and the items \nare as shown in the following table.\nItem A B C D\nProfit 2 4 7 10\nWeight 1 3 5 7\nSolution\nUsing the greedy approach of 0 -1 knapsack, the weight that's stored in \nthe knapsack would be A+B = 4 with the maximum profit 2 + 4 = 6. But, \nthat solution would not be the optimal solution.\nTherefore, dynamic programming must be adopted to solve 0 -1 \nknapsack problems.\n0/1 Knapsack Problem -Example\nLet us consider that the capacity of the knapsack is W = 8 and the items \nare as shown in the following table.\nItem A B C D\nProfit 2 4 7 10\nWeight 1 3 5 7\nSolution\nUsing the greedy approach of 0 -1 knapsack, the weight that's stored in \nthe knapsack would be A+B = 4 with the maximum profit 2 + 4 = 6. But, \nthat solution would not be the optimal solution.\nTherefore, dynamic programming must be adopted to solve 0 -1 knapsack \nproblems.\n0/1 Knapsack Problem -Example\nStep 1\n\u2022Construct anadjacency table with maximum weight ofknapsack as\nrows and items with respective weights and profits ascolumns .\n\u2022Values tobestored inthetable arecumulative profits ofthe items\nwhose weights donot exceed themaximum weight oftheknapsack\n(designated values ofeach row)\n\u2022Soweadd zeroes tothe0throw and 0thcolumn because iftheweight\nofitem is0,then itweighs nothing ;ifthe maximum weight of\nknapsack is0,then noitem canbeadded into theknapsack .\n0/1 Knapsack Problem -Example\n\n0/1 Knapsack Problem -Example\nhe remaining values are filled with the maximum profit achievable with \nrespect to the items and weight per column that can be stored in the \nknapsack.\nThe formula to store the profit values is \u2212\nc[i,w]=max{c[i\u22121,w\u2212w[ i]]+P[ i]}\n0/1 Knapsack Problem -Example\nTofind the items tobeadded inthe knapsack, recognize the\nmaximum profit from thetable and identify theitems that make\nuptheprofit, inthis example, its{1,7}.\n0/1 Knapsack Problem -Example\nThe optimal solution is {1, 7} with the maximum profit is 12.\nMaking Change problem\n\u2022We need to generate a table \ud835\udc50[\ud835\udc5b][\ud835\udc41], where\n1.\ud835\udc5b= number of denominations \n2.\ud835\udc41= amount for which you need to make a change.", "mimetype": "text/plain", "start_char_idx": 2433, "end_char_idx": 5392, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c73961ec-0397-49a5-b3b2-d02252a31a00": {"__data__": {"id_": "c73961ec-0397-49a5-b3b2-d02252a31a00", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5fdcf6e7-3c1f-4bc4-bad2-ca7b37d944b2", "node_type": "1", "metadata": {}, "hash": "64e8252b236db35a21281f18072f9b2b7df6c33de2b5b4cbde1f2422bc66aa43", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "073631f1-213b-4ee1-a318-a903a2494c31", "node_type": "1", "metadata": {}, "hash": "10fffd0bba7001ad8e3701dc2220162d86f260956c71f793140bf7e72066d245", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The formula to store the profit values is \u2212\nc[i,w]=max{c[i\u22121,w\u2212w[ i]]+P[ i]}\n0/1 Knapsack Problem -Example\nTofind the items tobeadded inthe knapsack, recognize the\nmaximum profit from thetable and identify theitems that make\nuptheprofit, inthis example, its{1,7}.\n0/1 Knapsack Problem -Example\nThe optimal solution is {1, 7} with the maximum profit is 12.\nMaking Change problem\n\u2022We need to generate a table \ud835\udc50[\ud835\udc5b][\ud835\udc41], where\n1.\ud835\udc5b= number of denominations \n2.\ud835\udc41= amount for which you need to make a change. \nTo generate table \ud835\udc84[\ud835\udc8a][\ud835\udc8b] use following steps:\nStep -1:  Make c[i][0]=0\ud835\udc53\ud835\udc5c\ud835\udc5f0<\ud835\udc56\u2264\ud835\udc5b\nRepeat step -2 to step -4 for the remaining matrix values \nStep -2:  If \ud835\udc56=1then \ud835\udc50[\ud835\udc56][\ud835\udc57]=1+\ud835\udc50[1][\ud835\udc57\u2212\ud835\udc511]\nStep -3:  If \ud835\udc57<\ud835\udc51\ud835\udc56then \ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc50[\ud835\udc56\u22121][\ud835\udc57]\nStep -4:  Otherwise \ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc5a\ud835\udc56\ud835\udc5b (\ud835\udc50[\ud835\udc56\u22121][\ud835\udc57],1+\ud835\udc50[\ud835\udc56][\ud835\udc57\u2212\ud835\udc51\ud835\udc56])Optimal \nSub-\nstructure\nMaking Change problem\nDenominations: \ud835\udc511=1,\ud835\udc512=4,\ud835\udc513=6. Make a change of Rs. 8. \nStep-1:  Make \ud835\udc50[\ud835\udc56][0]=0\ud835\udc53\ud835\udc5c\ud835\udc5f 0<\ud835\udc56\u2264\ud835\udc5b\nStep-2:  If \ud835\udc56=1then \ud835\udc50[\ud835\udc56][\ud835\udc57]=1+\ud835\udc50[1][\ud835\udc57\u2212\ud835\udc511],here \ud835\udc511=1\nStep-3:  If \ud835\udc57<\ud835\udc51\ud835\udc56then \ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc50[\ud835\udc56\u22121][\ud835\udc57]\nStep-4:  Otherwise \ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc5a\ud835\udc56\ud835\udc5b (\ud835\udc50\ud835\udc56\u22121\ud835\udc57,1+\ud835\udc50\ud835\udc56\ud835\udc57\u2212\ud835\udc51\ud835\udc56)\n0 1 2 3 4 5 6 7 8\n\ud835\udc85\ud835\udfcf=\ud835\udfcf0 1 2 3 4 5 6 7 8\n\ud835\udc85\ud835\udfd0=\ud835\udfd20 1 2 3\n\ud835\udc85\ud835\udfd1=\ud835\udfd40\ud835\udc8a=\ud835\udfcf\n\ud835\udc8a=\ud835\udfd0\n\ud835\udc8a=\ud835\udfd1\ud835\udc57 Amoun\nt \nmin (\ud835\udc50[1][4],1+\ud835\udc50[2][0])=min (4,1+0)=min (4,1)=1 \ud835\udc5a\ud835\udc56\ud835\udc5b (\ud835\udc50[1][5],1+\ud835\udc50[2][1])=\ud835\udc5a\ud835\udc56\ud835\udc5b (5,1+1)=\ud835\udc5a\ud835\udc56\ud835\udc5b (5,2)=21 2\nMaking Change problem\n\u2022Denominations: \ud835\udc511=1,\ud835\udc512=4,\ud835\udc513=6. Make a change of Rs. 8.", "mimetype": "text/plain", "start_char_idx": 4892, "end_char_idx": 6199, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "073631f1-213b-4ee1-a318-a903a2494c31": {"__data__": {"id_": "073631f1-213b-4ee1-a318-a903a2494c31", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c73961ec-0397-49a5-b3b2-d02252a31a00", "node_type": "1", "metadata": {}, "hash": "55edd634f816730f8629df8a9c02bb1fb4d0483773ad2366ba6602902c2407dc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "188c649b-3eeb-444d-a728-d8adf8af1a75", "node_type": "1", "metadata": {}, "hash": "7e377e2387d939660db2c4741688dad0849540a3e9daa7484c179e2ba6633838", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Make a change of Rs. 8. \nStep-1:  Make \ud835\udc50[\ud835\udc56][0]=0\ud835\udc53\ud835\udc5c\ud835\udc5f 0<\ud835\udc56\u2264\ud835\udc5b\nStep-2:  If \ud835\udc56=1then \ud835\udc50[\ud835\udc56][\ud835\udc57]=1+\ud835\udc50[1][\ud835\udc57\u2212\ud835\udc511],here \ud835\udc511=1\nStep-3:  If \ud835\udc57<\ud835\udc51\ud835\udc56then \ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc50[\ud835\udc56\u22121][\ud835\udc57]\nStep-4:  Otherwise \ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc5a\ud835\udc56\ud835\udc5b (\ud835\udc50\ud835\udc56\u22121\ud835\udc57,1+\ud835\udc50\ud835\udc56\ud835\udc57\u2212\ud835\udc51\ud835\udc56)\n0 1 2 3 4 5 6 7 8\n\ud835\udc85\ud835\udfcf=\ud835\udfcf0 1 2 3 4 5 6 7 8\n\ud835\udc85\ud835\udfd0=\ud835\udfd20 1 2 3 1 2 3 4 2\n\ud835\udc85\ud835\udfd1=\ud835\udfd40 1 2 3 1 2 1 2 2\ud835\udc8a=\ud835\udfcf\n\ud835\udc8a=\ud835\udfd0\n\ud835\udc8a=\ud835\udfd1\ud835\udc57 Amoun\nt \nMaking Change problem\n\u2022We can also find the coins to be included in the solution set as follows:\n1. Start looking at c[3, 8] = c[2, 8]  \u27f9 So, not to include acoin with denomination 6.\n2. Next go to c[2,8] \u2260 c[1, 8] but c[2,8] = 1 + c[2,4]\n\u25aa So, include a coin with denomination 4\n3. Now, got to c[2,4] \u2260 c[1,4] but c[2,4] = 1+ c[2,0]\n\u25aa So, again include a coin with denomination 4\n4. Go to c[2,0] = c[1,0] and stop.\n0 1 2 3 4 5 6 7 8\n\ud835\udc85\ud835\udfcf=\ud835\udfcf0 1 2 3 4 5 6 7 8\n\ud835\udc85\ud835\udfd0=\ud835\udfd20 1 2 3 1 2 3 4 2\n\ud835\udc85\ud835\udfd1=\ud835\udfd40 1 2 3 1 2 1 2 2\ud835\udc50[\ud835\udc56][\ud835\udc57]=\ud835\udc5a\ud835\udc56\ud835\udc5b (\ud835\udc50[\ud835\udc56\u2212\n1][\ud835\udc57],\ud835\udfcf+\ud835\udc84[\ud835\udc8a][\ud835\udc8b\u2212\ud835\udc85\ud835\udc8a])\nSolution contains 2 coins with denomination \n4 \nIntroduction & Programming with \nESP8266\nDynamic Programming:\nChapter -4\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Principal of Optimality:\n\u20220/1 Knapsack Problem, \n\u2022Making Change Problem.\n2.Chain matrix multiplication, \nLongest   Common Subsequence.\n3. All pair shortest paths.Content INDEX\nMatrix Chain Multiplication Algorithm\n\u2022Matrix Chain Multiplication isanalgorithm that isapplied to\ndetermine thelowest cost way formultiplying matrices .\n\u2022The actual multiplication isdone using the standard way of\nmultiplying the matrices, i.e.,itfollows the basic rule that the\nnumber ofrows inone matrix must beequal tothe number of\ncolumns inanother matrix .\n\u2022Hence, multiple scalar multiplications must bedone toachieve the\nproduct .", "mimetype": "text/plain", "start_char_idx": 6176, "end_char_idx": 7834, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "188c649b-3eeb-444d-a728-d8adf8af1a75": {"__data__": {"id_": "188c649b-3eeb-444d-a728-d8adf8af1a75", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "073631f1-213b-4ee1-a318-a903a2494c31", "node_type": "1", "metadata": {}, "hash": "10fffd0bba7001ad8e3701dc2220162d86f260956c71f793140bf7e72066d245", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "52823b2d-9779-49d9-b3c3-cccd40fafaf0", "node_type": "1", "metadata": {}, "hash": "e99dab747097c6b1406da25cf310c375eaeb699beb7cc4dc032c72db0a2b5e61", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Principal of Optimality:\n\u20220/1 Knapsack Problem, \n\u2022Making Change Problem.\n2.Chain matrix multiplication, \nLongest   Common Subsequence.\n3. All pair shortest paths.Content INDEX\nMatrix Chain Multiplication Algorithm\n\u2022Matrix Chain Multiplication isanalgorithm that isapplied to\ndetermine thelowest cost way formultiplying matrices .\n\u2022The actual multiplication isdone using the standard way of\nmultiplying the matrices, i.e.,itfollows the basic rule that the\nnumber ofrows inone matrix must beequal tothe number of\ncolumns inanother matrix .\n\u2022Hence, multiple scalar multiplications must bedone toachieve the\nproduct .\n\u2022Tobrief itfurther, consider matrices A,B,C,and D,tobemultiplied ;\nhence, the multiplication isdone using the standard matrix\nmultiplication .There are multiple combinations ofthe matrices\nfound while using thestandard approach since matrix multiplication\nisassociative\nMatrix Chain Multiplication Algorithm\nFor instance, there are five ways to multiply the four matrices given \nabove \u2212\n\u2022(A(B(CD)))\n\u2022(A((BC)D))\n\u2022((AB)(CD))\n\u2022((A(BC))D)\n\u2022(((AB)C)D)\nMatrix Chain Multiplication Algorithm\n\u2022Now, ifthe size ofmatrices A,B,C,and Dare lm,mn,np,p\nqrespectively, then thenumber ofscalar multiplications performed\nwillbelmnpq .Butthecost ofthematrices change based ontherows\nand columns present init.Suppose, thevalues ofl,m,n,p,qare5,\n10,15,20,25respectively, the cost of(A(B(CD))) is5100 25=\n12,500;however, thecost of(A((BC)D)) is102537=9,250.\n\u2022So, dynamic programming approach of the matrix chain\nmultiplication isadopted inorder tofind thecombination with the\nlowest cost .\nMatrix Chain Multiplication Algorithm\nCount the number ofparenthesizations .Find the number ofways in\nwhich theinput matrices canbemultiplied using theformulae \u2212\n\u2022Once the parenthesization isdone, the optimal substructure must be\ndevised asthefirst step ofdynamic programming approach sothefinal\nproduct achieved isoptimal .Inmatrix chain multiplication, theoptimal\nsubstructure isfound bydividing the sequence ofmatrices A[i.j]into\ntwo parts A[i,k]and A[k+ 1,j].Itmust beensured that the parts are\ndivided insuch away that optimal solution isachieved .\nMatrix Chain Multiplication Algorithm\nUsing the formula,\n\u2022Thelowest cost parenthesization ofthe sequence ofmatrices by\nconstructing cost tables and corresponding kvalues table .\n\u2022Once the lowest cost isfound, print the corresponding\nparenthesization astheoutput .\nPseudocode to find the lowest cost of all the possible \nparenthesizations \u2212\nMATRIX -CHAIN -MULTIPLICATION(p) the lowest cost parenthesization of the sequence of \nmatrices by constructing cost tables and corresponding k values table.\nOnce the lowest cost is found, print the corresponding parenthesization as the output.\nn = p.length 1\nlet m[1n, 1n] and s[1n  1, 2n] be new matrices\nfor i= 1 to n\nm[i, i] = 0\nfor l = 2 to n // l is the chain length\nfor i= 1 to n -l + 1\nj = i+ l -1\nm[i, j] = \u221e\nfor k = ito j -1\nq = m[ i, k] + m[k + 1, j] + pi -1pkpj\nif q < m[ i, j]\nm[i, j] = q\ns[i, j] = k\nreturn m and s\nPseudocode to print the optimal output parenthesizing \u2212\nPRINT -OPTIMAL -OUTPUT(s, i, j )\nif i== j\nprint Ai\nelse print (\nPRINT -OPTIMAL -OUTPUT(s, i, s[i, j])\nPRINT -OPTIMAL -OUTPUT(s, s[ i, j] + 1, j)\nprint )\nExample\nA sequence of matrices A, B, C, D with dimensions 5 10, 10 15, 15 20, 20 \n25 are set to be multiplied. Find the lowest cost parenthesization to \nmultiply the given matrices using matrix chain multiplication.\nFind the count of parenthesization of the 4 matrices, i.e. n = 4.", "mimetype": "text/plain", "start_char_idx": 7140, "end_char_idx": 10716, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "52823b2d-9779-49d9-b3c3-cccd40fafaf0": {"__data__": {"id_": "52823b2d-9779-49d9-b3c3-cccd40fafaf0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "188c649b-3eeb-444d-a728-d8adf8af1a75", "node_type": "1", "metadata": {}, "hash": "7e377e2387d939660db2c4741688dad0849540a3e9daa7484c179e2ba6633838", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff7d59fa-9ce2-42b9-b0df-307804b381cd", "node_type": "1", "metadata": {}, "hash": "abdf96bb77b1ec770c39168e03fd143bcedc45f4debf11482c4edf39d28b6400", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Find the lowest cost parenthesization to \nmultiply the given matrices using matrix chain multiplication.\nFind the count of parenthesization of the 4 matrices, i.e. n = 4.\nUsing the formula, P(n)={1\u2211n\u22121k=1P(k)P(n\u2212k) ifn=1ifn\u22652\nSince n = 4 2, apply the second case of the formula \u2212\nP(n)=\u2211k=1n\u22121P(k)P(n\u2212k)\nP(4)=\u2211k=13P(k)P(4\u2212k)\nP(4)=P(1)P(3)+P(2)P(2)+P(3)P(1)\nExample\nIf P(1) = 1 and P(2) is also equal to 1, P(4) will be calculated based on \nthe P(3) value. Therefore, P(3) needs to determined first.\nP(3)=P(1)P(2)+P(2)P(1)\n=1+1=2\nTherefore,\nP(4)=P(1)P(3)+P(2)P(2)+P(3)P(1)\n=2+1+2=5\nAmong these 5 combinations of parenthesis, the matrix chain \nmultiplication algorithm must find the lowest cost parenthesis.\nExample\nStep 1\nThe table above isknown asacost table ,where allthe cost values\ncalculated from thedifferent combinations ofparenthesis arestored .\nAnother table is also created to store the kvalues obtained at the \nminimum cost of each combination.\nExample\nStep 2\nApplying the dynamic programming approach formula find the costs of \nvarious parenthesizations,\n\nExample\nC[1,1]=0\nC[2,2]=0\nC[3,3]=0\nC[4,4]=0\n\nExample\n\nExample\nStep 4\nFind the values of [1, 3] and [2, 4] in this step. The cost table is always \nfilled diagonally step -wise.\n\nExample\n\u2022C[2,4]=min{(0+7500+(10 \u00d715\u00d720)),(3000+5000)}C[2,4]=min{(0+7500+(10 \u00d71\n5\u00d720)),(3000+5000)}\n\u2022C[2,4]=8000\n\u2022C[1,3]=min{(0+3000+1000),(1500+0+750)}C[1,3]=min{(0+3000+1000), \n(1500+0+750)}\n\u2022C[1,3]=2250\n\nExample\nStep 5\nNow compute the final element of the cost table to compare the \nlowest cost parenthesization .\n\u2022C[1,4]=min{0+8000+1250,750+7500+1875,2200+0+2500}C[1,4]=min{0+8\n000+1250,750+7500+1875,2200+0+2500}\n\u2022C[1,4]=4700\nExample\nNow that allthevalues incost table arecomputed, thefinal step isto\nparethesize the sequence ofmatrices .For that, ktable needs tobe\nconstructed with the minimum value ofkcorresponding toevery\nparenthesis .\nExample\nParenthesization\nBased on the lowest cost values from the cost table and their \ncorresponding k values, let us add parenthesis on the sequence of \nmatrices.\nThe lowest cost value at [1, 4] is achieved when k = 3, therefore, the \nfirst parenthesization must be done at 3.\nExample\n(ABC)(D)\nThe lowest cost value at [1, 3] is achieved when k = 2, therefore the \nnext parenthesization is done at 2.\n((AB)C)(D)\nThe lowest cost value at[1,2]isachieved when k=1,therefore the\nnext parenthesization isdone at1.But theparenthesization needs at\nleast two matrices tobemultiplied sowedonotdivide further .\n((AB)(C))(D)\nSince, the sequence cannot be parenthesized further, the final \nsolution of matrix chain multiplication is ((AB)C)(D).\nLongest Common Subsequence\n\u2022Asubsequence isasequence that appears inthe same relative\norder, butnotnecessarily contiguous .\n\u2022Given two sequences \ud835\udc7fand\ud835\udc80,we say that asequence \ud835\udc81isa\ncommon subsequence of\ud835\udc7fand\ud835\udc80if\ud835\udc81isasubsequence ofboth\ud835\udc7f\nand\ud835\udc80.", "mimetype": "text/plain", "start_char_idx": 10546, "end_char_idx": 13403, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ff7d59fa-9ce2-42b9-b0df-307804b381cd": {"__data__": {"id_": "ff7d59fa-9ce2-42b9-b0df-307804b381cd", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "52823b2d-9779-49d9-b3c3-cccd40fafaf0", "node_type": "1", "metadata": {}, "hash": "e99dab747097c6b1406da25cf310c375eaeb699beb7cc4dc032c72db0a2b5e61", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "264aaabd-da2c-41c3-ae64-139c6fe74359", "node_type": "1", "metadata": {}, "hash": "e6111c2f132b20ed458f827322d481778369d93a34b3d08599ce5e5d388e81ce", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "((AB)C)(D)\nThe lowest cost value at[1,2]isachieved when k=1,therefore the\nnext parenthesization isdone at1.But theparenthesization needs at\nleast two matrices tobemultiplied sowedonotdivide further .\n((AB)(C))(D)\nSince, the sequence cannot be parenthesized further, the final \nsolution of matrix chain multiplication is ((AB)C)(D).\nLongest Common Subsequence\n\u2022Asubsequence isasequence that appears inthe same relative\norder, butnotnecessarily contiguous .\n\u2022Given two sequences \ud835\udc7fand\ud835\udc80,we say that asequence \ud835\udc81isa\ncommon subsequence of\ud835\udc7fand\ud835\udc80if\ud835\udc81isasubsequence ofboth\ud835\udc7f\nand\ud835\udc80.\n\u2022E.g.,if\ud835\udc7f=<\ud835\udc68,\ud835\udc69,\ud835\udc6a,\ud835\udc69,\ud835\udc6b,\ud835\udc68,\ud835\udc69>and\ud835\udc80=<\ud835\udc69,\ud835\udc6b,\ud835\udc6a,\ud835\udc68,\ud835\udc69,\ud835\udc68>then <\ud835\udc69,\n\ud835\udc6a,\ud835\udc68>isasubsequence .\n\u2022Use dynamic programming technique tofind the longest common\nsubsequence (LCS) .\nLongest Common Subsequence\n\u2022We need to generate table \ud835\udc84(\ud835\udfcf..\ud835\udc8e,\ud835\udfcf..\ud835\udc8f)\nwhere \ud835\udc8e=length of string \ud835\udc7a\ud835\udfcfand \ud835\udc8f=length of string \ud835\udc7a\ud835\udfd0.\nTo generate table \ud835\udc84[\ud835\udc8a][\ud835\udc8b]use following steps:\nStep-1: Make \ud835\udc84[\ud835\udc8a][\ud835\udfce]=\ud835\udfceand \ud835\udc84[\ud835\udfce][\ud835\udc8b]=\ud835\udfce\nStep-2: if \ud835\udc99\ud835\udc8a=\ud835\udc9a\ud835\udc8bthen \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b\u2212\ud835\udfcf]+\ud835\udfcf\nStep-3: else \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\ud835\udc26\ud835\udc1a\ud835\udc31 (\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b], \ud835\udc84[\ud835\udc8a,\ud835\udc8b\u2212\ud835\udfcf])\nLongest Common Subsequence\n\ud835\udc9a\ud835\udc8b \ud835\udc68 \ud835\udc69 \ud835\udc6a \ud835\udc69 \ud835\udc6b \ud835\udc68 \ud835\udc69\n\ud835\udc99\ud835\udc8a 0 0 0 0 0 0 0 0\n\ud835\udc690 0 1 1 1 1 1 1\n\ud835\udc6b0 0 1 1 1 2 2 2\n\ud835\udc6a0 0 1 2 2 2 2 2\n\ud835\udc680 1 1 2 2 2 3 3\n\ud835\udc690 1 2 2 3 3 3 4\n\ud835\udc680 1 2 2 3 3 4 4\ud835\udc8a\ud835\udc87\ud835\udc99\ud835\udc8a=\ud835\udc9a\ud835\udc8bthen \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b\u2212\ud835\udfcf]+\ud835\udfcfelse \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190max( \ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b], \ud835\udc84[\ud835\udc8a,\ud835\udc8b\u2212\ud835\udfcf])\nLongest Common Subsequence\n\ud835\udc9a\ud835\udc8b \ud835\udc68 \ud835\udc69 \ud835\udc6a \ud835\udc69 \ud835\udc6b \ud835\udc68 \ud835\udc69\n\ud835\udc99\ud835\udc8a 0 0 0 0 0 0 0 0\n\ud835\udc690 0 1 1 1 1 1 1\n\ud835\udc6b0 0 1 1 1 2 2 2\n\ud835\udc6a0 0 1 2 2 2 2 2\n\ud835\udc680 1 1 2 2 2 3 3\n\ud835\udc690 1 2 2 3 3 3 4\n\ud835\udc680 1 2 2 3 3 4 4\ud835\udc8a\ud835\udc87\ud835\udc99\ud835\udc8a=\ud835\udc9a\ud835\udc8bthen \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b\u2212\ud835\udfcf]+\ud835\udfcfelse \ud835\udc84[\ud835\udc8a,", "mimetype": "text/plain", "start_char_idx": 12836, "end_char_idx": 14283, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "264aaabd-da2c-41c3-ae64-139c6fe74359": {"__data__": {"id_": "264aaabd-da2c-41c3-ae64-139c6fe74359", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ff7d59fa-9ce2-42b9-b0df-307804b381cd", "node_type": "1", "metadata": {}, "hash": "abdf96bb77b1ec770c39168e03fd143bcedc45f4debf11482c4edf39d28b6400", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "17fd34e9-5202-4259-bfef-a0843d8e214a", "node_type": "1", "metadata": {}, "hash": "e6016f6513b3fe6def09b8ff645056bcd8b938133660adf40782cf92facdfd75", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\ud835\udc8b]\u2190\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b\u2212\ud835\udfcf]+\ud835\udfcfelse \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\nmax( \ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b], \ud835\udc84[\ud835\udc8a,\ud835\udc8b\u2212\ud835\udfcf])\n\ud835\udc9a\ud835\udc8b \ud835\udc68 \ud835\udc69 \ud835\udc6a \ud835\udc69 \ud835\udc6b \ud835\udc68 \ud835\udc69\n\ud835\udc99\ud835\udc8a 0 0 0 0 0 0 0 0\n\ud835\udc690 0 1 1 1 1 1 1\n\ud835\udc6b0 0 1 1 1 2 2 2\n\ud835\udc6a0 0 1 2 2 2 2 2\n\ud835\udc680 1 1 2 2 2 3 3\n\ud835\udc690 1 2 2 3 3 3 4\n\ud835\udc680 1 2 2 3 3 4 4\ud835\udc8a\ud835\udc87\ud835\udc99\ud835\udc8a=\ud835\udc9a\ud835\udc8bthen \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b\u2212\ud835\udfcf]+\ud835\udfcfelse \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190max( \ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b], \ud835\udc84[\ud835\udc8a,\ud835\udc8b\u2212\ud835\udfcf])\nLongest Common Subsequence\n\ud835\udc9a\ud835\udc8b \ud835\udc68 \ud835\udc69 \ud835\udc6a \ud835\udc69 \ud835\udc6b \ud835\udc68 \ud835\udc69\n\ud835\udc99\ud835\udc8a 0 0 0 0 0 0 0 0\n\ud835\udc690 0 1 1 1 1 1 1\n\ud835\udc6b0 0 1 1 1 2 2 2\n\ud835\udc6a0 0 1 2 2 2 2 2\n\ud835\udc680 1 1 2 2 2 3 3\n\ud835\udc690 1 2 2 3 3 3 4\n\ud835\udc680 1 2 2 3 3 4 4\ud835\udc8a\ud835\udc87\ud835\udc99\ud835\udc8a=\ud835\udc9a\ud835\udc8bthen \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190\ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b\u2212\ud835\udfcf]+\ud835\udfcfelse \ud835\udc84[\ud835\udc8a,\ud835\udc8b]\u2190max( \ud835\udc84[\ud835\udc8a\u2212\ud835\udfcf,\ud835\udc8b], \ud835\udc84[\ud835\udc8a,\ud835\udc8b\u2212\ud835\udfcf])\nLongest Common Subsequence\n\ud835\udc9a\ud835\udc8b \ud835\udc68 \ud835\udc69 \ud835\udc6a \ud835\udc69 \ud835\udc6b \ud835\udc68 \ud835\udc69\n\ud835\udc99\ud835\udc8a 0 0 0 0 0 0 0 0\n\ud835\udc690 0 1 1 1 1 1 1\n\ud835\udc6b0 0 1 1 1 2 2 2\n\ud835\udc6a0 0 1 2 2 2 2 2\n\ud835\udc680 1 1 2 2 2 3 3\n\ud835\udc690 1 2 2 3 3 3 4\n\ud835\udc680 1 2 2 3 3 4 4\ud835\udc7f=<\ud835\udc68,\ud835\udc69,\ud835\udc6a,\ud835\udc69,\ud835\udc6b,\ud835\udc68,\ud835\udc69>and \ud835\udc80=<\ud835\udc69,\ud835\udc6b,\ud835\udc6a,\ud835\udc68,\ud835\udc69,\ud835\udc68>and LCS = <\ud835\udc69,\ud835\udc6b,\ud835\udc68,\ud835\udc69>\nIntroduction & Programming with \nESP8266\nDynamic Programming:\nChapter -4\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Principal of Optimality:\n\u20220/1 Knapsack Problem, \n\u2022Making Change Problem.\n2.Chain matrix multiplication, \nLongest   Common Subsequence.\n3. All pair shortest paths.Content INDEX\nAll pair shortest paths\n\u2022Given adirected, connected weighted graph G(V, E),foreach edge \u27e8u,\nv\u27e9\u2208E,aweight w(u, v)isassociated with each edge .", "mimetype": "text/plain", "start_char_idx": 14259, "end_char_idx": 15445, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "17fd34e9-5202-4259-bfef-a0843d8e214a": {"__data__": {"id_": "17fd34e9-5202-4259-bfef-a0843d8e214a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "264aaabd-da2c-41c3-ae64-139c6fe74359", "node_type": "1", "metadata": {}, "hash": "e6111c2f132b20ed458f827322d481778369d93a34b3d08599ce5e5d388e81ce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6b2335b1-0ebf-4a6e-9afa-05059b11e8c0", "node_type": "1", "metadata": {}, "hash": "5405384f56bcb70ae2f39a913e2d68203587d69b89389b750e8674c5ac9cfe08", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\ud835\udc69,\ud835\udc6a,\ud835\udc69,\ud835\udc6b,\ud835\udc68,\ud835\udc69>and \ud835\udc80=<\ud835\udc69,\ud835\udc6b,\ud835\udc6a,\ud835\udc68,\ud835\udc69,\ud835\udc68>and LCS = <\ud835\udc69,\ud835\udc6b,\ud835\udc68,\ud835\udc69>\nIntroduction & Programming with \nESP8266\nDynamic Programming:\nChapter -4\nMrs. Bhumi Shah\nAssistant Professor \nDepartment of Computer Science and Engineering\n1.Principal of Optimality:\n\u20220/1 Knapsack Problem, \n\u2022Making Change Problem.\n2.Chain matrix multiplication, \nLongest   Common Subsequence.\n3. All pair shortest paths.Content INDEX\nAll pair shortest paths\n\u2022Given adirected, connected weighted graph G(V, E),foreach edge \u27e8u,\nv\u27e9\u2208E,aweight w(u, v)isassociated with each edge .\n\u2022The allpairs ofshortest paths problem istofind ashortest path from\n\ud835\udc62to\ud835\udc63forevery pair ofvertices\ud835\udc62and\ud835\udc63inV.\n\u2022Floyd\u2019s algorithm isused tofind allpair shortest path problem from a\ngiven weighted graph .\n\u2022Asaresult ofthis algorithm, itwill generate amatrix, which will\nrepresent theminimum distance from any node toallother nodes in\nthegraph .\n\u2022Atfirst, theoutput matrix issame asgiven cost matrix ofthegraph .\n\u2022Asthe algorithm proceeds, the output matrix will beupdated with\neach vertex\ud835\udc58asanintermediate vertex .\n\u2022The time complexity ofthis algorithm isO(n^ 3),where\ud835\udc5bisthe\nnumber ofvertices inthegraph .\nAll pair shortest paths\nStep: 2 Calculate the distance between each\nnode with node 1asanintermediate\nnode .\nD1 =     0 5 \u221e \u221e\n50 0 15 5\n30 \u221e 0 15\n15 \u221e 5 01 2 3 4\n1\n2\n3\n4\nFor node 2\n2\u21921\u21923=\u221e 2\u21923=15\n2\u21921\u21924=\u221e 2\u21924=5\nNo \nchange \n\nAll pair shortest paths\nFor node 3\n3\u21921\u21922=35 3\u21922=\u221e\n3\u21921\u21924=\u221e 3\u21924=15\n\nAll pair shortest paths\nStep: 2 Calculate the distance between each node\nwith node 1asanintermediate node.\nD1 =     0 5 \u221e \u221e\n50 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \u221e 5 01 2 3 4\n1\n2\n3\n4\nFor node 4\n4\u21921\u21922=20 4\u21922=\u221e\n4\u21921\u21923=\u221e 4\u21923=5\ud835\udfd0\ud835\udfce\n\nAll pair shortest paths Step: 3 Calculate the distance between each node\nwith node 2asanintermediate node.\nD2 =     0 5 \u221e \u221e\n50 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFor node 1\n1\u21922\u21923=20 1\u21923=\u221e\n1\u21922\u21924=10 1\u21924=\u221e\ud835\udfd0\ud835\udfce \ud835\udfcf\ud835\udfce\nNo change for Node 3 \n& 4 \n\nAll pair shortest pathsStep: 4 Calculate the distance between each node\nwith node 3asanintermediate node.\nD3 =     0 5 \ud835\udfd0\ud835\udfce \ud835\udfcf\ud835\udfce\n50 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFor node 1\n1\u21923\u21922=55 1\u21922=5\n1\u21923\u21924=35 1\u21924=10\nNo \nchange \n\nAll pair shortest paths Step: 4 Calculate the distance between each node\nwith node 3asanintermediate node.", "mimetype": "text/plain", "start_char_idx": 14918, "end_char_idx": 17122, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6b2335b1-0ebf-4a6e-9afa-05059b11e8c0": {"__data__": {"id_": "6b2335b1-0ebf-4a6e-9afa-05059b11e8c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "15d0_3UVz1Pd8b-pMaIQdQy8TJ7TKKuV4", "node_type": "4", "metadata": {}, "hash": "0247f904614e9a3149ae95c0580a2288b9e7f334daa978236fa8f380db299c97", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "17fd34e9-5202-4259-bfef-a0843d8e214a", "node_type": "1", "metadata": {}, "hash": "e6016f6513b3fe6def09b8ff645056bcd8b938133660adf40782cf92facdfd75", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "D3 =     0 5 \ud835\udfd0\ud835\udfce \ud835\udfcf\ud835\udfce\n50 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFor node 1\n1\u21923\u21922=55 1\u21922=5\n1\u21923\u21924=35 1\u21924=10\nNo \nchange \n\nAll pair shortest paths Step: 4 Calculate the distance between each node\nwith node 3asanintermediate node.\nD3 =     0 5 \ud835\udfd0\ud835\udfce \ud835\udfcf\ud835\udfce\n50 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFor node 2\n2\u21923\u21921=45 2\u21921=50\n2\u21923\u21924=30 2\u21924=5\nNo change for Node \n4  \ud835\udfd2\ud835\udfd3\n\nAll pair shortest paths\nStep: 5 Calculate thedistance between each node\nwith node 4asanintermediate node .\nD4 =     0 5 \ud835\udfd0\ud835\udfce \ud835\udfcf\ud835\udfce\n\ud835\udfd2\ud835\udfd3 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFor node 1\n1\u21924\u21922=30 1\u21922=5\n1\u21924\u21923=15 1\u21923=20\ud835\udfcf\ud835\udfd3\n\nAll pair shortest pathsStep: 5 Calculate the distance between each node\nwith node 4asanintermediate node.\nD4 =     0 5 \ud835\udfcf\ud835\udfd3\ud835\udfcf\ud835\udfce\n\ud835\udfd2\ud835\udfd3 0 15 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFor node 2\n2\u21924\u21921=20 2\u21921=45\n2\u21924\u21923=10 2\u21923=15\ud835\udfcf\ud835\udfce \ud835\udfd0\ud835\udfce\nNo change for Node \n3  \n\nAll pair shortest paths\nStep: 5 Calculate the distance between each node\nwith node 4asanintermediate node .\nD4 =     0 5 \ud835\udfcf\ud835\udfd3\ud835\udfcf\ud835\udfce\n\ud835\udfd0\ud835\udfce 0 \ud835\udfcf\ud835\udfce 5\n30 \ud835\udfd1\ud835\udfd3 0 15\n15 \ud835\udfd0\ud835\udfce 5 01 2 3 4\n1\n2\n3\n4\nFinal \nSolution \n\nFloyd\u2019s Algorithm\nfunction Floyd(L[1..n, 1..n]):array [1..n, 1..n]\narray D[1..n, 1..n]\nD \u2190 L\nfor k \u2190 1 to n do\nfor i  \u2190 1 to n do\nfor j \u2190 1 to n do\nD[i,j] \u2190 min(D[i,j], D[i,k]+ D[k,j])\nreturn D", "mimetype": "text/plain", "start_char_idx": 16896, "end_char_idx": 18100, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7234f23f-5691-4a7a-b2a7-a9d731977d07": {"__data__": {"id_": "7234f23f-5691-4a7a-b2a7-a9d731977d07", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "91911b4d-ccdc-45e1-85dd-9a061f824623", "node_type": "1", "metadata": {}, "hash": "2030c61d65355807c670873dfe1e010dea0a1c7a1006e89b8bbae34681c38248", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nGreedy Algorithms\nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Introduction, Elements of Greedy Strategy\n2.Minimum Spanning Tree: \n\u2022Kruskal\u2019s Algorithm\n\u2022Prim\u2019s Algorithm\n\u2022Dijkstra\u2019s Algorithm\n3. Knapsack Problem, Activity Selection Problem, \nHuffman Codes\nIntroduction to Greedy Strategy\n\u2022A Greedy  Algorithm  builds  up a solution  piece  by piece , always  \nchoosing  the option  that looks  best  at the moment .\n\u2022It does  not reconsider  its choices  once  made .\n\u2022Works  well for optimization  problems  (e.g., minimum,  maximum) .\n\u2022Simpler  and more  efficient  than  dynamic  programming  but doesn't  \nalways  guarantee  optimal  solution .\nCharacteristics of Greedy Algorithms\nGreedy Choice Property : \n\u2022A global optimum can be arrived at by selecting a local optimum.\n\u2022Feasibility: Only choose options that satisfy the problem's constraints.\n\u2022Optimal Substructure: A problem has an optimal solution that includes \noptimal solutions to subproblems.\nWhen to Use Greedy Algorithms\nWhen a problem exhibits :\n\u2022Greedy -choice property\n\u2022Optimal substructure\nIf a greedy approach fails to provide the correct solution, consider Dynamic \nProgramming.\nReal -Life Examples of Greedy Strategy\n\u2022Coin Change Problem (Limited to certain denominations)\n\u2022Activity Selection Problem\n\u2022Huffman Coding\n\u2022Kruskal\u2019s and Prim\u2019s Algorithms for Minimum Spanning Tree\n\u2022Dijkstra\u2019s Algorithm for Shortest Path\nElements of Greedy Strategy\n1.Candidate Set: A list of possible candidates to be chosen.\n2.Selection Function: Chooses the best candidate to add to the solution.\n3.Feasibility Function: Determines whether a candidate can be added \nwithout violating the problem\u2019s constraints.\n4.Solution Function: Determines whether a complete solution has been \nreached.\nGreedy Algorithm Structure (Pseudo -code)\nGreedy(A)\n  solution = \u2205\n  while feasible(solution)\n    x = select(A)\n    if is_feasible (solution, x)\n       solution = solution \u222a {x}\n  return solution\nIntroduction &  Programming with \nESP8266\nGreedy Algorithms\nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Introduction, Elements of Greedy Strategy\n2.Minimum Spanning Tree: \n\u2022Kruskal\u2019s Algorithm\n\u2022Prim\u2019s Algorithm\n\u2022Dijkstra\u2019s Algorithm\n3. Knapsack Problem, Activity Selection Problem, \nHuffman Codes\nIntroduction to Greedy Strategy\n\u2022A Greedy  Algorithm  builds  up a solution  piece  by piece , always  \nchoosing  the option  that looks  best  at the moment .\n\u2022It does  not reconsider  its choices  once  made .\n\u2022Works  well for optimization  problems  (e.g., minimum,  maximum) .\n\u2022Simpler  and more  efficient  than  dynamic  programming  but doesn't  \nalways  guarantee  optimal  solution .\nCharacteristics of Greedy Algorithms\nGreedy Choice Property : \n\u2022A global optimum can be arrived at by selecting a local optimum.\n\u2022Feasibility: Only choose options that satisfy the problem's constraints.\n\u2022Optimal Substructure: A problem has an optimal solution that includes \noptimal solutions to subproblems.\nWhen to Use Greedy Algorithms\nWhen a problem exhibits :\n\u2022Greedy -choice property\n\u2022Optimal substructure\nIf a greedy approach fails to provide the correct solution, consider Dynamic \nProgramming.\nReal -Life Examples of Greedy Strategy\n\u2022Coin Change Problem (Limited to certain denominations)\n\u2022Activity Selection Problem\n\u2022Huffman Coding\n\u2022Kruskal\u2019s and Prim\u2019s Algorithms for Minimum Spanning Tree\n\u2022Dijkstra\u2019s Algorithm for Shortest Path\nElements of Greedy Strategy\n1.Candidate Set: A list of possible candidates to be chosen.\n2.Selection Function: Chooses the best candidate to add to the solution.\n3.Feasibility Function: Determines whether a candidate can be added \nwithout violating the problem\u2019s constraints.\n4.Solution Function: Determines whether a complete solution has been \nreached.\nGreedy Algorithm Structure (Pseudo -code)\nGreedy(A)\n  solution = \u2205\n  while feasible(solution)\n    x = select(A)\n    if is_feasible (solution, x)\n       solution = solution \u222a {x}\n  return solution\nIntroduction to Minimum Spanning Tree (MST)\nLet \ud835\udc3a = \u06e6\ud835\udc41,\u06e7\ud835\udc34 be a connected,  undirected  graph  where,\n1.N is the set of nodes  and \n2.A is the set of edges .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4211, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "91911b4d-ccdc-45e1-85dd-9a061f824623": {"__data__": {"id_": "91911b4d-ccdc-45e1-85dd-9a061f824623", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7234f23f-5691-4a7a-b2a7-a9d731977d07", "node_type": "1", "metadata": {}, "hash": "091820c9827d1e5f86c03d4864f206cd7de39a4b73ae8b3f35712f8092153802", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4fdeabc-49b2-4b33-93a8-c3bb38e009d8", "node_type": "1", "metadata": {}, "hash": "78162b6dbca3ddcc9e493fc47d605326f19d16edbeb060cf341235e714354157", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Selection Function: Chooses the best candidate to add to the solution.\n3.Feasibility Function: Determines whether a candidate can be added \nwithout violating the problem\u2019s constraints.\n4.Solution Function: Determines whether a complete solution has been \nreached.\nGreedy Algorithm Structure (Pseudo -code)\nGreedy(A)\n  solution = \u2205\n  while feasible(solution)\n    x = select(A)\n    if is_feasible (solution, x)\n       solution = solution \u222a {x}\n  return solution\nIntroduction to Minimum Spanning Tree (MST)\nLet \ud835\udc3a = \u06e6\ud835\udc41,\u06e7\ud835\udc34 be a connected,  undirected  graph  where,\n1.N is the set of nodes  and \n2.A is the set of edges . \nEach  edge  has a given  positive  length  or weight . \nA spanning  tree of a graph  \ud835\udc3a is a sub-graph  which  is basically  a tree and it \ncontains  all the vertices  of \ud835\udc3a but does  not contain  cycle .\nA minimum  spanning  tree (MST)  of a weighted  connected  graph  \ud835\udc3a is a \nspanning  tree with  minimum  or smallest  weight  of edges .\nTwo Algorithms  for constructing  minimum  spanning  tree are,\n1.Kruskal\u2019s  Algorithm\n2.Prim\u2019s  Algorithm\nSpanning Tree Examples \nA\nB C\nD E F G\nHA\nB C\nD E F G\nH\nA\nB C\nDE\nFA\nB C\nDE\nFGraph \nGraph Spanning Tree \nSpanning Tree \nPrim\u2019s Algorithm for MST \u2013 Example 1\n1 2 3\n4 5 6\n74 6 4 5 6\n3 8\n4731 2Step:1Select  an arbitrary  node .\nNode - Set B Edges\n1\nPrim\u2019s Algorithm for MST \u2013 Example 1\n\nPrim\u2019s Algorithm for MST \u2013 Example 1\n\nPrim\u2019s Algorithm for MST \u2013 Example 1\nStep Edge Selected \n{u, v}Set B Edges Considered\nInit. - {1} --\n1 {1, 2} {1,2} {1,2} {1,4}\n2 {2, 3} {1,2,3} {1,4} {2,3} {2,4} {2,5}\n3 {1, 4} {1,2,3,4} {1,4} {2,4} {2,5} {3,5} {3,6}\n4 {4, 5} {1,2,3,4,5} {2,4} {2,5} {3,5} {3,6} {4,5} {4,7}\n5 {4, 7} {1,2,3,4,5,7} {2,4} {2,5} {3,5} {3,6} {4,7} {5,6} {5,7}\n6 {6,7} {1,2,3,4,5,6,7} {2,4} {2,5} {3,5} {3,6} {5,6} {5,7} {6,7}Cost = 17\n\nPrim\u2019s Algorithm\nFunction  Prim(G  = (N, A): graph ; length : A \u2014 R+): set of edges  \nT \u2190 \u00d8\nB \u2190 {an arbitrary  member  of N}\nwhile  B \u2260 N do\n find e = {u, v} of minimum  length  such  that\n  u \u2208 B and v \u2208 N \\ B \n T \u2190 T U {e} \n B \u2190 B U {v} \nreturn  T\nExercises \u2013 Home Work\nWrite the Prim\u2019s Algorithm to find out Minimum Spanning Tree. Apply the \nsame and find MST for the graph given below .", "mimetype": "text/plain", "start_char_idx": 3593, "end_char_idx": 5784, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c4fdeabc-49b2-4b33-93a8-c3bb38e009d8": {"__data__": {"id_": "c4fdeabc-49b2-4b33-93a8-c3bb38e009d8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "91911b4d-ccdc-45e1-85dd-9a061f824623", "node_type": "1", "metadata": {}, "hash": "2030c61d65355807c670873dfe1e010dea0a1c7a1006e89b8bbae34681c38248", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "83ead083-016c-47b1-a6b4-d54873893114", "node_type": "1", "metadata": {}, "hash": "8b8d31b1157e1f41ec09a2a8674346536822962822dbe02a7f7020c592caa5c3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Apply the \nsame and find MST for the graph given below .\n\nKruskal\u2019s Algorithm for MST \u2013 Example 1\nA\nB\nC DE4\n275\n36 6\n5\nStep 1: Taking min \nedge (C,D)1\nC D\n1Step 2:  Taking next \nmin edge (B,C)\nB\nC D2\n1\nStep 3:  Taking next\n min edge (B,E)\nB\nC DE\n23\n1Step 4:  Taking next \nmin edge (A,B)\nB\nC DE\n23\n1A\n4\nSo, we obtained a \nminimum\nspanning tree of cost : \n4 + 2 + 1 + 3 = 10\nKruskal\u2019s Algorithm for MST \u2013 Example 2\n\nKruskal\u2019s Algorithm for MST \u2013 Example 2\n\nKruskal\u2019s Algorithm for MST \u2013 Example 2\n\nKruskal\u2019s Algorithm \nFunction Kruskal(G = (N, A))\nSort A by increasing length \nn \u2190 the number of nodes in N\nT \u2190 \u00d8 {edges of the minimum spanning tree} \nDefine n sets, containing a different element of set N \nrepeat\ne \u2190 {u, v} //e is the shortest edge not yet considered\nucomp  \u2190 find(u) \nvcomp  \u2190 find(v) \nif ucomp  \u2260 vcomp  then merge( ucomp , vcomp ) \nT \u2190 T U {e} \nuntil T contains n - 1 edges \nreturn Tfind(u) tells in which connected component a node \ud835\udc62 is \nfound \nmerge( ucomp , vcomp ) is used to merge \ntwo connected components.\nExercises \u2013 Home Work\n\u2022The complexity for the Kruskal\u2019s  algorithm is in \ud835\udf3d(\ud835\udc82 \ud835\udc8d\ud835\udc90\ud835\udc88 \ud835\udc8f) where \ud835\udc82 is \ntotal number of edges and \ud835\udc8f is the total number of nodes  in the \ngraph \ud835\udc3a.\n\u2022Write the kruskal\u2019s  Algorithm to find out Minimum Spanning Tree. \nApply the same and find MST for the graph given below.\n\nDijkstra\u2019s Algorithm\n\u2022Consider now a directed graph \ud835\udc3a = (\ud835\udc41,\ud835\udc34) where \ud835\udc41 is the set of nodes and \ud835\udc34 \nis the set of directed edges of graph \ud835\udc3a.\n\u2022Each edge has a positive length .\n\u2022One of the nodes is designated as the source node .\n\u2022The problem is to determine the length of the shortest path  from the source \nto each of the other nodes of the graph. \n\u2022Dijkstra\u2019s  Algorithm is for finding the shortest paths between the nodes in a \ngraph. \n\u2022For a given source node, the algorithm finds the shortest path between the \nsource node and every other node. \n\u2022The algorithm maintains a matrix \ud835\udc73 which gives the length of each directed \nedge: \n\nDijkstra\u2019s Algorithm - Example\n\nDijkstra\u2019s Algorithm - Example\n\nDijkstra\u2019s Algorithm - Example\n\nExercises \u2013 Home Work\nWrite Dijkstra\u2019s Algorithm for shortest path. Use the algorithm to find the shortest path \nfrom the following graph. \n\nExercises \u2013 Home Work\nFunction Dijkstra (L[1 .. n, 1 .. n]): array [2..n] \narray D[2.. n]  \nC \u2190 {2,3,\u2026, n} \n{S = N \\ C exists only implicitly}\nfor i \u2190 2 to n do \nD[i] \u2190 L[1, i] \nrepeat n - 2 times\nv \u2190 some element of C minimizing D[v] \nC \u2190 C \\ {v} {and implicitly S \u2190 S U {v}} \nfor each w \u2208C do\nD[w] \u2190 min(D[w], D[v] + L[v, w]) \nreturn D\nIntroduction &  Programming with \nESP8266\nGreedy Algorithms\nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Introduction, Elements of Greedy Strategy\n2.Minimum Spanning Tree: \n\u2022Kruskal\u2019s Algorithm\n\u2022Prim\u2019s Algorithm\n\u2022Dijkstra\u2019s Algorithm\n3. Knapsack Problem, Activity Selection Problem, \nHuffman Codes\nKnapsack Problem\n\nFractional Knapsack Problem\n\u2022We are given \ud835\udc5b objects and a knapsack. \n\u2022Object  \ud835\udc8a has a positive weight \ud835\udc98\ud835\udc8a and a positive value \ud835\udc97\ud835\udc8a for \ud835\udc8a =\n \ud835\udfcf,\ud835\udfd0\u2026 \ud835\udc8f. \n\u2022The knapsack can carry a weight not exceeding \ud835\udc7e. \n\u2022Our aim is to fill the knapsack in a way that maximizes the value of the \nincluded objects, while respecting the capacity constraint.", "mimetype": "text/plain", "start_char_idx": 5728, "end_char_idx": 8955, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "83ead083-016c-47b1-a6b4-d54873893114": {"__data__": {"id_": "83ead083-016c-47b1-a6b4-d54873893114", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4fdeabc-49b2-4b33-93a8-c3bb38e009d8", "node_type": "1", "metadata": {}, "hash": "78162b6dbca3ddcc9e493fc47d605326f19d16edbeb060cf341235e714354157", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "31e0fcdf-e2a1-4e6b-8178-0d391ca4b968", "node_type": "1", "metadata": {}, "hash": "9188090a8ed1be249c069c1f3978c5f9ab880bfb36c57936468b0f88f5b33988", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Introduction, Elements of Greedy Strategy\n2.Minimum Spanning Tree: \n\u2022Kruskal\u2019s Algorithm\n\u2022Prim\u2019s Algorithm\n\u2022Dijkstra\u2019s Algorithm\n3. Knapsack Problem, Activity Selection Problem, \nHuffman Codes\nKnapsack Problem\n\nFractional Knapsack Problem\n\u2022We are given \ud835\udc5b objects and a knapsack. \n\u2022Object  \ud835\udc8a has a positive weight \ud835\udc98\ud835\udc8a and a positive value \ud835\udc97\ud835\udc8a for \ud835\udc8a =\n \ud835\udfcf,\ud835\udfd0\u2026 \ud835\udc8f. \n\u2022The knapsack can carry a weight not exceeding \ud835\udc7e. \n\u2022Our aim is to fill the knapsack in a way that maximizes the value of the \nincluded objects, while respecting the capacity constraint. \n\u2022In a fractional knapsack problem, we assume that the objects can be \nbroken into smaller pieces .\nFractional Knapsack Problem\n\u2022So we may decide to carry only a fraction \ud835\udc99\ud835\udc8a of object \ud835\udc8a, \n    where \ud835\udfce\u2264\ud835\udc99\ud835\udc8a\u2264\ud835\udfcf. \n\u2022In this case, object \ud835\udc8a contribute \ud835\udc99\ud835\udc8a\ud835\udc98\ud835\udc8a to the total weight in the knapsack, \nand \ud835\udc99\ud835\udc8a\ud835\udc97\ud835\udc8a to the value of the load. \n\u2022Symbolic Representation of the problem can be given as follows:\n maximize \u03c3\ud835\udc8a=\ud835\udfcf\ud835\udc8f\ud835\udc99i\ud835\udc97i subject to \u03c3\ud835\udc8a=\ud835\udfcf\ud835\udc8f\ud835\udc99i\ud835\udc98i \u2264\ud835\udc7e\n                         Where ,\ud835\udc63\ud835\udc56>0, \ud835\udc64\ud835\udc56>0 and 0\u2264\ud835\udc65\ud835\udc56\u22641 for 1\u2264 \ud835\udc56\u2264\ud835\udc5b. \nFractional Knapsack Problem - Example\n\u2022We are given 5 objects and the weight carrying capacity of knapsack is \n\ud835\udc7e=\ud835\udfcf\ud835\udfce\ud835\udfce .\n\u2022For each object, weight \ud835\udc64\ud835\udc56 and value \ud835\udc63\ud835\udc56 are given in the following table.\n\u2022Fill the knapsack with given objects such that the total value of knapsack \nis maximized.Obj \ud835\udc56 1 2 3 4 5\n\ud835\udc63\ud835\udc56 20 30 66 40 60\n\ud835\udc64\ud835\udc56 10 20 30 40 50\nFractional Knapsack Problem - Greedy Solution\nThree  Selection  Functions  can be defined  as,\n1.Sort the items  in descending  order  of their  values  and select  the \nitems  till weight  criteria  is satisfied .\n2.Sort the items  in ascending  order  of their  weight  and select  the \nitems  till weight  criteria  is satisfied .\n3.To calculate  the ratio  value/weight  for each  item  and sort the item  \non basis  of this ratio . Then  take  the item  with  the highest  ratio  and \nadd it.", "mimetype": "text/plain", "start_char_idx": 8337, "end_char_idx": 10286, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "31e0fcdf-e2a1-4e6b-8178-0d391ca4b968": {"__data__": {"id_": "31e0fcdf-e2a1-4e6b-8178-0d391ca4b968", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "83ead083-016c-47b1-a6b4-d54873893114", "node_type": "1", "metadata": {}, "hash": "8b8d31b1157e1f41ec09a2a8674346536822962822dbe02a7f7020c592caa5c3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "349b6e8c-9853-4943-be9f-3b667da614d0", "node_type": "1", "metadata": {}, "hash": "781684e8f24a965965b59da092ed8b9ae280124f0f31629fd9cad5e8cc8aabfe", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Sort the items  in ascending  order  of their  weight  and select  the \nitems  till weight  criteria  is satisfied .\n3.To calculate  the ratio  value/weight  for each  item  and sort the item  \non basis  of this ratio . Then  take  the item  with  the highest  ratio  and \nadd it. \nFractional Knapsack Problem - Greedy Solution\nObject  \ud835\udc56 1 2 3 4 5\n\ud835\udc63\ud835\udc56 20 30 66 40 60\n\ud835\udc64\ud835\udc56 10 20 30 40 50\n\u0d57\ud835\udc63\ud835\udc56\ud835\udc64\ud835\udc562.0 1.5 2.2 1.0 1.2\nSelection Objects Value \n1 2 3 4 5\nMax  \ud835\udc63\ud835\udc56 0 0 1 0.5 1 146\nMin  \ud835\udc64\ud835\udc56 1 1 1 1 0 156\nMax  \u03a4\ud835\udc63\ud835\udc56\ud835\udc64\ud835\udc561 1 1 0 0.8 164305020\n10203040\n30102040\nProfit = 66 + 60 + (40 * 0.5) = 146Profit = 20 + 30 + 66 + 40 = 156Profit = 66 + 20 + 30 + 48 = 164Weight \nCapacity 100\nFractional Knapsack Problem - Algorithm\nAlgorithm: Greedy -Fractional -Knapsack (w[1..n], \np[1..n], W) \nfor i = 1 to n do \n x[i] \u2190 0 ; weight \u2190 0 \nWhile weight < W do\n i \u2190 the best remaining object\n   if weight + w[ i] \u2264 W then  \n      x[i] \u2190 1 \n      weight \u2190 weight + w[ i] \n   else \n      x[i] \u2190 (W - weight) / w[ i] \n      weight \u2190 W \nreturn x\nExercises \u2013 Home Work\n1.Consider  Knapsack  capacity  \ud835\udc4a=50, \ud835\udc64 = (10, 20, 40) and \ud835\udc63 = (60, 80,100) \nfind the maximum  profit  using  greedy  approach .\n2.Consider  Knapsack  capacity  \ud835\udc4a = 10, \ud835\udc64=(4, 8, 2, 6, 1) and \ud835\udc63 = (12, 32, 40, \n30, 50). Find  the maximum  profit  using  greedy  approach .\nActivity Selection Problem\n\u2022The Activity  Selection  Problem  is an optimization  problem  which  deals  \nwith  the selection  of non-overlapping  activities  that needs  to be \nexecuted  by a single  person  or a machine  in a given  time  duration .\n\u2022An activity -selection  can also be applicable  for scheduling  a resourc e \namong  several  competing  activities .\n\u2022We are given  a set \ud835\udc46 of \ud835\udc5b activities  with  start  time  \ud835\udc94\ud835\udc8a and finish  time  \ud835\udc87\ud835\udc8a, \nof an \ud835\udc8a\ud835\udc95\ud835\udc89 activity . Find  the maximum  size set of mutually  compatible  \nactivities .\n\u2022Activities  \ud835\udc8a and \ud835\udc8b are compatible  if the half-open  internal  [\ud835\udc94\ud835\udc8a,\ud835\udc87\ud835\udc8a) and \n[\ud835\udc94\ud835\udc8b,\ud835\udc87\ud835\udc8b) do not overlap , that is, \ud835\udc8a and \ud835\udc8b are compatible  if \ud835\udc94\ud835\udc8a\u2265\ud835\udc87\ud835\udc8b or \ud835\udc94\ud835\udc8b\u2265\n\ud835\udc87\ud835\udc8a.\nActivity Selection Problem -Example\nExample : 11 activities  are \ngiven  as,\nSolution : \nStep  1: \nSort the activities  of set \ud835\udc7a as \nper increasing  finish  time  to \ndirectly  identify  mutually  \ncompatible  activities  by \ncomparing  finish  time  of first \nactivity  and start  time  of next  \nactivitySr.", "mimetype": "text/plain", "start_char_idx": 10004, "end_char_idx": 12315, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "349b6e8c-9853-4943-be9f-3b667da614d0": {"__data__": {"id_": "349b6e8c-9853-4943-be9f-3b667da614d0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "31e0fcdf-e2a1-4e6b-8178-0d391ca4b968", "node_type": "1", "metadata": {}, "hash": "9188090a8ed1be249c069c1f3978c5f9ab880bfb36c57936468b0f88f5b33988", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f30d4ce1-9e6b-4456-8834-addd4ff4b0e1", "node_type": "1", "metadata": {}, "hash": "cfc3c7c3cf214e91a877cabcacf627742e1aacdc93af5bba8e2476004d4f9e5e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Find  the maximum  size set of mutually  compatible  \nactivities .\n\u2022Activities  \ud835\udc8a and \ud835\udc8b are compatible  if the half-open  internal  [\ud835\udc94\ud835\udc8a,\ud835\udc87\ud835\udc8a) and \n[\ud835\udc94\ud835\udc8b,\ud835\udc87\ud835\udc8b) do not overlap , that is, \ud835\udc8a and \ud835\udc8b are compatible  if \ud835\udc94\ud835\udc8a\u2265\ud835\udc87\ud835\udc8b or \ud835\udc94\ud835\udc8b\u2265\n\ud835\udc87\ud835\udc8a.\nActivity Selection Problem -Example\nExample : 11 activities  are \ngiven  as,\nSolution : \nStep  1: \nSort the activities  of set \ud835\udc7a as \nper increasing  finish  time  to \ndirectly  identify  mutually  \ncompatible  activities  by \ncomparing  finish  time  of first \nactivity  and start  time  of next  \nactivitySr. Activity  (\ud835\udc94\ud835\udc8a, \ud835\udc87\ud835\udc8a) \n1 P (1, 4)\n2 Q (3, 5) \n3 R (0, 6) \n4 S (5, 7) \n5 T (3, 8) \n6 U (5, 9) \n7 V (6, 10) \n8 W (8, 11) \n9 X (8, 12) \n10 Y (2, 13) \n11 Z (12, 14)\nActivity Selection Problem -Example\nExample : 11 activities  are given  \nas,\nSolution : \nStep  2: \n1.A = {P} \n2.A = {P , S} \n3.A = {P , S, W} \n4.A = {P , S, W, Z} \nAnswer:  A = {P , S, W, Z}Sr. Activity  (\ud835\udc94\ud835\udc8a, \ud835\udc87\ud835\udc8a) \n1 P (1, 4)\n2 Q (3, 5) \n3 R (0, 6) \n4 S (5, 7) \n5 T (3, 8) \n6 U (5, 9) \n7 V (6, 10) \n8 W (8, 11) \n9 X (8, 12) \n10 Y (2, 13) \n11 Z (12, 14)\nActivity Selection Problem\nAlgorithm: Activity Selection \nStep I: Sort the input activities by increasing finishing time.  f1 \u2264 f2 \u2264 . . .\u2264  fn \nStep II: Call GREEDY -ACTIVITY -SELECTOR (s, f)\nn = length [s] \nA = { i} \nj = 1 \nfor i = 2 to n \n do if  si \u2265 fj \n then  A = A U { i} \n j = i \nreturn set A\nHuffman Codes\n\u2022Prefix code is used for encoding (compression) and Decoding (Decompression).\n\u2022Prefix Code: Any code that is not prefix of another code is called prefix code .\nCharacters Frequency Code Bits\na 45 000 135\nb 13 111 39\nc 12 101 36\nd 16 110 48\ne 9 011 27\nf 5 001 5\nTotal bits 290\nHuffman Codes\n\u2022Huffman  invented  a greedy  algorithm  that constructs  an optimal  prefix  \ncode  called  a Huffman  code .\n\u2022Huffman  coding  is a lossless  data  compression  algorithm . \n\u2022It assigns  variable -length  codes  to input  characters .\n\u2022Lengths  of the assigned  codes  are based  on the frequencies  of \ncorresponding  characters . \n\u2022The most  frequent  character  gets the smallest  code  and the least  \nfrequent  character  gets the largest  code .\n\u2022The variable -length  codes  assigned  to input  characters  are Prefix  Codes .\nHuffman Codes\n\u2022In Prefix codes, the codes are assigned in such a way that the code \nassigned to one character is not a prefix of code assigned to any other \ncharacter. \nFor example,  \n\u2022This is how  Huffman  Coding  makes  sure  that there  is no ambiguity  when  \ndecoding  the generated  bit stream .\n\u2022There  are mainly  two major  parts  in Huffman  Coding\n\u2022Build  a Huffman  Tree  from  input  characters .\n\u2022Traverse  the Huffman  Tree  and assign  codes  to characters .\nHuffman Codes\n\u2022Find the Huffman codes for the following characters .", "mimetype": "text/plain", "start_char_idx": 11783, "end_char_idx": 14510, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f30d4ce1-9e6b-4456-8834-addd4ff4b0e1": {"__data__": {"id_": "f30d4ce1-9e6b-4456-8834-addd4ff4b0e1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1OVE_-aBWt7QUKjJPosmBfkUeSEVeWvkk", "node_type": "4", "metadata": {}, "hash": "8d55f6092b5d3d710051b386b7b25fc089c159f98a8c5982f9a7bfa67c5e02de", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "349b6e8c-9853-4943-be9f-3b667da614d0", "node_type": "1", "metadata": {}, "hash": "781684e8f24a965965b59da092ed8b9ae280124f0f31629fd9cad5e8cc8aabfe", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022The most  frequent  character  gets the smallest  code  and the least  \nfrequent  character  gets the largest  code .\n\u2022The variable -length  codes  assigned  to input  characters  are Prefix  Codes .\nHuffman Codes\n\u2022In Prefix codes, the codes are assigned in such a way that the code \nassigned to one character is not a prefix of code assigned to any other \ncharacter. \nFor example,  \n\u2022This is how  Huffman  Coding  makes  sure  that there  is no ambiguity  when  \ndecoding  the generated  bit stream .\n\u2022There  are mainly  two major  parts  in Huffman  Coding\n\u2022Build  a Huffman  Tree  from  input  characters .\n\u2022Traverse  the Huffman  Tree  and assign  codes  to characters .\nHuffman Codes\n\u2022Find the Huffman codes for the following characters .\nCharacters a b c d e f\nFrequency (in \nthousand)45 13 12 16 9 5\nStep 1: Arrange  the characters  in the Ascending  order  of their  \nfrequency .\nf:5 e:9 c:12 b:13 d:16 a:45\nHuffman Codes\nStep 2: \n\u2713Extract  two nodes  with  the minimum  frequency .\n\u2713Create  a new  internal  node  with  frequency  equal  to the sum  of the two \nnodes  frequencies . \n\u2713Make  the first extracted  node  as its left child  and the other  extracted  node  \nas its right  child . \nf:5 e:9 c:12 b:13 d:16 a:4514\nHuffman Codes\nStep 3: \n\u2713Rearrange  the tree in ascending  order .\n\u2713Assign  \ud835\udfce to the left branch  and \ud835\udfcf to the right  branch .\n\u2713Repeat  the process  to complete  the tree.\nc:12 b:13 d:16 a:45 f:5 e:914\n0 1\nHuffman Codes\nStep 4: \nc:12 b:13 d:16 a:45\nf:5 e:914\n0 125\nf:5 e:914\n0 1d:16 a:45\nc:12 b:1325\n0 1\nHuffman Codes\nStep 5: \nf:5 e:914\n0 1d:16 a:45\nc:12 b:1325\n0 130\na:45\nc:12 b:132\n5\n0 1\n0 1d:16\nf:5 e:91430\n0 1\nHuffman Codes\n55\na:45\nc:12 b:1325\n0 1\n0 1d:16\nf:5 e:91430\n0 10 1Step 6: \nHuffman Codes\nStep 7: \na:45\nc:12 b:1325\n0 1\n0 1d:16\nf:5 e:91430\n0 155\n0 1100\n0 1\nHuffman Codes\nStep 8: \nCharacters a b c d e f\nFrequency (in \nthousand)45 13 12 16 9 5\n0 101 100 111 1101 1100\nHuffman Codes\nAlgorithm: HUFFMAN (C) \nn = |C|\nQ = C\nfor i = 1 to n -1\n        allocate a new node z\n        z.left  = x = EXTRACT -MIN(Q)\n        z.right  = y = EXTRACT -MIN(Q)\n        z.freq  = x.freq  + y.freq\n        INSERT( Q,z)\nreturn EXTRACT -MIN(Q)  // return the root of the tree\nExercises \u2013 Home Work\n\u2022Find an optimal Huffman code for the following set of frequency. \n1.a : 50,    b : 20, c : 15, d : 30.\n2.Frequency \n3.Frequency Characters A B C D E F\nFrequency (in \nthousand)24 12 10 8 8 5\nCharacters a b c d e f g\nFrequency (in thousand)37 28 29 13 30 17 6", "mimetype": "text/plain", "start_char_idx": 13766, "end_char_idx": 16244, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "471b4b16-9050-4d04-b804-e5cedf48d274": {"__data__": {"id_": "471b4b16-9050-4d04-b804-e5cedf48d274", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO", "node_type": "4", "metadata": {}, "hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "474097ba-98c1-4d53-8baa-d9fa59d81e21", "node_type": "1", "metadata": {}, "hash": "03ac3d2a661a1d95107a23e3a49843240b2521dd452bd42db50c13c269d3d8de", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Structure of divide -and-conquer algorithms\n2.Examples:\n\u2022Binary Search\n\u2022Quick Sort\n\u2022Merge Sort\n3.  Strassen Multiplication\n4. Max -Min problem\nIntroduction to Divide and Conquer Algorithm\nDivide  and Conquer  Algorithm  is a problem -solving  technique  used  to \nsolve  problems  by dividing  the main  problem  into subproblems,  solving  \nthem  individually  and then  merging  them  to find solution  to the original  \nproblem . Divide  and Conquer  is mainly  useful  when  we divide  a problem  \ninto independent  subproblems .\nWorking of Divide and Conquer Algorithm\nDivide  and Conquer  Algorithm  can be divided  into three  steps : Divide,  \nConquer  and Merge .\n1. Divide :\n\u2022Break  down  the original  problem  into smaller  subproblems .\n\u2022Each  subproblem  should  represent  a part of the overall  problem .\n\u2022The goal  is to divide  the problem  until  no further  division  is possible .\n2. Conquer :\n\u2022Solve  each  of the smaller  subproblems  individually .\n\u2022If a subproblem  is small  enough  (often  referred  to as the \u201cbase  case\u201d),  \nwe solve  it directly  without  further  recursion .\n\u2022The goal  is to find solutions  for these  subproblems  independently .\nWorking of Divide and Conquer Algorithm\n3. Merge :\n\u2022Combine  the sub-problems  to get the final  solution  of the whole  \nproblem .\n\u2022Once  the smaller  subproblems  are solved,  we recursively  combine  their  \nsolutions  to get the solution  of larger  problem .\n\u2022The goal  is to formulate  a solution  for the original  problem  by merging  \nthe results  from  the subproblems .\nCatachrestic of Divide and Conquer Algorithm\n\u2022Dividing  the Problem : The first step  is to break  the problem  into \nsmaller,  more  manageable  subproblems . This division  can be done  \nrecursively  until  the subproblems  become  simple  enough  to solve  \ndirectly .\n\u2022Independence  of Subproblems : Each  subproblem  should  be \nindependent  of the others,  meaning  that solving  one subproblem  does  \nnot depend  on the solution  of another . This allows  for parallel  \nprocessing  or concurrent  execution  of subproblems,  which  can lead  to \nefficiency  gains .\nCatachrestic of Divide and Conquer Algorithm\n\u2022Conquering  Each  Subproblem : Once  divided,  the subproblems  are \nsolved  individually . This may  involve  applying  the same  divide  and \nconquer  approach  recursively  until  the subproblems  become  simple  \nenough  to solve  directly,  or it may  involve  applying  a different  algorithm  \nor technique .\n\u2022Combining  Solutions : After  solving  the subproblems,  their  solutions  are \ncombined  to obtain  the solution  to the original  problem . This \ncombination  step  should  be relatively  efficient  and straightforward,  as \nthe solutions  to the subproblems  should  be designed  to fit together  \nseamlessly .\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Structure of divide -and-conquer algorithms\n2.Examples:\n\u2022Binary Search\n\u2022Quick Sort\n\u2022Merge Sort\n3.  Strassen Multiplication\n4. Max -Min problem\nWhat is Binary Search?\nBinary Search  is an efficient searching algorithm that works on sorted \narrays . It repeatedly divides the search interval in half:\n\u2022If the target is equal to the middle  element, return it.\n\u2022If the target is less, search the left half .\n\u2022If the target is greater , search the right half .\nSteps\nAlgorithm Steps:\n1.Set two pointers: low = 0, high = n \u2013 1\n2.While low \u2264 high:\n\u2022Compute mid = (low + high) / 2\n\u2022If arr[mid] == target, return index\n\u2022If arr[mid] > target, set high = mid \u2013 1\n\u2022If arr[mid] < target, set low = mid + 1If not found, return -1\n3.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3877, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "474097ba-98c1-4d53-8baa-d9fa59d81e21": {"__data__": {"id_": "474097ba-98c1-4d53-8baa-d9fa59d81e21", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO", "node_type": "4", "metadata": {}, "hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "471b4b16-9050-4d04-b804-e5cedf48d274", "node_type": "1", "metadata": {}, "hash": "dd63b4d7ccae7d0fe60fcb4b327ea2bfb4593e86fd2057faba5fc6c46e5dfd24", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9c9b1b05-978b-4f7f-8fd2-eec55ed4b572", "node_type": "1", "metadata": {}, "hash": "dbb6adf030e36d9bf0e84e7593d18ee08b7700a45f276f182b978a1f29e96479", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Strassen Multiplication\n4. Max -Min problem\nWhat is Binary Search?\nBinary Search  is an efficient searching algorithm that works on sorted \narrays . It repeatedly divides the search interval in half:\n\u2022If the target is equal to the middle  element, return it.\n\u2022If the target is less, search the left half .\n\u2022If the target is greater , search the right half .\nSteps\nAlgorithm Steps:\n1.Set two pointers: low = 0, high = n \u2013 1\n2.While low \u2264 high:\n\u2022Compute mid = (low + high) / 2\n\u2022If arr[mid] == target, return index\n\u2022If arr[mid] > target, set high = mid \u2013 1\n\u2022If arr[mid] < target, set low = mid + 1If not found, return -1\n3.  If not found, return -1\nBinary Search Algorithm\nAlgorithm: Function biniter (T[1,\u2026,n], x)\n if x > T[n] then return n+1\n i \u2190 1; \n j \u2190 n;\n while i < j do\n  k \u2190 ( i + j ) \u00f7 2\n  if  x \u2264 T [k]  then  j \u2190 k \n  else i \u2190 k + 1\n return i\nBinary Search Analysis\n\u2022Let \ud835\udc61(\ud835\udc5b) be the time required for a call on binrec ( \ud835\udc47[\ud835\udc56,\u2026,\ud835\udc57], \ud835\udc65 ), where \ud835\udc5b = \n\ud835\udc57 \u2013 \ud835\udc56  + 1 is the number of elements still under consideration in the \nsearch.\n\u2022The recurrence equation is given as,\n\u2022\ud835\udc95(\ud835\udc8f)=\ud835\udc95(\ud835\udc8f/\ud835\udfd0)+\ud835\udf3d(\ud835\udfcf)    \n\u2022Comparing this to the general template for divide and conquer \nalgorithm, \ud835\udc4e=1, \ud835\udc4f=2 \ud835\udc4e\ud835\udc5b\ud835\udc51 \ud835\udc53(\ud835\udc5b)=\ud835\udf03(1).\n\u2022 \u2234\ud835\udc95(\ud835\udc8f)\u2208\ud835\udf3d(\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f)\n\u2022The complexity of binary search is \ud835\udf3d(\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f)\ud835\udc7b(\ud835\udc8f)=\ud835\udc82\ud835\udc7b(\ud835\udc8f/\ud835\udc83)+\ud835\udc87(\ud835\udc8f)\nExample\nArray: [10, 20, 30, 40, 50, 60, 70]\nTarget: 40\nStep 1:low = 0, high = 6 \u2192 mid = 3\narr[3] = 40 \u2192 FOUND\nResult: Element found at index 3\nQuick Sort\n\u2022Quick  sort chooses  the first element  as a pivot  element,  a lower  bound  is \nthe first index  and an upper  bound  is the last index .\n\u2022The array  is then  partitioned  on either  side of the pivot .\n\u2022Elements  are moved  so that,  those  greater  than  the pivot  are shifted  to its \nright  whereas  the others  are shifted  to its left. \n\u2022Each  Partition  is internally  sorted  recursively .\n\nQuick Sort algorithm Example\n\nQuick Sort Algorithm\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high]; \n    int i = low - 1;\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap( arr[i], arr[j]);\n        }}\n    swap( arr[i + 1], arr[high]);\n    return i + 1;\n}\nvoid quickSort (int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition( arr, low, high); // Partitioning index\n        quickSort (arr, low, pi - 1);\n        quickSort (arr, pi + 1, high);\n    }}\nQuick Sort Analysis\n1.Worst Case \nRunning time depends on which element is chosen as key or pivot \nelement.\nThe worst case behavior for quick sort occurs when the array is \npartitioned into one sub -array with \ud835\udc8f\u2212\ud835\udfcf elements and the other \nwith \ud835\udfce element .", "mimetype": "text/plain", "start_char_idx": 3257, "end_char_idx": 5890, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9c9b1b05-978b-4f7f-8fd2-eec55ed4b572": {"__data__": {"id_": "9c9b1b05-978b-4f7f-8fd2-eec55ed4b572", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO", "node_type": "4", "metadata": {}, "hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "474097ba-98c1-4d53-8baa-d9fa59d81e21", "node_type": "1", "metadata": {}, "hash": "03ac3d2a661a1d95107a23e3a49843240b2521dd452bd42db50c13c269d3d8de", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e6c9a876-19cf-4c0f-ae67-64a8357c058d", "node_type": "1", "metadata": {}, "hash": "0fc17997ca94b2a27f89594c69ad57bbbc5bb205ba86947824b72e2182d8c735", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The worst case behavior for quick sort occurs when the array is \npartitioned into one sub -array with \ud835\udc8f\u2212\ud835\udfcf elements and the other \nwith \ud835\udfce element .\nIn this case, the recurrence will be,\n\ud835\udc47(\ud835\udc5b)=\ud835\udc47(\ud835\udc5b\u22121)+\ud835\udc47(0)+\ud835\udf03(\ud835\udc5b)\n \ud835\udc47(\ud835\udc5b)=\ud835\udc47(\ud835\udc5b\u22121)+ \ud835\udf03(\ud835\udc5b)\n \ud835\udc7b(\ud835\udc8f)= \ud835\udf3d(\ud835\udc8f\ud835\udfd0)\nQuick Sort Analysis\n2.Best Case\nOccurs when partition produces sub -problems each of size n/2.\nRecurrence equation:\n\ud835\udc47(\ud835\udc5b)=2\ud835\udc47(\ud835\udc5b/2)+ \u03b8(\ud835\udc5b)\n\ud835\udc59 = 2,\ud835\udc4f = 2,\ud835\udc58 = 1,\ud835\udc60\ud835\udc5c \ud835\udc59 = \ud835\udc4f\ud835\udc58\n\ud835\udc7b(\ud835\udc8f)= \ud835\udf3d(\ud835\udc8f\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f )\n3.Average Case\nAverage case running time is much closer to the best case.\nIf suppose the partitioning algorithm produces a 9:1 proportional \nsplit the recurrence will be, \n\ud835\udc47(\ud835\udc5b)=\ud835\udc47(9\ud835\udc5b/10)+ \ud835\udc47(\ud835\udc5b/10)+ \u03b8(\ud835\udc5b)\n\ud835\udc7b(\ud835\udc8f)= \ud835\udf3d(\ud835\udc8f\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f )\nMerge Sort\n\u2022Merge  Sort is an example  of divide  and conquer  algorithm .\n\u2022It is based  on the idea  of breaking  down  a list into several  sub-lists until  \neach  sub list consists  of a single  element .\n\u2022Merging  those  sub lists in a manner  that results  into a sorted  list.\n\u2022Procedure\n\u2022Divide  the unsorted  list into Nsub lists,  each  containing  1 element\n\u2022Take  adjacent  pairs  of two singleton  lists and merge  them  to form  a list \nof 2 elements .Nwill now  convert  into N/2lists of size 2\n\u2022Repeat  the process  till a single  sorted  list of all the elements  is obtained\nMerge Sort Example\n\nMerge Sort Algorithm\nvoid merge(int A[ ] , int start, inmid , int end)\n {\n //stores the starting position of both parts in temporary variables.\nint p = start ,q = mid+1;\nint Arr[end -start+1] , k=0;\nfor(int i = start ; i <= end ; i++) {\n    if(p > mid)      //checks if first part comes to an end or not .\n       Arr[ k++ ] = A[ q++] ;\n   else if ( q > end)   //checks if second part comes to an end or not\n       Arr[ k++ ] = A[ p++ ];\n   else if( A[ p ] < A[ q ])     //checks which part has smaller element.\n      Arr[ k++ ] = A[ p++ ];\n   \nMerge Sort Algorithm\nelse\n      Arr[ k++ ] = A[ q++];\n }\n  for (int p=0 ; p< k ;p ++) {\n   /* Now the real array has elements in sorted manner including both \n        parts.*/\n     A[ start++ ] = Arr[ p ] ;                          \n  }\n}\nMerge Sort Analysis\n\u2022Let \ud835\udc7b(\ud835\udc8f) be the time taken by this algorithm to sort an array of \ud835\udc5b \nelements.\n\u2022Separating \ud835\udc47 into \ud835\udc48 & \ud835\udc49 takes linear time; \ud835\udc5a\ud835\udc52\ud835\udc5f\ud835\udc54\ud835\udc52(\ud835\udc48, \ud835\udc49, \ud835\udc47) also takes \nlinear time.\n\ud835\udc47(\ud835\udc5b)=\ud835\udc47(\ud835\udc5b/2)+ \ud835\udc47(\ud835\udc5b/2)+\ud835\udc54(\ud835\udc5b)    where \ud835\udc54(\ud835\udc5b)\u2208\u03b8(\ud835\udc5b).\n\ud835\udc47(\ud835\udc5b)=2\ud835\udc61(\ud835\udc5b/2)+ \u03b8(\ud835\udc5b)\n\u2022Applying  the general case, \ud835\udc59=2, \ud835\udc4f=2, \ud835\udc58=1\n\u2022Since \ud835\udc59=\ud835\udc4f\ud835\udc58 the second case applies so, \ud835\udc61(\ud835\udc5b)\u2208\u03b8(\ud835\udc5b\ud835\udc59\ud835\udc5c\ud835\udc54\ud835\udc5b).\n\u2022Time complexity of merge sort is \ud835\udec9(\ud835\udc8f\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f).", "mimetype": "text/plain", "start_char_idx": 5744, "end_char_idx": 8162, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e6c9a876-19cf-4c0f-ae67-64a8357c058d": {"__data__": {"id_": "e6c9a876-19cf-4c0f-ae67-64a8357c058d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO", "node_type": "4", "metadata": {}, "hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9c9b1b05-978b-4f7f-8fd2-eec55ed4b572", "node_type": "1", "metadata": {}, "hash": "dbb6adf030e36d9bf0e84e7593d18ee08b7700a45f276f182b978a1f29e96479", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "befea919-9995-4fa5-adf1-6442946beb59", "node_type": "1", "metadata": {}, "hash": "1a83717a3a82fa047f63795c53ca8036ff03227a5495a4ab8c9e566bdbf8d2fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\ud835\udc47(\ud835\udc5b)=\ud835\udc47(\ud835\udc5b/2)+ \ud835\udc47(\ud835\udc5b/2)+\ud835\udc54(\ud835\udc5b)    where \ud835\udc54(\ud835\udc5b)\u2208\u03b8(\ud835\udc5b).\n\ud835\udc47(\ud835\udc5b)=2\ud835\udc61(\ud835\udc5b/2)+ \u03b8(\ud835\udc5b)\n\u2022Applying  the general case, \ud835\udc59=2, \ud835\udc4f=2, \ud835\udc58=1\n\u2022Since \ud835\udc59=\ud835\udc4f\ud835\udc58 the second case applies so, \ud835\udc61(\ud835\udc5b)\u2208\u03b8(\ud835\udc5b\ud835\udc59\ud835\udc5c\ud835\udc54\ud835\udc5b).\n\u2022Time complexity of merge sort is \ud835\udec9(\ud835\udc8f\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f). \n\ud835\udc95\ud835\udc8f\n=\ud835\udf3d\ud835\udc8f\ud835\udc8c \ud835\udc8a\ud835\udc87 \ud835\udc8d < \ud835\udc83\ud835\udc8c\n\ud835\udf3d\ud835\udc8f\ud835\udc8c\ud835\udc8d\ud835\udc90\ud835\udc88\ud835\udc8f  \ud835\udc8a\ud835\udc87 \ud835\udc8d= \ud835\udc83\ud835\udc8c\n\ud835\udf3d\ud835\udc8f\ud835\udc8d\ud835\udc90\ud835\udc88 \ud835\udc83\ud835\udc8d \ud835\udc8a\ud835\udc87 \ud835\udc8d >\ud835\udc83\ud835\udc8c\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Structure of divide -and-conquer algorithms\n2.Examples:\n\u2022Binary Search\n\u2022Quick Sort\n\u2022Merge Sort\n3.  Strassen Multiplication\n4. Max -Min problem\nMatrix Multiplication\nMultiply following two matrices. Count how many scalar multiplications are \nrequired. \n13\n75\u221968\n42\n\ud835\udc4e\ud835\udc5b\ud835\udc60\ud835\udc64\ud835\udc52\ud835\udc5f =1\u00d76+3\u00d741\u00d78+3\u00d72\n7\u00d76+5\u00d747\u00d78+5\u00d72\nTo multiply 2\u00d72 matrices, total 8 (23) scalar multiplications are required. \nMatrix Multiplication\nIn general, \ud835\udc34 and \ud835\udc35 are two  2\u00d72 matrices to be multiplied.\n\ud835\udc34=\ud835\udc3411 \ud835\udc3412\n\ud835\udc3421 \ud835\udc3421 and \ud835\udc35=\ud835\udc3511 \ud835\udc3512\n\ud835\udc3521 \ud835\udc3522\n\ud835\udc36=\ud835\udc3611 \ud835\udc3612\n\ud835\udc3621 \ud835\udc3622=\ud835\udc3411 \ud835\udc3412\n\ud835\udc3421 \ud835\udc3422\u2219\ud835\udc3511 \ud835\udc3512\n\ud835\udc3521 \ud835\udc3522\n\ud835\udc3611=\ud835\udc3411\u2219\ud835\udc3511+\ud835\udc3412\u2219\ud835\udc3521\n\ud835\udc3612=\ud835\udc3411\u2219\ud835\udc3512+\ud835\udc3412\u2219\ud835\udc3522\n\ud835\udc3621=\ud835\udc3421\u2219\ud835\udc3511+\ud835\udc3422\u2219\ud835\udc3521\n\ud835\udc3622=\ud835\udc3421\u2219\ud835\udc3512+\ud835\udc3422\u2219\ud835\udc3522\nComputing each entry in the product takes \ud835\udc8f multiplications and there are \n\ud835\udc8f\ud835\udfd0 entries for a total of \ud835\udc76(\ud835\udc8f\ud835\udfd1 ). \nStrassen\u2019s Algorithm for Matrix Multiplication \n\u2022Consider the problem of multiplying  two \ud835\udc5b \u00d7 \ud835\udc5b matrices. \n\u2022Strassen\u2019s devised a better method which has the same basic method as \nthe multiplication of long integers. \n\u2022The main idea is to save one multiplication on a small problem and then \nuse recursion.", "mimetype": "text/plain", "start_char_idx": 7957, "end_char_idx": 9437, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "befea919-9995-4fa5-adf1-6442946beb59": {"__data__": {"id_": "befea919-9995-4fa5-adf1-6442946beb59", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO", "node_type": "4", "metadata": {}, "hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e6c9a876-19cf-4c0f-ae67-64a8357c058d", "node_type": "1", "metadata": {}, "hash": "0fc17997ca94b2a27f89594c69ad57bbbc5bb205ba86947824b72e2182d8c735", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6b55756-074c-42ba-b0bb-f76a364d60a6", "node_type": "1", "metadata": {}, "hash": "210f4f5cbed8ae9bcadab0098bd2061d46d6e03a09e37aa509b7008d710a49a8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Strassen\u2019s Algorithm for Matrix Multiplication \n\u2022Consider the problem of multiplying  two \ud835\udc5b \u00d7 \ud835\udc5b matrices. \n\u2022Strassen\u2019s devised a better method which has the same basic method as \nthe multiplication of long integers. \n\u2022The main idea is to save one multiplication on a small problem and then \nuse recursion.\nStrassen\u2019s Algorithm for Matrix Multiplication \n\ud835\udc461=\ud835\udc3512\u2212\ud835\udc3522\n\ud835\udc462=\ud835\udc3411+\ud835\udc3412\n\ud835\udc463=\ud835\udc3421+\ud835\udc3422\n\ud835\udc464=\ud835\udc3521\u2212\ud835\udc3511\n\ud835\udc465=\ud835\udc3411+\ud835\udc3422\n\ud835\udc466=\ud835\udc3511+\ud835\udc3522\n\ud835\udc467=\ud835\udc3412\u2212\ud835\udc3422\n\ud835\udc468=\ud835\udc3521+\ud835\udc3522\n\ud835\udc469=\ud835\udc3411\u2212\ud835\udc3421\n\ud835\udc4610=\ud835\udc3511+\ud835\udc3512\ud835\udc431=\ud835\udc3411\u2219\ud835\udc461\n\ud835\udc432=\ud835\udc462\u2219\ud835\udc3522\n\ud835\udc433=\ud835\udc463\u2219\ud835\udc3511\n\ud835\udc434=\ud835\udc3422\u2219\ud835\udc464\n\ud835\udc435=\ud835\udc465\u2219\ud835\udc466\n\ud835\udc436=\ud835\udc467\u2219\ud835\udc468\n\ud835\udc437=\ud835\udc469\u2219\ud835\udc4610\nAll above \noperations \ninvolve only one \nmultiplication . \n\ud835\udc34=\ud835\udc3411 \ud835\udc3412\n\ud835\udc3421 \ud835\udc3421 and\n \ud835\udc35=\ud835\udc3511 \ud835\udc3512\n\ud835\udc3521 \ud835\udc3522\nStrassen\u2019s Algorithm Analysis\nIt is therefore possible to multiply two 2 \u00d7 2 matrices using only seven scalar \nmultiplications . \nLet \ud835\udc61(\ud835\udc5b) be the time needed to multiply two \ud835\udc5b \u00d7 \ud835\udc5b matrices by recursive use of equations .\n\ud835\udc95\ud835\udc8f= \ud835\udfd5\ud835\udc95\ud835\udc8f\n\ud835\udfd0+ \ud835\udc88\ud835\udc8f  \nWhere \ud835\udc54(\ud835\udc5b) \u2208 \ud835\udc42(\ud835\udc5b2). \nThe general equation applies with \ud835\udc59=7,\ud835\udc4f=2 and \ud835\udc58=2.\nSince \ud835\udc59>\ud835\udc4f\ud835\udc58, the third case applies and \ud835\udc61\ud835\udc5b\u2208\ud835\udc42\ud835\udc5b\ud835\udc59\ud835\udc547. \nSince \ud835\udc59\ud835\udc547 >2.81, it is possible to multiply two \ud835\udc5b \u00d7 \ud835\udc5b matrices in a time  \ud835\udc76(\ud835\udc8f\ud835\udfd0.\ud835\udfd6\ud835\udfcf).\ud835\udc95\ud835\udc8f=\ud835\udc8d\ud835\udc95\ud835\udc8f/\ud835\udc83+\ud835\udc20\ud835\udc8f\n\nMax -Min Problem\n\u2022Finding a maximum and minimum element from a given array is the \napplication of the Divide and Conquer algorithm.\n\u2022There are various ways to this problem, but the most traditional \napproach to to solve this problem is the linear approach. In the linear \napproach, we traverse all elements once and find the minimum and \nmaximum element.\n\u2022In this approach, the time complexity to solve this problem is \u03b8(n). \nExample of Max -Min Problem\n\nMax -Min Problem Algorithm\n\nMax -Min Problem Algorithm\n\u2022Step 1: Find the mid of the array.\n\u2022Step 2: Find the maximum and minimum of the left subarray recursively.\n\u2022Step 3: Find the maximum and minimum of the right subarray recursively.\n\u2022Step 4: Compare the result of step 3 and step 4\n\u2022Step 5: Return the minimum and maximum.", "mimetype": "text/plain", "start_char_idx": 9132, "end_char_idx": 10999, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b6b55756-074c-42ba-b0bb-f76a364d60a6": {"__data__": {"id_": "b6b55756-074c-42ba-b0bb-f76a364d60a6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1xPP8QAWYhHQc77VAxtY_qN6nC1SkELIO", "node_type": "4", "metadata": {}, "hash": "cd9b00acfc14cac3490afd0cbc744a5b51aac9ec0da6f98383dd6bb58222b7d3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "befea919-9995-4fa5-adf1-6442946beb59", "node_type": "1", "metadata": {}, "hash": "1a83717a3a82fa047f63795c53ca8036ff03227a5495a4ab8c9e566bdbf8d2fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022There are various ways to this problem, but the most traditional \napproach to to solve this problem is the linear approach. In the linear \napproach, we traverse all elements once and find the minimum and \nmaximum element.\n\u2022In this approach, the time complexity to solve this problem is \u03b8(n). \nExample of Max -Min Problem\n\nMax -Min Problem Algorithm\n\nMax -Min Problem Algorithm\n\u2022Step 1: Find the mid of the array.\n\u2022Step 2: Find the maximum and minimum of the left subarray recursively.\n\u2022Step 3: Find the maximum and minimum of the right subarray recursively.\n\u2022Step 4: Compare the result of step 3 and step 4\n\u2022Step 5: Return the minimum and maximum.\nMax -Min Problem Algorithm\nMinMaxDAC (A, i, j) {\n    if(i == j)\n        return (A[ i], A[i]);\n    if((j - i) == 1)\n        if (A[ i] < A[j])\n            return (A[ i], A[j])\n        else\n            return (A[j], A[ i])\n    else {\n        int mid = ( i + j) / 2;\n        LMin , LMax  = MinMaxDAC (A, i, mid);\n        RMin , RMax  = MinMaxDAC (A, mid + 1, j);\nMax -Min Problem Algorithm\nif(LMax  > RMax )\n            max = LMax ;\n        else\n            max = RMax ;\n        if(LMin  < RMin )\n            min = LMin ;\n        else\n            min = RMin ;\n        return (min, max);\nMax -Min Problem Analysis\nT(n) = 1,  if n = 1 or n = 2 \nT(n) = 2T(n/2) + C, if n > 2\nAfter solving the above recurrence relation,\nT(n) \u2248 \u039f(n)", "mimetype": "text/plain", "start_char_idx": 10351, "end_char_idx": 11724, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "61f93aad-a4d3-4d8e-9420-52d245615a9a": {"__data__": {"id_": "61f93aad-a4d3-4d8e-9420-52d245615a9a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27aa38d8-be5c-495a-a4b4-0ea363b871ed", "node_type": "1", "metadata": {}, "hash": "b048cb2025f5ded95baf187bc5037c1e80f32df955c6acf8a530bf2897417186", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Algorithm\n2.Writing an Algorithm Analysis\n3.Asymptotic Analysis\n4.Analyzing control statement, Loop invariant and \nthe correctness of the algorithm\n5.Recurrences\n6.Sorting Techniques with analysis\nWhat is Algorithm?\n\u2022The word algorithm comes from the name of a Persian mathematician \nAbu Ja\u2019far Mohammed ibn -i Musa al Khowarizmi . \n\u2022Algorithm is a finite set of instructions used to accomplish particular \ntask. \nAn algorithm takes some value, or set of values, as input and produces \nsome value, or set of values, as output. \nWhat is Algorithm?\nFig 1.1 Algorithm\nProperties of Algorithm\n\u2022Clear and Unambiguous: Each step should be clear and lead to only one \ninterpretation .\n\u2022Well -Defined Inputs: If an algorithm takes inputs, they should be well -\ndefined. An algorithm may or may not require inputs .\n\u2022Well -Defined Outputs: The algorithm must clearly define the output and \nproduce at least one output .\n\u2022Finiteness: The algorithm must terminate after a finite number of steps .\n\u2022Feasible: It must be simple, practical, and executable with available \nresources, without relying on future technology .\nProperties of Algorithm\n\u2022Language Independent: The algorithm should be independent of any \nspecific programming language .\n\u2022Deterministic: For the same input, the algorithm should produce the \nsame output .\n\u2022Effective: Every step in the algorithm must perform some work\nTypes of Algorithm\n\u2022Sorting  Algorithms : These  algorithms  rearrange  a given  array  or list of \nelements  in a specific  order  . Examples  include  merge  sort and quicksort  \n\u2022Searching  Algorithms : Used  to find specific  items  within  a collection  of \ndata  . Common  examples  include  linear  search  and binary  search  .\n\u2022Greedy  Algorithms : These  make  locally  optimal  choices  at each  step  in \nhopes  of finding  a global  optimum  solution  .\n\u2022Dynamic  Programming : An algorithmic  technique  that optimizes  \nrecursion  by storing  results  of repeated  calls  for the same  inputs  .\n\u2022Backtracking  Algorithms : These  explore  different  options  to find the best  \nsolution  by trying  different  paths  and backtracking  when  a path  doesn't  \nwork  .\n\u2022Divide  and Conquer  Algorithms : This strategy  involves  dividing  a problem  \ninto smaller  subproblems,  solving  them,  and combining  the solutions  .\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Algorithm\n2.Writing an Algorithm Analysis\n3.Asymptotic Analysis\n4.Analyzing control statement, Loop invariant and \nthe correctness of the algorithm\n5.Recurrences\n6.Sorting Techniques with analysis\nWhat is Algorithm Analysis?\n\u2022Definition: Evaluating an algorithm's performance in terms of time and \nspace .\n\u2022Goal: To estimate the resources (time, memory) that an algorithm \nconsumes .\n\u2022Importance:\n\u2022Choosing the most efficient algorithm for a task .\n\u2022Understanding scalability with increasing input size\nParameters for Algorithm Analysis\nTime Complexity\n\u2022Definition:  The amount of time required by an algorithm to complete \nits execution.\n\u2022Notation:  Big O, Big Omega, Big Theta.\n\u2022Common Time Complexities:\n\u2022O(1) - Constant Time\n\u2022O(n) - Linear Time\n\u2022O(n log n) - Linearithmic  Time\n\u2022O(n^2) - Quadratic Time\n\u2022O(log n) - Logarithmic Time\n\u2022O(2^n) - Exponential Time\nParameters for Algorithm Analysis\nSpace Complexity\n\u2022Definition: The amount of memory space required by an algorithm.\n\u2022Components: Instruction space, data space, environment stack space.\n\u2022Importance: Essential for algorithms processing large datasets.\nAlgorithm Design Techniques\nDivide  and Conquer\n\u2022Concept : Break  down  a problem  into smaller  subproblems,  solve  them  \nrecursively,  and combine  their  solutions .\n\u2022Examples : Merge  Sort,  Quick  Sort,  Binary  Search .\nDynamic  Programming\n\u2022Concept : Solve  overlapping  subproblems  by storing  their  solutions  to \navoid  recomputation .\n\u2022Examples : Fibonacci  sequence,  Knapsack  problem  etc.\n\u2022Greedy  Algorithms\n\u2022Concept : Make  locally  optimal  choices  at each  step  with  the hope  of \nfinding  a global  optimum .", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4313, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "27aa38d8-be5c-495a-a4b4-0ea363b871ed": {"__data__": {"id_": "27aa38d8-be5c-495a-a4b4-0ea363b871ed", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "61f93aad-a4d3-4d8e-9420-52d245615a9a", "node_type": "1", "metadata": {}, "hash": "b59d1741e6c99f8fc789c5a305752025a01665e4d81b689025e553a4154f1a66", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3656cd17-b055-4e24-809b-26808b7132a0", "node_type": "1", "metadata": {}, "hash": "e12d67f478beabed2ffc1b1d753e4082c41b8c1c522fd1d46f5cc001e097605d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Components: Instruction space, data space, environment stack space.\n\u2022Importance: Essential for algorithms processing large datasets.\nAlgorithm Design Techniques\nDivide  and Conquer\n\u2022Concept : Break  down  a problem  into smaller  subproblems,  solve  them  \nrecursively,  and combine  their  solutions .\n\u2022Examples : Merge  Sort,  Quick  Sort,  Binary  Search .\nDynamic  Programming\n\u2022Concept : Solve  overlapping  subproblems  by storing  their  solutions  to \navoid  recomputation .\n\u2022Examples : Fibonacci  sequence,  Knapsack  problem  etc.\n\u2022Greedy  Algorithms\n\u2022Concept : Make  locally  optimal  choices  at each  step  with  the hope  of \nfinding  a global  optimum .\n\u2022Examples : Dijkstra's  algorithm,  Prim's  algorithm,  Huffman  coding .\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Algorithm\n2.Writing an Algorithm Analysis\n3.Asymptotic Analysis\n4.Analyzing control statement, Loop invariant and \nthe correctness of the algorithm\n5.Recurrences\n6.Sorting Techniques with analysis\nWhy algorithm analysis?\n\u2022For one problem one or more solutions are available.\n\u2022Which one is better ? How can we choose?\n\u2022The analysis of an algorithm can help us in understanding of solution in \nbetter way.\n\u2022Time & Space analysis Image\nOrder of Growth\n\u2022Any algorithm is expected to work fast for any input size.\n\u2022Smaller input size algorithm will work fine but for higher input size \nexecution time is much higher.\n\u2022So how the behavior of algorithm changes with the no. of inputs will \ngive the analysis of the algorithm and is called the Order of Growth.\nAlgorithm falls under three types\nFig 1.1 :Algorithm falls under three types\nRate of Growth\nRate at which the running time increases as a function of input is called \nrate of growth.\n\nAsymptotic Complexity\n\u2022Refers to defining the mathematical bound of its run -time \nperformance.\n\u2022Running time of an algorithm as a function of input size n for large n.\n\u2022Asymptotic means approaching a value or curve arbitrarily.\nAsymptotic Notations\n\u2022Refers to defining the mathematical bound of its run -time \nperformance.\n\u2022Running time of an algorithm as a function of input size n for large n.\n\u2022Asymptotic means approaching a value or curve arbitrarily.\n\u039f Notation\n\u2022express the tight upper bound of an algorithm\n\u2022f(n)=O(g(n)) implies: \u039f(g(n)) = { f(n) : there exists positive constants c>0 \nand n0 such that f(n) \u2264 c.g(n) for all n > n0. }\nAsymptotic Notations\n\u03a9Notation\n\u2022express  the lower  bound  of an algorithm\n\u2022f(n)=  \n (g(n))  implies : \n (g(n))  = { f(n) : there  exists  positive  constants  c>0 \nand n0 such  that f(n) \u2265 g(n) for all n > n0. } \n\u03b8Notation\n\u2022express  both  the lower  bound  and the upper  bound  (tight  bound)\u201d\n\u2022f(n)=  \n (g(n))  implies : \n (g(n))  = { f(n) : there  exists  positive  constants  \nc1>0, c2>0 and n0 such  that c1.g(n) \u2264 f(n) \u2264 c2.g(n) for all n > n0. }", "mimetype": "text/plain", "start_char_idx": 3644, "end_char_idx": 6594, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3656cd17-b055-4e24-809b-26808b7132a0": {"__data__": {"id_": "3656cd17-b055-4e24-809b-26808b7132a0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27aa38d8-be5c-495a-a4b4-0ea363b871ed", "node_type": "1", "metadata": {}, "hash": "b048cb2025f5ded95baf187bc5037c1e80f32df955c6acf8a530bf2897417186", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a7aa49b6-b984-41e2-b837-beeea0e9befb", "node_type": "1", "metadata": {}, "hash": "4f49dcc9385f9a3abf81f8e6f03f84f75e228c8c9924e84c65e3442a34060cb9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Asymptotic Notations\n\u03a9Notation\n\u2022express  the lower  bound  of an algorithm\n\u2022f(n)=  \n (g(n))  implies : \n (g(n))  = { f(n) : there  exists  positive  constants  c>0 \nand n0 such  that f(n) \u2265 g(n) for all n > n0. } \n\u03b8Notation\n\u2022express  both  the lower  bound  and the upper  bound  (tight  bound)\u201d\n\u2022f(n)=  \n (g(n))  implies : \n (g(n))  = { f(n) : there  exists  positive  constants  \nc1>0, c2>0 and n0 such  that c1.g(n) \u2264 f(n) \u2264 c2.g(n) for all n > n0. } \nOR, if & only  if f(n)=O(g(n))  and f(n)=  \n (g(n))  for all n > n0\nAsymptotic Notations\n\nAsymptotic Notations\nExamples  on Big-O Notation(Upper  bound/Worst  case)  \n1)find  upper  bound  for f(n)= 2n+2 \nsolution :2n+2<=4n, for all n>=1 so 2n+2=O(n)  with  c=4 and n0 =1 \n2)find  upper  bound  for f(n)= 2n2+1 \nsolution :2n2+1<=3n2, for all n>=1 so 2n2+1=O(n 2) with  c=3 and n0 =1\n3)Find  upper  bound  for f(n)= 5n4+4n+1 \nSolution  : 5n4+4n+1 <=7n4, for all n>=2 so 5n4+4n+1 =O(n 4) with  c=7 and \nn0 =2 \n3)Find  upper  bound  for f(n)= 5n4+4n+1 \nSolution  : 5n4+4n+1 <=7n4, for all n>=2 so 5n4+4n+1 =O(n 4) with  c=7 and \nn0 =2\nNow Try to solve below Questions\nI.Find upper bound for f(n)=200 \nII. Find upper bound for f(n)=n3+n2 \nIII. Show that 20n3=O(n4) for appropriate c and n0. \nAsymptotic Notations\nExamples on Big - \u03a9 Notation(Lower bound/ Best case) \n1)find lower bound for f(n)=2n+2  \nsolution: 2n<=2n+2, for all n>=1 so 2n+2= \u03a9(n) with c=2 and n0 =1 \n2)find lower bound for f(n)=2n2+1 \nsolution: n2<=2n2+1, for all n>=1 so 2n2+1= \u03a9(n2) with c=1 and n0 =1\n3)Find lower bound for f(n)=5n4+4n+1 \nSolution : 4n4 <=5n4+4n+1, for all n>=1 so 5n4+4n+1 = \u03a9(n4) with c=4 and \nn0 =1\nNow Try to solve below Questions\n\nAsymptotic Notations\nExamples on Big - \u03b8 Notation(Tight bound/ Average case) \n1)find tight bound for f(n)=2n+2 \nsolution: 2n<=2n+2<=4n, for all n>=1 so 2n+2= \u03b8(n) with c1 =2, c2 =4 and \nn0 =1 \n2)find lower bound for f(n)=2n2+1 \nsolution: n2<=2n2+1<=3n2, for all n>=1 so 2n2+1= \u03b8(n2) with c1 =1, c2 =3 \nand n0 =1\nNow Try to solve below Questions\n\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs.", "mimetype": "text/plain", "start_char_idx": 6141, "end_char_idx": 8260, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a7aa49b6-b984-41e2-b837-beeea0e9befb": {"__data__": {"id_": "a7aa49b6-b984-41e2-b837-beeea0e9befb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3656cd17-b055-4e24-809b-26808b7132a0", "node_type": "1", "metadata": {}, "hash": "e12d67f478beabed2ffc1b1d753e4082c41b8c1c522fd1d46f5cc001e097605d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "801e1b8c-445d-4ac7-b67a-058e45d8706d", "node_type": "1", "metadata": {}, "hash": "ab6eec8c07acf9a2fb3fee4c96300cf167d5b0ec592a7bb9efca8865bbdf8f72", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Algorithm\n2.Writing an Algorithm Analysis\n3.Asymptotic Analysis\n4.Analyzing control statement, Loop invariant and \nthe correctness of the algorithm\n5.Recurrences\n6.Sorting Techniques with analysis\nAnalysing control statement\nControl Statements are:\n1.Sequencing\n2.For Loop\n3.While and Repeat loop\n1.Sequencing\nSequencing means putting one instruction after another\nExample\nint i=10; \u2026\u2026\u2026\u2026\u2026. 1\nprintf (\u201c%d\u201d,& i);\u2026\u2026\u2026..1\ni=i+5;\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u20261\nHere each instruction execute only once then \nfrequency count=1+1+1=3\n2. For Loops\nMain()\n{\nX=y+z;------------------------------ O(1)\nFor(i=1;i< n;i++)--------------------------------- O(n)\n{\nA=b+c;--------------------------- O(1)\n}\n}\nTotal Frequency Count=O(1)+O(n)=O(1+n)=O(n)\n3. While and Repeat Loops\n1) While(n>0) ----------- O(n)\n{\nn=n-1;----O(n)\n}\n total Frequency count= O(n)\n2)\nWhile(n>0)\n{\nn=n/2;\u2026\u2026\u2026\u2026\u2026.O(log n)\n}\nTotal frequency count= O(log n)\nWhat is a Loop Invariant?\nA loop invariant is a condition or property that:\n\u2022Holds true before the loop starts,\n\u2022Remains true after every iteration of the loop,\n\u2022And helps in proving the correctness of the algorithm.\nWhy is it important?\nLoop invariants are used to prove that a loop works correctly  and \ncontributes to the overall correctness of an algorithm.\nSteps to Use a Loop Invariant\n1.Initialization : True before the first iteration.\n2.Maintenance : Remains true during each iteration.\n3.Termination : Helps prove the final result is correct when the loop \nends.\nExample: Finding Minimum Value\nint min = arr[0];\nfor (int i = 1; i < n; i++) {\n    if (arr[i] < min)\n        min = arr[i];\n}\nLoop Invariant:At  the start of each iteration, min holds the minimum of \nelements arr[0] to arr[i-1].\nCorrectness of the Algorithm\nAn algorithm is correct  if:\n\u2022It produces the correct output  for all valid inputs.\n\u2022It terminates  (does not go into infinite loop).\nCorrectness = Partial Correctness + Termination\n\u2022\n  Partial correctness : Loop invariants help prove that the logic is \nsound.\n\u2022\n  Termination : Prove the loop stops after a finite number of steps.\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Algorithm\n2.Writing an Algorithm Analysis\n3.Asymptotic Analysis\n4.Analyzing control statement, Loop invariant and \nthe correctness of the algorithm\n5.Recurrences\n6.Sorting Techniques with analysis\nMethods For Solving Recurrence Relations\n1. Substitution method\n2. Recursion tree method\n3. Master method.\n1.Substitution method\nSubstitution Method is very famous method for solving any recurrences. \nThere are two types of substitution methods -\n1.Forward Substitution\n2.Backward Substitution\nForward Substitution\nIt is called Forward Substitution because here we substitute recurrence \nof any term into next terms. It uses following steps to find Time using \nrecurrences -\n\u2022Pick Recurrence Relation and the given initial Condition\n\u2022Put the value from previous recurrence into the next recurrence\n\u2022Observe and Guess the pattern and the time\n\u2022Prove that the guessed result is correct using mathematical Induction.\nForward Substitution\nExample\nT(n) = T(n -1) + n, n>1\nT(n) = 1, n=1 \nSolution:\n1. Pick Recurrence and the given initial Condition:\nT(n)=T(n -1)+n, n>1T(n)=1, n=1\n2. Put the value from previous recurrence into the next recurrence:\nT(1) = 1T(2) = T(1) + 2 = 1 + 2 = 3T(3) = T(2) + 3 = 1 + 2 + 3 = 6T(4)= T(3) + \n4 = 1 + 2 + 3 + 4 = 10\n3.", "mimetype": "text/plain", "start_char_idx": 8261, "end_char_idx": 11805, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "801e1b8c-445d-4ac7-b67a-058e45d8706d": {"__data__": {"id_": "801e1b8c-445d-4ac7-b67a-058e45d8706d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a7aa49b6-b984-41e2-b837-beeea0e9befb", "node_type": "1", "metadata": {}, "hash": "4f49dcc9385f9a3abf81f8e6f03f84f75e228c8c9924e84c65e3442a34060cb9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39c656e3-1237-41c8-afb1-94a247c6e73d", "node_type": "1", "metadata": {}, "hash": "6840b8af2485231c31b56e79b0a2db28486877e58762d6ee7e692af179fead94", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Forward Substitution\nExample\nT(n) = T(n -1) + n, n>1\nT(n) = 1, n=1 \nSolution:\n1. Pick Recurrence and the given initial Condition:\nT(n)=T(n -1)+n, n>1T(n)=1, n=1\n2. Put the value from previous recurrence into the next recurrence:\nT(1) = 1T(2) = T(1) + 2 = 1 + 2 = 3T(3) = T(2) + 3 = 1 + 2 + 3 = 6T(4)= T(3) + \n4 = 1 + 2 + 3 + 4 = 10\n3. Observe and Guess the pattern and the time:\nSo guessed pattern will be -T(n) = 1 + 2 + 3 .... + n = (n * (n+1))/2Time \nComplexity will be O(n2)\nForward Substitution\n4. Prove that the guessed result is correct using mathematical Induction:\nProve T(1) is true:\nT(1) = 1 * (1+1)/2 = 2/2 = 1 and from definition of recurrence we know \nT(1) = 1. Hence proved T(1) is true \nAssume T(N -1) to be true:\nAssume T(N -1) = ((N - 1) * (N -1+1))/2 = (N * (N -1))/2 to be true\nThen prove T(N) will be true:T (N) = T(N -1) + N from recurrence definition\nNow, T(N -1) = N * (N -1)/2So, T(N) = T(N -1) + N              = (N * (N -1))/2 + N              \n= (N * (N -1) + 2N)/2              =N * (N+1)/2And from our guess also \nT(N)=N(N+1)/2Hence T(N) is true.Therefore  our guess was correct and \ntime will be O(N2)\nBackward Substitution\nIt is called  Backward  Substitution  because  here  we substitute  recurrence  \nof any term  into previous  terms . It uses  following  steps  to find Time  \nusing  recurrences -\n\u2022Take  the main  recurrence  and try to write  recurrences  of previous  \nterms\n\u2022Take  just previous  recurrence  and substitute  into main  recurrence\n\u2022Again  take  one more  previous  recurrence  and substitute  into main  \nrecurrence\n\u2022Do this process  until  you reach  to the initial  condition\n\u2022After  this substitute  the the value  from  initial  condition  and get the \nsolution\nBackward Substitution\nExample :\nT(n) =T(n-1)+n,n>1T(n) =1,n=1\nSolution :\n1. Take the main recurrence and try to write recurrences of previous \nterms:\nT(n) = T(n -1) + nT(n-1) = T(n -2) + n - 1T(n -2) = T(n -3) + n \u2013 2\n2. Take just previous recurrence and substitute into main recurrence\nput T(n -1) into T(n)So, T(n)=T(n -2)+ n -1 + n\n3. Again take one more previous recurrence and substitute into main \nrecurrence\nput T(n -2) into T(n)So, T(n)=T(n -3)+ n -2 + n -1 + n\nBackward Substitution\n4. Do this process  until  you reach  to the initial  condition\nSo similarly,  we can find T(n-3), T(n-4)......and so on and can insert  into \nT(n). Eventually  we will get following : T(n)=T( 1) + 2 + 3 + 4 +......... + n-1 + \nn\n5. After  this substitute  the the value  from  initial  condition  and get the \nsolution\nPut T(1)=1, T(n) = 1 +2 +3 + 4 +.............. + n-1 + n = n(n+ 1)/2. So Time  will \nbe O(N2)\nRecursion tree method\nIn this method,  a recurrence  relation  is converted  into recursive  trees . \nEach  node  represents  the cost incurred  at various  levels  of recursion . To \nfind the total  cost,  costs  of all levels  are summed  up.", "mimetype": "text/plain", "start_char_idx": 11471, "end_char_idx": 14343, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "39c656e3-1237-41c8-afb1-94a247c6e73d": {"__data__": {"id_": "39c656e3-1237-41c8-afb1-94a247c6e73d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "801e1b8c-445d-4ac7-b67a-058e45d8706d", "node_type": "1", "metadata": {}, "hash": "ab6eec8c07acf9a2fb3fee4c96300cf167d5b0ec592a7bb9efca8865bbdf8f72", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "53831b68-db71-4ad5-b97c-b8c14a240c07", "node_type": "1", "metadata": {}, "hash": "ae5ca504b28a1b707a553ba6befe8191ecaf82c14a3768edeee96e6bf54e6d5f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Eventually  we will get following : T(n)=T( 1) + 2 + 3 + 4 +......... + n-1 + \nn\n5. After  this substitute  the the value  from  initial  condition  and get the \nsolution\nPut T(1)=1, T(n) = 1 +2 +3 + 4 +.............. + n-1 + n = n(n+ 1)/2. So Time  will \nbe O(N2)\nRecursion tree method\nIn this method,  a recurrence  relation  is converted  into recursive  trees . \nEach  node  represents  the cost incurred  at various  levels  of recursion . To \nfind the total  cost,  costs  of all levels  are summed  up.\nSteps  to solve  recurrence  relation  using  recursion  tree method :\n\u2022Draw  a recursive  tree for given  recurrence  relation\n\u2022Calculate  the cost at each  level  and count  the total  no of levels  in the \nrecursion  tree.\n\u2022Count  the total  number  of nodes  in the last level  and calculate  the \ncost of the last level\n\u2022Sum  up the cost of all the levels  in the recursive  tree\nRecursion tree method\nQuestion  1:\nT(n) = 2T(n/ 2) + c\nSolution : \nStep  1: Draw  a recursive  tree\n \n\nRecursion tree method\nStep  2: Calculate  the work  done  or cost at each  level  and count  total  no \nof levels  in recursion  tree \n\nRecursion tree method\nCount  the total  number  of levels  \u2013 \nChoose  the longest  path  from  root  node  to leaf node\n n/20 -\u2192 n/21 -\u2192 n/22 -\u2192 \u2026\u2026\u2026  -\u2192 n/2k\nSize of problem  at last level  = n/2k\n At last level  size of problem  becomes  1\n n/2k = 1\n 2k = n\n  k = log2(n)   \nTotal  no of levels   in recursive  tree = k +1 = log2(n) + 1\nRecursion tree method\n\u2022Step 3: Count total number of nodes in the last level and calculate cost of \nlast level\nNo. of nodes at level 0 = 20 = 1\nNo. of nodes at level 1 = 21 = 2\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\nNo. of nodes at the (k+1) th level (or last level) = 2k = 2log\n2(n) = nlog\n2(2) = n\nCost of sub problems at level last level = n x \u0398(1) = \u0398(n)\nRecursion tree method\n\u2022Step 4: Sum up the cost all the levels in recursive tree\n T(n) = c + 2c + 4c + \u2014- ((no. of levels -1) times) + last level cost\n= c + 2c + 4c + \u2014- (log2(n) times) + \u0398(n)\n= c(1 + 2 + 4 + \u2014- (log2(n) times)) + \u0398(n)\n1 + 2 + 4 + \u2014\u2013 (log2(n) times) \u2013> 20 + 21 + 22 + \u2014\u2013 (log2(n) times) \u2013> \nGeometric Progression(G.P .)\nUsing GP Sum Formula , we get the sum of the series as n\n= c(n) + \u0398(n)\nMaster method.\n\u2022The time  complexity  of the algorithm  is represented  in the form  of \nrecurrence  relation .\n\u2022When  analyzing  algorithms,  recall  that we only  care  about  the \nasymptotic  behavior\n\u2022Rather  than  solving  exactly  the recurrence  relation  associated  with  the \ncost of an algorithm,  it is sufficient  to give an asymptotic  characterization\n\u2022The main  tool for doing  this is the master  theorem\nMaster method.\n\nMaster method.\nExample 1\nLet T(n) = T(n/2) + \u00bd n2 + n. \nWhat are the parameters?\na = 1\nb = 2\nd = 2\nTherefore, which condition applies?\n \n\nMaster method.\nExample 2\n \n\nMaster Method.\nExample 3\n \n\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs.", "mimetype": "text/plain", "start_char_idx": 13834, "end_char_idx": 16784, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "53831b68-db71-4ad5-b97c-b8c14a240c07": {"__data__": {"id_": "53831b68-db71-4ad5-b97c-b8c14a240c07", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "39c656e3-1237-41c8-afb1-94a247c6e73d", "node_type": "1", "metadata": {}, "hash": "6840b8af2485231c31b56e79b0a2db28486877e58762d6ee7e692af179fead94", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8ba30654-25ec-4b4f-8de7-3ed5f0026a87", "node_type": "1", "metadata": {}, "hash": "2cf56aef919fec6faf5599bc4eeffc95982206808a4654b4c8d7277d4ff4001c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022The time  complexity  of the algorithm  is represented  in the form  of \nrecurrence  relation .\n\u2022When  analyzing  algorithms,  recall  that we only  care  about  the \nasymptotic  behavior\n\u2022Rather  than  solving  exactly  the recurrence  relation  associated  with  the \ncost of an algorithm,  it is sufficient  to give an asymptotic  characterization\n\u2022The main  tool for doing  this is the master  theorem\nMaster method.\n\nMaster method.\nExample 1\nLet T(n) = T(n/2) + \u00bd n2 + n. \nWhat are the parameters?\na = 1\nb = 2\nd = 2\nTherefore, which condition applies?\n \n\nMaster method.\nExample 2\n \n\nMaster Method.\nExample 3\n \n\nIntroduction &  Programming with \nESP8266\nIntroduction and Analysis of Algorithms \nChapter 1\nMrs. Bhumi Shah \nAssistant Professor\nComputer Science and Engineering\nContent\n1.Algorithm\n2.Writing an Algorithm Analysis\n3.Asymptotic Analysis\n4.Analyzing control statement, Loop invariant and \nthe correctness of the algorithm\n5.Recurrences\n6.Sorting Techniques with analysis\nSorting Techniques with analysis\n1.Bubble Sort\n2.Selection Sort \n3.Insertion sort\nBubble Sort\n\u2022Bubble  Sort is the simplest sorting  algorithm that works  by repeatedly  \nswapping  the adjacent  elements  if they  are in the wrong  order . This \nalgorithm  is not suitable  for large  data  sets as its average  and worst -case  \ntime  complexity  is quite  high .\n\nBubble Sort\n\u2022InBubble  sort,  each  element  is compared  with  its adjacent  element . If \nthe first element  is smaller  than  the second  one,  then  the positions  of \nthe elements  are interchanged,  otherwise  it is not changed .\n\u2022Then  next  element  is compared  with  its adjacent  element  and the same  \nprocess  is repeated  for all the elements  in the array  until  we get a \nsorted  array .\nBubble Sort Example\n\u2022Sort the following  array  in Ascending  order\n45 34 56 23 12\n\nBubble Sort Example\n\nBubble Sort Algorithm\n\nBubble Sort \n\u2022It is a simple  sorting  algorithm  that works  by comparing  each  pair of \nadjacent  items  and swapping  them  if they  are in the wrong  order .\n\u2022The pass  through  the list is repeated  until  no swaps  are needed,  \nwhich  indicates  that the list is sorted .\n\u2022As it only  uses  comparisons  to operate  on elements,  it is a \ncomparison  sort.\n\u2022Although  the algorithm  is simple,  it is too slow  for practical  use.\n\u2022The time  complexity  of bubble  sort is \ud835\udf3d(\ud835\udc8f^\ud835\udfd0 )\nBubble Sort Best case Analysis\n\nAnalysis of Bubble Sort\n\nAnalysis of Bubble Sort\n\nSelection Sort\nSelection Sort is a simple comparison -based sorting algorithm. It divides \nthe array into two parts:\n\u2022The sorted part (built from left to right)\n\u2022The unsorted part\nOn each pass:\n\u2022Find the minimum element from the unsorted part\n\u2022Swap it with the first unsorted element \nAlgorithm Steps\n1.Start from the first element, assume it's the minimum.\n2.Compare it with all other elements.\n3.If any smaller element is found, update the minimum index.\n4.Swap the minimum element with the first unsorted element.\n5.Repeat for the remaining unsorted part.", "mimetype": "text/plain", "start_char_idx": 16070, "end_char_idx": 19086, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8ba30654-25ec-4b4f-8de7-3ed5f0026a87": {"__data__": {"id_": "8ba30654-25ec-4b4f-8de7-3ed5f0026a87", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "11seGvA0PWwJDKzV5MwpALRMixSkF8DZ3", "node_type": "4", "metadata": {}, "hash": "3d7a7b3f30674e97929770ff82eaf386c4e01722292b06ba3d8979c898a0cedc", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "53831b68-db71-4ad5-b97c-b8c14a240c07", "node_type": "1", "metadata": {}, "hash": "ae5ca504b28a1b707a553ba6befe8191ecaf82c14a3768edeee96e6bf54e6d5f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Although  the algorithm  is simple,  it is too slow  for practical  use.\n\u2022The time  complexity  of bubble  sort is \ud835\udf3d(\ud835\udc8f^\ud835\udfd0 )\nBubble Sort Best case Analysis\n\nAnalysis of Bubble Sort\n\nAnalysis of Bubble Sort\n\nSelection Sort\nSelection Sort is a simple comparison -based sorting algorithm. It divides \nthe array into two parts:\n\u2022The sorted part (built from left to right)\n\u2022The unsorted part\nOn each pass:\n\u2022Find the minimum element from the unsorted part\n\u2022Swap it with the first unsorted element \nAlgorithm Steps\n1.Start from the first element, assume it's the minimum.\n2.Compare it with all other elements.\n3.If any smaller element is found, update the minimum index.\n4.Swap the minimum element with the first unsorted element.\n5.Repeat for the remaining unsorted part.\nExample of Selection Sort\nUnsorted array:[64, 25, 12, 22, 11]\nPass 1 :Minimum in [64, 25, 12, 22, 11] is 11\nSwap 11 with 64 \u2192 [11, 25, 12, 22, 64]\nPass 2: Minimum in [25, 12, 22, 64] is 12\nSwap 12 with 25 \u2192 [11, 12, 25, 22, 64]\nPass 3: Minimum in [25, 22, 64] is 22\nSwap 22 with 25 \u2192 [11, 12, 22, 25, 64]\nPass 4: Minimum in [25, 64] is 25Already in place \u2192 no\n swapSorted  array: [11, 12, 22, 25, 64]\nSelection Sort Algorithm\n# Input: Array A\n# Output: Sorted array A\nAlgorithm: Selection_Sort (A)\nfor i \u2190 1 to n -1 do\nminj  \u2190 i;\nminx \u2190 A[ i]; \nfor j \u2190 i + 1 to n do\nif A[j] < minx then\nminj  \u2190 j;\nminx \u2190 A[j];\nA[minj ] \u2190 A[ i];\nA[i] \u2190 minx;\nSelection Sort Analysis\n\nInsertion Sort \nInsertion Sort is a simple and intuitive sorting algorithm that builds the \nfinal sorted array one element at a time, similar to sorting playing cards in \nyour hand.\nHow It Works:\n\u2022Start from the second element.\n\u2022Compare the current element with all elements before it.\n\u2022Shift larger elements to the right.\n\u2022Insert the current element in its correct position.\nExample of Insertion Sort \nInitial array:[8, 4, 1, 5]\nPass 1 (i = 1):\nCompare 4 with 8 \u2192 shift 8 \u2192 insert 4[4, 8, 1, 5]\nPass 2  (i = 2):Compare 1 with 8 \u2192 shift 8\nCompare 1 with 4 \u2192 shift 4 \u2192 insert 1[1, 4, 8, 5]\nPass 3  (i = 3):\nCompare 5 with 8 \u2192 shift 8\nCompare 5 with 4 \u2192 insert 5[1, 4, 5, 8]\nFinal sorted array: [1, 4, 5, 8]\nInsertion Sort Algorithm \nInput: Array T\n# Output: Sorted array T\nAlgorithm: Insertion_Sort (T[1,\u2026,n])\nfor i \u2190 2 to n do\nx \u2190 T[ i];\nj \u2190 i \u2013 1; \nwhile x < T[j] and j > 0 do\nT[j+1] \u2190 T[j];\nj \u2190 j \u2013 1;\nT[j+1] \u2190 x;\nInsertion Sort Analysis", "mimetype": "text/plain", "start_char_idx": 18322, "end_char_idx": 20693, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f35240c5-57ae-46c0-87e0-cdd3b9eeb67f": {"__data__": {"id_": "f35240c5-57ae-46c0-87e0-cdd3b9eeb67f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1v8qSwjR0XHZVzUGqi3-8KQXxMAIAab1z", "node_type": "4", "metadata": {}, "hash": "ad746661805d58b6f2e19811e6c77769908ebabad061c05117a922c4bcabd342", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "PARUL INSTITUTE OF TECHNOLOGY  \nDEPARTMENT OF COMPUTER SCIENCE & ENGINEERING  \n5th SEMESTER  \nDESIGN AND ANALYSIS OF ALGORITHM  \n \nAssignment: 1  \n1) What is algorithm?  What are the algorithm design techniques?   List out the criteria that \nall algorithms must satisfy.  \n2) Define : time complexity, Space complexity, best case time complexity, average case \ntime complexity, worst case time complexity  \n3) Explain Asymptotic notation in detail  \n4) Time complexity of binary search is O(log n).justify  \n5) What are different methods of solving recurrence? Explain master method in detail.  \n6) Using master method solve the following recurrence  \nT(n)=16T(n/4)+n  \nT(n)=4T(n/2)+n2logn \nT(n)=7T(n/3)+n  \n7) Analyze time complexity for given algorithm  \n1) x=0;   2)  x=0;                   3)   x=0;  \ny=1;        i=1;   For(i=0;i<n;i++)  \nFor(i=0;i<n;i++)                    while(i<n)          For(j=0;j<n*n;j++)  \nFor(j=0;j<n;j++)       {       x++;  \n x++;            i=2*i;  \n    y=x*x;           x++;  \n          } \n  \n \n \n \n \n \n \n \nAssignment: 2  \n1) Explain Binary search with proper example.  \n2) Explain quick sort with proper example.  \n3) Explain merge sort with proper example.  \n4) Write down equation for Strassen multiplication using d & c method.  \n \n \nAssignment: 3  \n1) What is greedy approach? What are the characteristic of greedy algorithm? Explain the \nelements of greedy algorithm  \n2) What is minimum cost spanning tree? Write an algorithm for anyone method for finding \nthe minimum cost spanning tree. Also discuss its complexity.  \n3) Prove that any weighted connected graph with distinct weight has exactly one minimum \nspanning tree  \n4) Explain dijkstra\u2019s algorithm with example & also discuss its complexity  \n5) Explain single source shortest paths in directed acyclic graphs with suitable example  \n \nAssignment: 4  \n1) What are the characteristic of dynamic programming? Explain the elements of dynamic \nprogramming in brief.  \n2) How to solve knapsack problem using dynamic programming?  \n3) How Making Change Problem  can be solved using dynamic programming?  \n4) How LCS can be implemented using dynamic programming?  \n \nAssignment: 5  \n1) Explain BFS & DFS.  \n2) Explain n queen problem.  \n3) Explain knapsack problem.  \n4) Explain travelling salesman problem.  \n5) What is P , NP , NP Complete and NP hard Problem.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2357, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ba1fe4b5-3746-4b80-8d6d-6c284497a113": {"__data__": {"id_": "ba1fe4b5-3746-4b80-8d6d-6c284497a113", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "08db533c-e978-468b-ac88-64537e566cd6", "node_type": "1", "metadata": {}, "hash": "b7eb741bb146bef3595c6498559fd1abf859b04bcb59dc5f8312cda5c9bfa2e0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Design and Analysis \nof Algorithm  \nMrs. Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.1 Algorithm: Definition, Properties, Types of Algorithms.\u2026.................................................. ..........  2\n \n \n \n \n   \n                                                                                                                                                              1 \n \n1.1 Algorithm:  \nDefinition of Algorithm  \nAn algorithm  is a finite sequence of well-defined, step -by-step instructions or rules designed to \nperform a specific task or solve a particular problem. Algorithms can be expressed in various \nforms such as natural language, pseudocode, or programming languages.  \nProperties of Algorithms  \nAlgorithms possess several key  properties, which include:  \n\u2022 Finiteness: An algorithm must always terminate after a finite number of steps.  \n\u2022 Definiteness: Each step of the algorithm must be clearly and unambiguously defined.  \n\u2022 Inputs: An algorithm can have zero or more inputs that are externally provided.  \n\u2022 Outputs: An algorithm must produce one or more outputs, which are the results of the \ncomputations performed.  \n\u2022 Effectiveness: Each operation within the algorithm must be sufficiently basic that a \nperson using the algorithm could perform it with pencil and paper, meaning they are not \noverly complex . \nTypes of Algorithms  \nAlgorithms can be categorized in various ways based on their characteristics and functionalities:  \n1. Based on Functionality:  \n\u2022 Sorting Algorithms: Organize data in a specified order (e.g.,  QuickSort,  MergeSort).  \n\u2022 Searching Algorithms: Retrieve specific data from a collection (e.g.,  Binary \nSearch,  Linear Search).  \n\u2022 Graph Algorithms: Solve problems related to graph data structures (e.g.,  Dijkstra's \nAlgorithm,  Kruskal's Algorithm).  \n2. Based on Design Paradigm:  \n\u2022 Divide and Conquer: Breaks a problem into smaller subproblems (e.g.,  MergeSort).  \n\u2022 Dynamic Programming: Solves complex problems by breaking them down into \nsimpler overlapping subproblems (e.g.,  Fibonacci Sequence Calculation).  \n\u2022 Greedy Algorithms: Makes a sequence of choices that lead to a local optimum \n(e.g.,  Prim\u2019s Algorithm).  \n3. Based on Implementation:  \n\u2022 Recursive Algorithms: Solve a problem by calling themselves on smaller instances \n \n \n   \n                                                                                                                                                              2 \n \nof the same problem (e.g.,  Factorial Calculation).  \n\u2022 Iterative Algorithms: Use loops to repeat instructions (e.g.,  Fibonacci using a loop).  \n4. Based on Complexity:  \n\u2022 Polynomial Time Algorithms: Have a running time that can be expressed as a \npolynomial function of the size of the input (e.g.,  Insertion Sort).  \n\u2022 Exponential Time Algorithms: Have a running time that grows exponentially with \nthe input size (e.g., some solutions for the  Traveling Salesman Problem).  \n \nNext Steps  \n\u2022 Explore About Algorithm.  \n\u2022 Learn about  Properties of Algorithm . \n\u2022 Learn about Types of Algorithms . \nReferences:  \n1. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n2. Introduction to Algorithm: \nhttps://enos.itcollege.ee/~japoia/algorithms/GT/Introduction_to_algorithms -3rd%20Edition.pdf\n \n \n   \n                                                                                                                                                              1 \n \n    \n \n \n\n  \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nDesign and Analysis \nof Algorithm  \nMrs. Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.2 Writing an Algorithm Analysis ..\u2026............................................. .......... .................... ...................3\n \n \n \n \n   \n                                                                                                                                                              1 \n \n1.2 Writing an Algorithm Analysis  \nWhat is Algorithm Analysis?  \n\u2022 Definition: Evaluating an algorithm's performance in terms of time and space .  \n\u2022 Goal: To estimate the resources (time, memory) that an algorithm consumes .  \n\u2022 Importance:  \n\u2022 Choosing the most efficient algorithm for a task .  \nUnderstanding scalability with increasing input size  \n \nParameters for Algorithm Analysis  \nTime Complexity  \n\u2022 Definition:  The amount of time required by an algorithm to complete its execution.  \n\u2022 Notation:  Big O, Big Omega, Big Theta.  \n\u2022 Common Time Complexities:  \n\u2022 O(1) - Constant Time  \n\u2022 O(n) - Linear Time  \n\u2022 O(n log n) - Linearithmic Time  \n\u2022 O(n^2) - Quadratic Time  \n\u2022 O(log n) - Logarithmic Time  \n\u2022 O(2^n) - Exponential Time  \nSpace Complexity  \n\u2022 Definition: The amount of memory space required by an algorithm.  \n\u2022 Components: Instruction space, data space, environment stack space.  \n\u2022 Importance: Essential for algorithms processing large datasets.", "mimetype": "text/plain", "start_char_idx": 66, "end_char_idx": 5093, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "08db533c-e978-468b-ac88-64537e566cd6": {"__data__": {"id_": "08db533c-e978-468b-ac88-64537e566cd6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ba1fe4b5-3746-4b80-8d6d-6c284497a113", "node_type": "1", "metadata": {}, "hash": "0cee99696d0965166b93a118d5678ae0eb63a971c70be5f990f75db9386c2752", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4652e6ee-e95e-4c65-9836-8ec61a518cca", "node_type": "1", "metadata": {}, "hash": "bcdd002dfb358e6dfe54b8ab15299f43cb0e16e5833d8e459909c7dd76e2447a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Goal: To estimate the resources (time, memory) that an algorithm consumes .  \n\u2022 Importance:  \n\u2022 Choosing the most efficient algorithm for a task .  \nUnderstanding scalability with increasing input size  \n \nParameters for Algorithm Analysis  \nTime Complexity  \n\u2022 Definition:  The amount of time required by an algorithm to complete its execution.  \n\u2022 Notation:  Big O, Big Omega, Big Theta.  \n\u2022 Common Time Complexities:  \n\u2022 O(1) - Constant Time  \n\u2022 O(n) - Linear Time  \n\u2022 O(n log n) - Linearithmic Time  \n\u2022 O(n^2) - Quadratic Time  \n\u2022 O(log n) - Logarithmic Time  \n\u2022 O(2^n) - Exponential Time  \nSpace Complexity  \n\u2022 Definition: The amount of memory space required by an algorithm.  \n\u2022 Components: Instruction space, data space, environment stack space.  \n\u2022 Importance: Essential for algorithms processing large datasets.  \n \nAlgorithm Design Techniques  \nDivide and Conquer  \n\u2022 Concept:  Break down a problem into smaller subproblems, solve them recursively, and \ncombine their solutions.  \n\u2022 Examples:  Merge Sort, Quick Sort, Binary Search.  \nDynamic Programming  \n\u2022 Concept:  Solve overlapping subproblems by storing their solutions to avoid \n \n \n   \n                                                                                                                                                              2 \n \nrecomputation.  \n\u2022 Examples:  Fibonacci sequence, Knapsack problem etc.  \n\u2022 Greedy Algorithms  \n\u2022 Concept:  Make locally optimal choices at each step with the hope of finding a global \noptimum.  \n\u2022 Examples:  Dijkstra's algorithm, Prim's algorithm, Huffman coding.  \n \n \nNext Steps  \n\u2022 Explore Asymptotic Analysis . \n\u2022 Learn about  Best  Case, Worst Case, Average Case . \nReferences:  \n3. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n4. Introduction to Algorithm: \nhttps://enos.itcollege.ee/~japoia/algorithms/GT/Introduction_to_algorithms -3rd%20Edition.pdf  \n \n \n   \n                                                                                                                                                              1 \n \n    \n \n \n\n  \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nDesign and Analysis \nof Algorithm  \nMrs. Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.3 Asymptotic Analysis \u2026\u2026...\u2026.................................................. .......... .................... ...................3\n \n \n \n \n   \n                                                                                                                                                              2 \n \n1.3 Asymptotic Analysis  \nAsymptotic notation  is used  to describe  the running  time  of an algorithm. \nIt shows order of growth of function.  \n\u0398-Notation  (Same  order)  \n\u2022 For a given  function  g(n),  we denote  by \u0398(g(n)) the set of functions  \n\u0398(g(n)) = {  f(n) : there exist  positive constants c 1, c2 and n0 such  that 0 \n\u2264 c 1g(n) \u2264 f (n) \u2264  c2g(n) for all n  \u2265 n 0 } \n\u2022 Because  \u0398(g(n)) is a set, we  could  write  f(n) \u20ac \u0398(g(n)) to indicate  that f(n) is a member  of \u0398(g(n)). \n\u2022 This notation  bounds  a function to within constant factors. We say f(n) = \u0398( g(n)) if there exist \npositive constants n0, c1 and c2 such  that to the right  of n0 the value of f(n) always lies between c1g(n) \nand c2g(n) inclusive.  \n\u2022 Figure a gives an intuitive picture of functions f(n) and g(n). For all values of n  to the right  of n 0, the \nvalue of f(n) lies  at or above c 1g(n) and at or below  c2g(n). In  other  words, for  all n  \u2265 n 0, the value of \nf(n) is equal to g(n) to within a constant factor.  \n\u2022 We say  that g(n) is an asymptotically  tight  bound  for f(n). \n \nO-Notation  (Upper  Bound)  \n\u2022 For a given  function  g(n),  we denote  by \u039f(g(n)) the set of functions  \n\u039f(g(n)) = {  f(n) : there exist  positive constants c and n 0 such that  0 \u2264 f \n(n) \u2264 cg(n) for all n \u2265 n 0 } \n\u2022 We use \u039f notation  to give an upper  bound  on a function,  to within  a constant  factor.", "mimetype": "text/plain", "start_char_idx": 4271, "end_char_idx": 8269, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4652e6ee-e95e-4c65-9836-8ec61a518cca": {"__data__": {"id_": "4652e6ee-e95e-4c65-9836-8ec61a518cca", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "08db533c-e978-468b-ac88-64537e566cd6", "node_type": "1", "metadata": {}, "hash": "b7eb741bb146bef3595c6498559fd1abf859b04bcb59dc5f8312cda5c9bfa2e0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5cf9c845-93f8-4b8c-a5a0-99311af1b76f", "node_type": "1", "metadata": {}, "hash": "454b7c16d615828a80d202cd91f6ae21664f33c6905f8104b3cb745f655b46b5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In  other  words, for  all n  \u2265 n 0, the value of \nf(n) is equal to g(n) to within a constant factor.  \n\u2022 We say  that g(n) is an asymptotically  tight  bound  for f(n). \n \nO-Notation  (Upper  Bound)  \n\u2022 For a given  function  g(n),  we denote  by \u039f(g(n)) the set of functions  \n\u039f(g(n)) = {  f(n) : there exist  positive constants c and n 0 such that  0 \u2264 f \n(n) \u2264 cg(n) for all n \u2265 n 0 } \n\u2022 We use \u039f notation  to give an upper  bound  on a function,  to within  a constant  factor.  For all values  of \n \n \n   \n                                                                                                                                                              3 \n \nn to the right  of n 0, the value of  the function  f(n) is on or below  g(n).  \n\u2022 This notation gives  an upper bound for a  function to  within  a constant  factor.  We write  f(n) = O(g(n)) \nif there are positive constants  n0 and c such  that to the right  of n0, the value of f(n) always lies on  or \nbelow cg(n). \n\u2022 We say that g(n) is an asymptotically  upper  bound  for f(n). \n \nExample:  \nLet f(n)=n2 and g(n)=2n \n \nHere  for n \u2265 4 we have \nbehavior f (n) \u2264 g(n) \nWhere n 0=4 \n \n \n \n \n \n \n\u03a9-Notation  (Lower  Bound)  \n\u2022 For a given  function  g(n),  we denote  by \u2126(g(n)) the set of functions  \n\u2126 (g(n)) = {  f(n) : there exist  positive constants c and n0 such that  0 \u2264 \ncg(n)  \u2264 f (n)for all n \u2265 n 0 } \n\u2022 \u2126 Notation  provides an  asymptotic  lower  bound.  For all values of n to the right of n 0, the value of \nthe function f(n) is on or above cg(n).  \nThis notation gives  a lower  bound  for a function  to within  a constant  factor.  We write f(n) = n f(n)=n2 g(n)=2n \n1 1 2 f(n) < g(n) \n2 4 4 f(n) = g(n) \n3 9 8 f(n) > g(n) \n4 16 16 f(n) = g(n) \n5 25 32 f(n) < g(n) \n6 36 64 f(n) < g(n) \n7 49 128 f(n) < g(n) \n \n \n \n   \n                                                                                                                                                              4 \n \n\u03a9(g(n)) if there are positive constants n0 and c such that to the right of n0, the value of f(n) \nalways lies on or Here  for n \u2265  4 we have behavior f (n) \u2265  g(n) \nWhere  n0=4 \n\u2022 above cg(n). \nHere  for n \u2265  4 we have behavior f (n) \u2265 g(n)  \nWhere  n0=4 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nLet f(n)=  2n and g(n)=  n2 \n \nn f(n)=  2n g(n)=  n2 \n1 2 1 f(n) > g(n) \n2 4 4 f(n) = g(n) \n3 8 9 f(n) < g(n) \n4 16 16 f(n) = g(n) \n5 32 25 f(n) > g(n) \n6 64 36 f(n) > g(n) \n7 128 49 f(n) > g(n) \n \n \n\u2022 Best case  helps evaluate an algorithm\u2019s efficiency under optimal conditions.  \n\u2022 Worst case  defines the upper limit of performance, ensuring reliability under all possible scenarios.  \n\u2022 Average case  gives a more practical measure, reflecting typical usage conditions.\n \n \n   \n                                                                                                                                                              1 \n \n \nNext Steps  \n\u2022 Explore variou s Algorithm . \n\u2022 Learn about  Analysing control statement,  \n\u2022 Learn about Loop invariant and the correctness of the algorithm  \nReferences:  \n5. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n6.", "mimetype": "text/plain", "start_char_idx": 7787, "end_char_idx": 10956, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5cf9c845-93f8-4b8c-a5a0-99311af1b76f": {"__data__": {"id_": "5cf9c845-93f8-4b8c-a5a0-99311af1b76f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4652e6ee-e95e-4c65-9836-8ec61a518cca", "node_type": "1", "metadata": {}, "hash": "bcdd002dfb358e6dfe54b8ab15299f43cb0e16e5833d8e459909c7dd76e2447a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7300b9b4-b4a5-412d-b334-67426e72651b", "node_type": "1", "metadata": {}, "hash": "15fa317be725ed16fc6ff53e8159099271e9893a4aa7067437ecc2d9decf062f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Worst case  defines the upper limit of performance, ensuring reliability under all possible scenarios.  \n\u2022 Average case  gives a more practical measure, reflecting typical usage conditions.\n \n \n   \n                                                                                                                                                              1 \n \n \nNext Steps  \n\u2022 Explore variou s Algorithm . \n\u2022 Learn about  Analysing control statement,  \n\u2022 Learn about Loop invariant and the correctness of the algorithm  \nReferences:  \n5. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n6. Introduction to Algorithm: \nhttps://enos.itcollege.ee/~japoia/algorithms/GT/Introduction_to_algorithms -3rd%20Edition.pdf  \n \n \n   \n                                                                                                                                                              1 \n \n    \n \n \n\n  \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nDesign and Analysis \nof Algorithm  \nMrs. Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.4 Analysing control stat ement .................................... .......... .................... ................... ......... 3\n \n \n \n \n   \n                                                                                                                                                              1 \n \n1.4 Analysing control statement, Loop invariant and \nthe correctness of the algorithm  \nAnalysing Control Statement  \nWhen analyzing algorithms, particularly those that involve loops, three key concepts come into \nplay: control statements, loop invariants, and algorithm correctness. Each plays a crucial role in \nunderstanding how an algorithm operates and ensuring it behaves as intended. Here is a detailed \nbreakdown of each concept:  \nControl Statements are:  \n1. Sequencing  \n2. For Loop  \n3. While and Repeat loop  \nSequencing  \nSequencing means putting one instruction after another  \nExample  \nint i=10; \u2026\u2026\u2026\u2026\u2026. 1  \nprintf(\u201c%d\u201d,&i);\u2026\u2026\u2026..1  \ni=i+5;\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u20261  \nHere each instruction execute only once then  \nfrequency count=1+1+1=3  \nFor Loops  \nMain()  \n{ \nX=y+z; ------------------------------ O (1)  \nFor(i=1;i<n;i++) --------------------------------- O(n)  \n{ \nA=b+c; --------------------------- O (1)  \n} \n} \nTotal Frequency Count=O(1)+O(n)=O(1+n)=O(n)  \n \nWhile and Repeat Loops  \n \n \n   \n                                                                                                                                                              2 \n \n1) While(n>0) ----------- O(n)  \n{ \nn=n-1;----O(n)  \n} \n total Frequency count= O(n)  \n \n2) \nWhile(n>0)  \n{ \nn=n/2;\u2026\u2026\u2026\u2026\u2026.O(log n)  \n} \nTotal frequency count= O(log n)  \nWhat is a Loop Invariant?  \nA loop invariant is a condition or property that:  \n\u2022 Holds true before the loop starts,  \n\u2022 Remains true after every iteration of the loop,  \n\u2022 And helps in proving the correctness of the algorithm.  \nWhy is it important?  \nLoop invariants are used to prove that a loop works correctly and contributes to the overall \ncorrectness of an algorithm.  \nSteps to Use a Loop Invariant  \n1. Initialization: True before the first iteration.  \n2. Maintenance: Remains true during each iteration.  \n3. Termination: Helps prove the final result is correct when the loop ends.  \nExample: Finding Minimum Value  \nint min = arr[0];  \nfor (int i = 1; i < n; i++) {  \n    if (arr[i] < min)  \n        min = arr[i];  \n} \n \nLoop Invariant :  At the start of each iteration, min holds the minimum of elements    arr[0] to \n \n \n   \n                                                                                                                                                              1 \n \n    \n \n \n\n  \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nDesign and Analysis \nof Algorithm  \nMrs. Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.5 Recurrences \u2026\u2026\u2026\u2026...\u2026.................................................. .......... .................... ...................3\n \n \n \n \n   \n                                                                                                                                                              1 \n \n1.5 Recurrences : \nSubstitution Method   \nSubstitution Method is very famous method for solving any recurrences. There are two types of \nsubstitution methods - \n1. Forward Substitution  \n2. Backward Substitution  \nForward Substitution : \nIt is called Forward Substitution because here we substitute recurrence of any term into next \nterms. It uses following steps to find Time using recurrences - \n\u2022 Pick Recurrence Relation and the given initial Condition  \n\u2022 Put the value from previous recurrence into the next recurrence  \n\u2022 Observe and Guess the pattern and the time  \n\u2022 Prove that the guessed result is correct using mathematical Induction.", "mimetype": "text/plain", "start_char_idx": 10332, "end_char_idx": 15273, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7300b9b4-b4a5-412d-b334-67426e72651b": {"__data__": {"id_": "7300b9b4-b4a5-412d-b334-67426e72651b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5cf9c845-93f8-4b8c-a5a0-99311af1b76f", "node_type": "1", "metadata": {}, "hash": "454b7c16d615828a80d202cd91f6ae21664f33c6905f8104b3cb745f655b46b5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2a25230f-1f65-4046-859e-ae468afb24b9", "node_type": "1", "metadata": {}, "hash": "3675046093996c9fad964211e572aa2f07e9576e85ba95e92bd67d1146ef95ea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.5 Recurrences \u2026\u2026\u2026\u2026...\u2026.................................................. .......... .................... ...................3\n \n \n \n \n   \n                                                                                                                                                              1 \n \n1.5 Recurrences : \nSubstitution Method   \nSubstitution Method is very famous method for solving any recurrences. There are two types of \nsubstitution methods - \n1. Forward Substitution  \n2. Backward Substitution  \nForward Substitution : \nIt is called Forward Substitution because here we substitute recurrence of any term into next \nterms. It uses following steps to find Time using recurrences - \n\u2022 Pick Recurrence Relation and the given initial Condition  \n\u2022 Put the value from previous recurrence into the next recurrence  \n\u2022 Observe and Guess the pattern and the time  \n\u2022 Prove that the guessed result is correct using mathematical Induction.  \nExample  \nT(n) = T(n -1) + n, n>1  \nT(n) = 1, n=1  \nSolution:  \n1. Pick Recurrence and the given initial Condition:  \nT(n)=T(n -1)+n, n>1T(n)=1, n=1  \n2. Put the value from previous recurrence into the next recurrence:  \nT(1) = 1T( 2) = T(1) + 2 = 1 + 2 = 3T(3) = T(2) + 3 = 1 + 2 + 3 = 6T(4)= T(3) + 4 = 1 + 2 + 3 + 4 = 10  \n3. Observe and Guess the pattern and the time:  \nSo guessed pattern will be -T(n) = 1 + 2 + 3 .... + n = (n * (n+1))/2Time Complexity will be O(n2)  \n4. Prove that the guessed result is correct using mathematical Induction:  \nProve T(1) is true:  \nT(1) = 1 * (1+1)/2 = 2/2 = 1 and from definition of recurrence we know T(1) = 1. Hence proved \nT(1) is true  \nAssume T(N -1) to be true:  \nAssume T(N -1) = ((N - 1) * (N -1+1))/2 = (N * (N-1))/2 to be true  \nThen prove T(N) will be true:T(N) = T(N -1) + N from recurrence definition  \nNow, T(N -1) = N * (N -1)/2So, T(N) = T(N -1) + N               \n \n \n   \n                                                                                                                                                              2 \n \n= (N * (N -1))/2 + N               \n= (N * (N -1) + 2N)/2               \n=N * (N+1)/2And from our guess also T(N)=N(N+1)/2Hence T(N) is true.Therefore our guess was \ncorrect and time will be O(N2)  \n \nBackward Substitution  \nIt is called Backward Substitution because here we substitute recurrence of any term into \nprevious terms. It uses following steps to find Time using recurrences - \n\u2022 Take the main recurrence and try to write recurrences of previous terms  \n\u2022 Take just previous recurrence and substitute into main recurrence  \n\u2022 Again take one more previous recurrence and substitute into main recurrence  \n\u2022 Do this process until you reach to the initial condition  \n\u2022 After this substitute the the value from initial condition and get the solution  \nExample:  \nT(n) = T(n -1) + n, n>1T(n) = 1, n = 1  \nSolution:  \n1. Take the main recurrence and try to write recurrences of previous terms:  \nT(n) = T(n -1) + nT(n -1) = T(n -2) + n - 1T(n -2) = T(n -3) + n \u2013 2 \n2. Take just previous recurrence and substitute into main recurrence  \nput T(n -1) into T(n)So, T(n)=T(n -2)+ n -1 + n  \n3. Again take one more previous recurrence and substitute into main recurrence  \nput T(n -2) into T(n)So, T(n)=T(n -3)+ n -2 + n -1 + n  \n. Do this process until you reach to the initial condition  \nSo similarly, we can find T(n -3), T(n -4)......and so on and can insert into T(n). Eventually we will \nget following: T(n)=T(1) + 2 + 3 + 4 +.........+ n -1 + n  \n5.", "mimetype": "text/plain", "start_char_idx": 14228, "end_char_idx": 17830, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2a25230f-1f65-4046-859e-ae468afb24b9": {"__data__": {"id_": "2a25230f-1f65-4046-859e-ae468afb24b9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7300b9b4-b4a5-412d-b334-67426e72651b", "node_type": "1", "metadata": {}, "hash": "15fa317be725ed16fc6ff53e8159099271e9893a4aa7067437ecc2d9decf062f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cbae03db-0e84-435c-a6eb-78e5dd785883", "node_type": "1", "metadata": {}, "hash": "1013d3ed5745c73256e3211ca8215815160535e60fd028047268f116616ef6c1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Take just previous recurrence and substitute into main recurrence  \nput T(n -1) into T(n)So, T(n)=T(n -2)+ n -1 + n  \n3. Again take one more previous recurrence and substitute into main recurrence  \nput T(n -2) into T(n)So, T(n)=T(n -3)+ n -2 + n -1 + n  \n. Do this process until you reach to the initial condition  \nSo similarly, we can find T(n -3), T(n -4)......and so on and can insert into T(n). Eventually we will \nget following: T(n)=T(1) + 2 + 3 + 4 +.........+ n -1 + n  \n5. After this substitute the the value from initial condition and get the solution  \nPut T(1)=1, T(n) = 1 +2 +3 + 4 +..............+ n -1 + n = n(n+1)/2. So Time will be O(N2)  \n \n \n \n \n \n \n \n   \n                                                                                                                                                              3 \n \nRecursion tree method  \nIn this method, a recurrence relation is converted into recursive trees. Each node represents the \ncost incurred at various levels of recursion. To find the total cost, costs of all levels are summed \nup. \nSteps to solve recurrence relation using recursion tree method:  \n\u2022 Draw a recursive tree for given recurrence relation  \n\u2022 Calculate the cost at each level and count the total no of levels in the recursion tree.  \n\u2022 Count the total number of nodes in the last level and calculate the cost of the last level  \nSum up the cost of all the levels in the recursive tree  \nQuestion 1:  \nT(n) = 2T(n/2) + c  \nSolution:  \nStep 1: Draw a recursive tree  \n  \n \nStep 2: Calculate the work done or cost at each level and count total no of levels in recursion tree   \n \n \n\n \n \n   \n                                                                                                                                                              4 \n \nCount the total number of levels \u2013  \nChoose the longest path from root node to leaf node  \n n/20 -\u2192 n/21 -\u2192 n/22 -\u2192 \u2026\u2026\u2026 -\u2192 n/2k  \nSize of problem at last level = n/2k  \n At last level size of problem becomes 1  \n n/2k = 1  \n 2k = n  \n  k = log2(n)    \nTotal no of levels  in recursive tree = k +1 = log2(n) + 1  \nStep 3:  Count total number of nodes in the last level and calculate cost of last level  \n No. of nodes at level 0 = 20 = 1 \n  No. of nodes at level 1 = 21 = 2 \n \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  \nNo. of nodes at the (k+1)th level (or last level) = 2k = 2log2(n) = nlog2(2) = n \n Cost of sub problems at level last level = n x \u0398(1) = \u0398(n)  \nStep 4:  Sum up the cost all the levels in recursive tree   \n   T(n) = c + 2c + 4c + \u2014- ((no. of levels -1) times) + last level cost  \n = c + 2c + 4c + \u2014- (log 2(n) times) + \u0398(n)  \n = c(1 + 2 + 4 + \u2014- (log 2(n) times)) + \u0398(n)  \n 1 + 2 + 4 + \u2014\u2013 (log 2(n) times) \u2013> 20 + 21 + 22 + \u2014\u2013 (log2(n) times) \u2013> Geometric Progression(G.P.)  \nUsing GP Sum Formula , we get the sum of the series as n  \n= c(n) + \u0398(n)  \n \nMaster method.  \n\u2022 The time complexity of the algorithm is represented in the form of recurrence relation.  \n\u2022 When analyzing algorithms, recall that we only care about the asymptotic behavior  \n\u2022 Rather than solving exactly the recurrence relation associated with the cost of an \nalgorithm, it is sufficient to give an asymptotic characterization  \n\u2022 The main tool for doing this is the master theorem  \n \n \n   \n                                                                                                                                                              5 \n \n \nExample 1  \nLet T(n) = T(n/2) + \u00bd n2 + n.  \nWhat are the parameters?  \na = 1  \nb = 2  \nd = 2  \nTherefore, which condition applies?  \n \nExample 2  \n \n \nNext Steps  \n\u2022 Explore various Recursion Technique.  \n\u2022 Learn about  Different Techniques - substitution method, recursion tree method, master method . \nReferences:  \n9. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n10.", "mimetype": "text/plain", "start_char_idx": 17347, "end_char_idx": 21183, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cbae03db-0e84-435c-a6eb-78e5dd785883": {"__data__": {"id_": "cbae03db-0e84-435c-a6eb-78e5dd785883", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2a25230f-1f65-4046-859e-ae468afb24b9", "node_type": "1", "metadata": {}, "hash": "3675046093996c9fad964211e572aa2f07e9576e85ba95e92bd67d1146ef95ea", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8c1d31e9-f3e2-4ff1-a19b-7081436bea60", "node_type": "1", "metadata": {}, "hash": "8c73fa7f3b82e8ca0deaaa3deb89ca0980321c7e7ebbe21145cbc686aaea59f3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 The time complexity of the algorithm is represented in the form of recurrence relation.  \n\u2022 When analyzing algorithms, recall that we only care about the asymptotic behavior  \n\u2022 Rather than solving exactly the recurrence relation associated with the cost of an \nalgorithm, it is sufficient to give an asymptotic characterization  \n\u2022 The main tool for doing this is the master theorem  \n \n \n   \n                                                                                                                                                              5 \n \n \nExample 1  \nLet T(n) = T(n/2) + \u00bd n2 + n.  \nWhat are the parameters?  \na = 1  \nb = 2  \nd = 2  \nTherefore, which condition applies?  \n \nExample 2  \n \n \nNext Steps  \n\u2022 Explore various Recursion Technique.  \n\u2022 Learn about  Different Techniques - substitution method, recursion tree method, master method . \nReferences:  \n9. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n10. Introduction to Algorithm: \nhttps://enos.itcollege.ee/~japoia/algorithms/GT/Introduction_to_algorithms -3rd%20Edition.pdf   \n\n \n \n   \n                                                                                                                                                              6 \n \n    \n \n \n \n \n \n \n \n \n \n \n \n \n \n   \n                                                                                                                                                              1 \n \n    \n \n \n\n  \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nDesign and Analysis \nof Algorithm  \nMrs. Bhumi Shah  \nCSE, PIT  \nParul University  \n \n \n Study \nGuide  \n                      \n \n \n \n \n \n1.6 Sorting Techniques with analysis \u2026\u2026\u2026\u2026...\u2026.................................................. .......... ....................\n \n \n \n \n   \n                                                                                                                                                              2 \n \n1.6 Sorting Techniques with analysis : \nBubble Sort  \n\u2022 In the bubble sort, the consecutive elements of the table are compared and if the keys of the two \nelements are not found in  proper order, they are interchanged.  \n\u2022 It starts from the beginning of the table and continue till the end of the table.  As a result of  this the \nelement with the largest key will be pushed to the last element\u2019s position.  \n\u2022 After this the second pass is made. The second  pass is exactly  like the first  one except  that this time \nthe elements except the last are considered.  After  the second  pass, the next  largest  element  will be \npushed down  to the  next to last position.", "mimetype": "text/plain", "start_char_idx": 20217, "end_char_idx": 22867, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8c1d31e9-f3e2-4ff1-a19b-7081436bea60": {"__data__": {"id_": "8c1d31e9-f3e2-4ff1-a19b-7081436bea60", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cbae03db-0e84-435c-a6eb-78e5dd785883", "node_type": "1", "metadata": {}, "hash": "1013d3ed5745c73256e3211ca8215815160535e60fd028047268f116616ef6c1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1595030f-423a-4445-b8c8-1226894bfacb", "node_type": "1", "metadata": {}, "hash": "7a557ce2927c160b6ffea321c8783aaaf017e70a5849488e3375e1dfaa438a2c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 It starts from the beginning of the table and continue till the end of the table.  As a result of  this the \nelement with the largest key will be pushed to the last element\u2019s position.  \n\u2022 After this the second pass is made. The second  pass is exactly  like the first  one except  that this time \nthe elements except the last are considered.  After  the second  pass, the next  largest  element  will be \npushed down  to the  next to last position.  \nAlgorithm  \nProcedure  bubble (T[1\u2026.n]) cost times \nfor i \u2190 1 to n do C1 n+1 \nfor i \u2190 1 to n-i do C2 \ud835\udc5b \n\u2211\ud835\udc56=1(n + 1 \u2212 i) \nif T[i] > T[j] C3 \u2211\ud835\udc5b (n \u2212 i) \n\ud835\udc56=1 \nT[i] \u2194 T[j] C4 \u2211\ud835\udc5b (n \u2212 i) \n \nend \nAnalysis  end \n \n \n\ud835\udc5b  \n \n \n \n \n \ud835\udc5b \ud835\udc5b \ud835\udc56=1 \nBest  case:  \nTake  i = 1 T(n)=C1  (n+1)  + C2  \u2211\ud835\udc56=1(n + 1 \u2212 i) + C3 \u2211\ud835\udc56=1(n \u2212 i) + C4 \u2211\ud835\udc56=1(n \u2212 i) \nT(n) = C1n + C1+ C2n + C3n \u2013 C3 + C4 n \u2013 C4 \n= (C1+C2+C3+C4) n \u2212 (C2,C3,C4,C7) \n= an \u2212 b \nThus,  T(n) = \u0398(n) \nWorst Case:  \n\ud835\udc5b(\ud835\udc5b+1)  = C1n+ C1 + C2 n+ C2 \u2013C2 ( 2 \ud835\udc5b(\ud835\udc5b+1)  ) + C3n \u2013 C3 ( 2 \ud835\udc5b(\ud835\udc5b+1)  )+C4n \u2013 C4 ( ) 2 \n= [\u2013C2/n2\u2013C3/n2\u2013C4/n2] +[\u2013 C2/n\u2013C3/n\u2013C4/n]+C 1+C2+C3+C4 \n= an2+bn+c  \n \n \n   \n                                                                                                                                                              3 \n \n\ud835\udc56=1 \n\ud835\udc56=1 = \u0398 (n2) \nAverage  case:  Average  case  will be same  as worst  case  T(n) = \u0398(n2) \nExample  \nConsider  the following  numbers  are stored  in an array: \nOriginal Array: 32,51,27,85,66,23,13,57  \nPass  1 : 32,27,51,66,23,13,57,85  \nPass  2 : 27,33,51,23,13,57,66,85  \nPass  3 : 27,33,23,13,51,57,66,85  \nPass  4 : 27,23,13,33,51,57,66,85  \nPass  5 : 23,13,27,33,51,57,66,85  \nPass  6 : 13,23,27,33,51,57,66,85  \n \nSelection Sort  \n\u2022 Selection  Sort works  by repeatedly  selecting  elements.  \n\u2022 The algorithm  finds  the smallest  element  in the array  first and exchanges  it with  the element  in the first \nposition.  \nThen it  finds  the second  smallest  element  and exchanges  it with  the element  in the second  position  and continues \nin this way until the entire array is sorted.", "mimetype": "text/plain", "start_char_idx": 22416, "end_char_idx": 24456, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1595030f-423a-4445-b8c8-1226894bfacb": {"__data__": {"id_": "1595030f-423a-4445-b8c8-1226894bfacb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8c1d31e9-f3e2-4ff1-a19b-7081436bea60", "node_type": "1", "metadata": {}, "hash": "8c73fa7f3b82e8ca0deaaa3deb89ca0980321c7e7ebbe21145cbc686aaea59f3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8d7a7e88-09a3-4e59-a88c-f116e961039e", "node_type": "1", "metadata": {}, "hash": "d82fc64406dbda4ee222c12466f816e8c92959cad5a5cd69c153d189d246a6f0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 The algorithm  finds  the smallest  element  in the array  first and exchanges  it with  the element  in the first \nposition.  \nThen it  finds  the second  smallest  element  and exchanges  it with  the element  in the second  position  and continues \nin this way until the entire array is sorted.  \nAlgorithm  \n \nProcedure  select ( T [1\u2026.n] )  Cost times \nfor i\u21901 to n-1 do  C1 n \nminj \u2190 i ; minx \u2190 T[i] C2 n-1 \nfor j\u2190i+1 to n do C3 \ud835\udc5b\u22121 \n\u2211\ud835\udc56=1 (i + 1) \n \n \n \n if T[j] < minx then minj \u2190 j C4 \u2211\ud835\udc5b\u22121 i \nminx \u2190 T[j] C5 \u2211\ud835\udc5b\u22121 i \nT[minj] \u2190 T[i] C6 n-1 \nT[i] \u2190 minx C7 n-1 \n \n \n \n \n \n \n \nAnalysis  \n \n T(n)=C 1n+ C2(n-1)+ C3(\u2211\ud835\udc5b\u22121(\ud835\udc56 + 1)) + C4(\u2211\ud835\udc5b\u22121(\ud835\udc56))+C5(\u2211\ud835\udc5b\u22121(\ud835\udc56))+C6(n-1)+ C7(n-1) \n\ud835\udc56=1 = C n+ C n+ C n+ C n+ C \ud835\udc5b \ud835\udc5b \ud835\udc56=1 \n\ud835\udc5b \ud835\udc5b^2+ C \ud835\udc5b^2 \ud835\udc56=1 \n\ud835\udc5b^2 \n \n \n   \n                                                                                                                                                              4 \n \n1 2 6  \n \n7 32 1 +C4 \n2 1 + C5 \n2 1 + C3 \n2 \n2 1 4 + C5 \n2 2 1 1 -C2-C6-C7 \n=n(C 1+ C2+ C6 +C7 + C3 \n2 \n= an2+bn+c  \nTime  complexity  of insertion  sort + C4 \n2 + C5 \n2 ) + n (C3 \n2 + C4 \n2 + C5 \n2 )-1(C 2+ C6 +C7) \nBest case  Average case  Worst  case \nO(n2)  O (n2)  O (n2) \nExample:  \n \n \n \n \n \n \n \n \nInsertion Sort  \n \n\u2022 Insertion  Sort works  by inserting an  element  into its appropriate  position  during  each  iteration.  \n\u2022 Insertion  sort works  by comparing  an element  to all its previous  elements  until  an appropriate \n \n \n   \n                                                                                                                                                              5 \n \n\ud835\udc56=2 \n\ud835\udc56=2 \n\ud835\udc56=2 \ud835\udc56=2 position is found.  \n\u2022 Whenever  an appropriate position is  found, the element  is inserted  there  by shifting  down  remaining \nelements.  \nAlgorithm  \n \nProcedure  insert (T[1\u2026.n]) \nfor i \u2190 2 to n do cost \nC1 times \nn \nx \u2190 T[i] C2 n-1 \nj \u2190 i - 1 C3 n-1 \nwhile j > 0 and x < T[j] do C4 \u2211\ud835\udc5b  Tj \nT[j+1] \u2190 T[j] C5 \u2211\ud835\udc5b  Tj-1 \nj \u2190 j - 1 \nend \ud835\udc5b \n\ud835\udc56=2 Tj-1 \n \n T[j + 1] \u2190 x \nend C7 n-1 \nAnalysis  \n\u2022 The running time of an algorithm on a particular input is the number of primitive operations or \n\"steps\" executed.  \n\u2022 A constant amount of time is required to execute each line of our pseudo  code.  One line may  take a \ndifferent amount of time than another line, but we shall assume that each execution of the ith line \ntakes time c i, where c i is a constant.  \n\u2022 The running time of the algorithm is the sum of running times for each statement executed; a \nstatement that takes ci steps to execute and is executed n times will contribute cin to the total \nrunning time.  \n\u2022 Let the time  complexity  of selection  sort is given  as T(n),  then  \nT(n) = C1n+ C2(n-1)+ C3(n-1)+ C4(\u2211\ud835\udc5b \ud835\udc47j)+(C 5 +C6) \u2211\ud835\udc5b \ud835\udc47j \u2212 1+ C7(n-1).", "mimetype": "text/plain", "start_char_idx": 24157, "end_char_idx": 26907, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8d7a7e88-09a3-4e59-a88c-f116e961039e": {"__data__": {"id_": "8d7a7e88-09a3-4e59-a88c-f116e961039e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1VH3apDw2tGv_9J1zotoUdVXuLDIWh0vD", "node_type": "4", "metadata": {}, "hash": "8ff9dbb8c11901f54f6a07e9337a145381f4edb34b09c107abb1285055df9c25", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1595030f-423a-4445-b8c8-1226894bfacb", "node_type": "1", "metadata": {}, "hash": "7a557ce2927c160b6ffea321c8783aaaf017e70a5849488e3375e1dfaa438a2c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 A constant amount of time is required to execute each line of our pseudo  code.  One line may  take a \ndifferent amount of time than another line, but we shall assume that each execution of the ith line \ntakes time c i, where c i is a constant.  \n\u2022 The running time of the algorithm is the sum of running times for each statement executed; a \nstatement that takes ci steps to execute and is executed n times will contribute cin to the total \nrunning time.  \n\u2022 Let the time  complexity  of selection  sort is given  as T(n),  then  \nT(n) = C1n+ C2(n-1)+ C3(n-1)+ C4(\u2211\ud835\udc5b \ud835\udc47j)+(C 5 +C6) \u2211\ud835\udc5b \ud835\udc47j \u2212 1+ C7(n-1). C6\n \n\u2211 \n \n \n   \n                                                                                                                                                              6 \n \n\ud835\udc56= 2 \ud835\udc56= 2 Where,  \n \n \nBest  case:  \nTake  j= 1 \nT(n) = C1n + C2(n-1) + C3(n-1) + C4(n-1) + C5 (n-1)+ c7(n-1) \n= (C1+C2+C3+C4+C7) n \u2212 (C2+C3+C4+C7) \n= an \u2212 b \nThus,  T(n) = \u0398(n)  \n \nWorst  case:  Take  j =n \nT (n) = C1n+ C2(n-1)+ C3(n-1)+ C4(\u22114  \n\ud835\udc47j)+(C 5 +C6) \u22114  \n\ud835\udc47j \u2212 1+ C7(n-1). = C n+ C n+ C n+ C \ud835\udc5b \ud835\udc5b \ud835\udc5b \ud835\udc5b^2 \ud835\udc5b^2 \ud835\udc5b^2 \n1 2 3 \n2 1 1 4+C5 \n2 2 1 + C6 \n2 + C4 \n2 + C5 \n2 1 + C6 \n1 + C7n-C2-C3- C7. \n2 1 = n (C4 \n2 + C5 \n2 + C6 \n2 )+n(C 1 +C2 +C3 +C7 + C4 \n2 + C5+ C6 \n2 2 )-1(C 2 +C3 +C7). \n= an2 + bn + c . \nThus,  T(n) = \u0398(n2) \nAverage  case:  Average case will be same as worst case T(n) = \u0398(n2) \nTime complexity of insertion sort  \nBest  case  Average  case  Worst  case  \nO(n)  O (n2) O (n2) \n \n \n \n \n \nExample:  \n \n  \n \n\ud835\udc56= 2 \ud835\udc56=2 \n \n \n   \n                                                                                                                                                              7 \n \n\n \n \n   \n                                                                                                                                                              1 \n \nNext Steps  \n\u2022 Explore various Divide and conquer Strategy.  \n\u2022 Learn about  Different Algorithm with Examples . \nReferences:  \n11. Analysis of Algorithm : https://www.geeksforgeeks.org/analysis -of-algorithms/  \n12. Introduction to Algorithm: \nhttps://enos.itcollege.ee/~japoia/algorithms/GT/Introduction_to_algorithms -3rd%20Edition.pdf   \n    \n \n \n   \n                                                                                                                                                              1", "mimetype": "text/plain", "start_char_idx": 26304, "end_char_idx": 28679, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "75215201-ad11-4b0a-88bf-154b660b0716": {"__data__": {"id_": "75215201-ad11-4b0a-88bf-154b660b0716", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1DLoy0AfL96-C7zsCj5PdHQXErpLYF4cb", "node_type": "4", "metadata": {}, "hash": "a0c2ddfabfa98a4325b5d0694c5e9846dffb6d519a7f82e30d8295c7d69ce968", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "PARUL UNIVERSITY  \nFaculty of Engineering & Technology  \nDepartment of Computer Science & Engineering  \nDesign and Analysis of Algo  \nQUESTION BANK  \n1. What is an algorithm?  \n2. What is meant by open hashing?  \n3. Define \u2126 -notation  \n4. Define order of an algorithm.  \n5. Define O -notation  \n6. Define conditional big -oh notation.  \n7. What do you mean by best case efficiency?  \n8. What is meant by worst case?  \n9. Define average case efficiency.  \n10. Why space complexity of a program is necessary?  \n11. What is an algorithm design technique?  \n12. Define little -oh notation.  \n13. Compare the order of growth n! and 2!  \n14. What are the types of algorithm efficiencies?  \n15. Prove or disprove if t(n) E O(g(n))then g(n) E omega t(n)?  \n16. Give an non -recursive algorithm to find out the largest element in a list of n numbers.  \n17. What is meant by divide &conquer?  \n18. Give the recurrence relation for divide &conquer.  \n19. What is meant by greedy algorithm?  \n20. What is meant by knapsack problem?  \n21. Define fractional knapsack problem.  \n22. What is the difference between quicksort and mergesort?  \n23. Give the algorithm of quick sort.  \n24. What is binary search?  \n25. What is the average case complexity of linear search algorithm?  \n26. Define depth first searching technique.  \n27. Write the procedure for selection sort.  \n28. Differentiate dynamic programming and divide and conquer..  \n29. Give two real time problems that could be solved using greedy algorithm.  \n30. State the time complexity of bubble sort algorithm.  \n31. Define dynamic programming.  \n32. Differentiate between greedy method and dynamic programming.  \n33. Differentiate between divide and conquer and dynamic programming.  \n34. Define multistage graph.  \n35.What is meant by all pairs shortest path problem?  \n36.Write the running time of 0/1 knapsack problem.  \n37.Define optimal binary search tree.  \n38. What is meant by all pairs shortest path problem?  \n39. Give an application of dynamic programming algorithm.  \n40. Give the running time of the optimal BST algorithm.  \n41. Write recurrence relation for 0/1 knapsack problem.  \n42. Write down the floyds algorithm.  \n43. What is meant by bottom up dynamic programming?  \n44. What is meant by travelling salesperson problem?  \n45. What is the running time of dynamic programming TSP?  \n46. State if backtracking always produces optimal solution.  \n47. Define backtracking.  \n48. What are the two types of constraints used in backtracking?  \n49. What is meant by optimization problem?  \n50. Define Hamiltonian circuit problem.  \n51. What is Hamiltonian cycle in an undirected graph?  \n52. Define 8queens problem.  \n53. List out the application of backtracking.  \n54. Define promising node and non -promising node.  \n55. Give the explicit and implicit constraint for 8 -queen problem.  \n56. How can we represent the solution for 8 -queen problem?  \n57. Give the categories of the problem in backtracking.  \n58. Differentiate backtracking and over exhaustive search.  \n59. What is state space tree?  \n60. Find optimal solution for the knapsack instance n =3,w=[20,15,15],P =[40,25,25]and C =30  \nWhat is heuristics?  \n61. Explain briefly branch and bound technique for solving problems.  \n62. Differentiate between DFS and BFS.  \n63. What is travelling salesperson problem?  \n64. What is the formula used to find upper bound for knapsack problem?  \n65. Differentiate between back tracking and branch and bound.  \n66. Define articulation point.  \n67. Define spanning tree.  \n68. List out the application of branch and bound technique.  \n69. What is the assignment problem?  \n70.What is tree edge and cross edge?  \n71.Define back edge and tree edge.  \n72.What is the real time application of the assignment problem?  \n73. What is the metric used to measure the accuracy of approximation of algorithm?  \n74. What is pre -structuring ?Give examples.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3907, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e7984d62-c668-4c29-a7ca-61eb00c560ae": {"__data__": {"id_": "e7984d62-c668-4c29-a7ca-61eb00c560ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fvTkHdyCfMHyA1s-UZCVOQ3LG9L3Fbgp", "node_type": "4", "metadata": {}, "hash": "55cdd7bbb277e0cbfbe678fc659383251a96496c8de6914cd1794d027cc42391", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6d700159-07c5-4510-8ed1-6bc57142c0c1", "node_type": "1", "metadata": {}, "hash": "5efefffd1f137d8500760b2ff3965d0da3ee0e96fcf2bf0a8ecddcc374af1d90", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Page 1 \nof 3 Seat No : ______________                         Enrollment No : ________________  \nPARUL UNIVERSITY  \nFACULTY OF ENGINEERING & TECHNOLOGY  \nB.Tech /Int. BTech  Winter 2024 -25 Examination  \nSemester:  5th/9th        Date : 11/11/2024 \nSubject Code : 303105218        Time : 02:00 pm to 4:30 pm \nSubject  Name : Design and Analysis of Algorithms     Total Marks : 60 \n \nInstructions :  \n1. This question paper comprises of two sections . Write answer of both the sections in separate answer books . \n2. From Section I, Q.1 is compulsory, attempt any THREE from Q . 2 to Q. 5 \n3. From Section II, Q.6 is compulsory, attempt any THREE from Q . 7 to Q . 10 \n4. Make suitable assumptions wherever necessary . \n5. Start new question on new page . \nSection -A (30 Marks ) \nQ.1 Objective Type Questions  -  \n(All are compulsory and each of two marks ) (6) C\nO PO Bloom \u2019s \nTaxonomy  \n 1. What  is Theta notation?   1 1   \nRemember  \n 2. Define  recursion in algorithms .  1 1     \nRemember  \n 3. Define  divide and conquer .  1 1     \nRemember  \nQ.2 Answer the following questions .      \n A) Find out the time complexity of  given code . \nint fun (int n) \n{  int count = 0; \n  for (int i = n; i > 0; i /= 2) \n     for (int j = 0; j < i; j ++) \n        count += 1; \n  return count;   }  (2) 1 2     \nUnderstan\nding  \n B) Let T (n) be the recurrence relation defined as follows : \nT(0) = 1,T(1) = 2, and T (n) = 5T (n - 1) - 6T (n - 2) for n \u2265 2 \nFind out time complexity . (3) 1 2     \nUnderstan\nding  \n C) Find Out Time complexity of given equation . \n                   T(n) = 3T(n/2)+n^2 (3) 1 2     \nUnderstan\nding  \nQ.3 Answer the following questions .      \n A) Discuss  Greedy algorithms and dynamic programming with \nexamples . (4) 2 3     \nUnderstan\nding  \n B) Discuss  the advantages of greedy algorithms over dynamic \nprogramming in specific cases . (4) 2 3     \nUnderstan\nding  \nQ.4 Answer the following questions .      \n A) Define MST, if there are 4 vertex and 5 edges in a graph then how \nmany MST are possible?  (2) 3 2     Applying  \n B) Explain Prim \u2019s algorithm for finding the Minimum Spanning Tree \n(MST ) of a graph . Also Describe the steps involved in Prim \u2019s algorithm . (3) 2 2    \nUnderstan\nding  \n   Page 2 \nof 3  C)Construct the minimum spanning tree (MST ) for the given graph using \nKruskal \u2019s Algorithm  \n                       (3) 3 2 Applying  \nQ.5 Answer the following questions .      \n A) Explain Strassen \u2019s algorithm for matrix multiplication and how \nit improves the efficiency compared to the conventional method . (6) 2 1      \nUnderstan\nding  \n B) What are the advantages and limitations of Strassen \u2019s algorithm?  (2) 2 1      \nUnderstan\nding  \nSection -B (30 Marks ) \nQ.6 Objective Type Questions  - \n(All are compulsory and each of two marks ) (6)    \n 1. Define  DFS (Depth First Search ).  1 1     \nRemember  \n 2. What  is the time complexity of bubble sort in every case?   1 1     \nRemember  \n 3. Define  the concept of backtracking .  1 1     \nRemember  \nQ.7 Answer the following questions .      \n A) Let A1, A2, A3, and A4 be four matrices of dimensions 10 x 15, \n15 x 2, 2 x 3, and 3 x 5, respectively .", "mimetype": "text/plain", "start_char_idx": 3, "end_char_idx": 3167, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6d700159-07c5-4510-8ed1-6bc57142c0c1": {"__data__": {"id_": "6d700159-07c5-4510-8ed1-6bc57142c0c1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fvTkHdyCfMHyA1s-UZCVOQ3LG9L3Fbgp", "node_type": "4", "metadata": {}, "hash": "55cdd7bbb277e0cbfbe678fc659383251a96496c8de6914cd1794d027cc42391", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7984d62-c668-4c29-a7ca-61eb00c560ae", "node_type": "1", "metadata": {}, "hash": "e70f3f71783dbdca6ba168c30864791f39d7dcd5946e6a05f549350d36d7188f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "(6) 2 1      \nUnderstan\nding  \n B) What are the advantages and limitations of Strassen \u2019s algorithm?  (2) 2 1      \nUnderstan\nding  \nSection -B (30 Marks ) \nQ.6 Objective Type Questions  - \n(All are compulsory and each of two marks ) (6)    \n 1. Define  DFS (Depth First Search ).  1 1     \nRemember  \n 2. What  is the time complexity of bubble sort in every case?   1 1     \nRemember  \n 3. Define  the concept of backtracking .  1 1     \nRemember  \nQ.7 Answer the following questions .      \n A) Let A1, A2, A3, and A4 be four matrices of dimensions 10 x 15, \n15 x 2, 2 x 3, and 3 x 5, respectively . The minimum number of scalar \nmultiplications required to find the product A1A2A3A4 using the basic \nmatrix multiplication method  (4) 2 3     \nUnderstan\nding  \n B) Consider two strings \ud835\udc34 =\"qppqrr\" and \ud835\udc35 =\"pqpprqrp \". What is \nlength of LCS (longest common subsequence )? And how many strings \nare possible of max length?   (4) 2 3    \nUnderstan\nding  \nQ.8 Answer the following questions .      \n A) Let in a file the frequesncy of letters i, n, d, e,x are 16,7,17,25,20 \nrespectively .What are the huffman's code of each letter?  (4) 2 2    \nUnderstan\nding  \n B) Apply Quick sort algorithm and write Recurrence relation of \nquicksort on given numbers . \n                                     2, 7, 3, 9, 1, 6, 8, 4 (4) 2 2 Understan\nding  \nQ.9 Answer the following questions .      \n A) Consider the following graph and write BFS , DFS \ntraversal (Consider 0 as root node ). \n          (3) 4 2,3 Analyzing  \n B) Consider the  following directed weighted graph - (5) 4 2 Analyzing  \n\n   Page 3 \nof 3                     \nUsing Floyd Warshall Algorithm, find the shortest path distance between \nevery pair of vertices . \nQ.10 Answer the following questions .      \n A) How many queens are possible on 5 *5 chess board and how ways \nare possible to place max queens on chess board?  (3) 4 1 Analyzing  \n B) Suppose T = 1011101110, P = 111  Find all the Valid Shift  Using \nThe Naive String Matching Algorithm  (3) 4 1 Analyzing  \n C) Differentiate NP hard and NP complete problems . (2) 5 1 Evaluating", "mimetype": "text/plain", "start_char_idx": 2566, "end_char_idx": 4666, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4b7e3973-523f-48d8-a8cb-d0316c5a468c": {"__data__": {"id_": "4b7e3973-523f-48d8-a8cb-d0316c5a468c", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1_S2NDuSdATGgkSztCXjSbV1ISkRtfr0L", "node_type": "4", "metadata": {}, "hash": "351fe4e5b3084975dbe89977c7ce2792b6a5fa032efd5215b630ce41cb2416fa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "01bbab79-dcbd-416a-b6a6-df14d812c9c4", "node_type": "1", "metadata": {}, "hash": "226ab24d9c91805a0f928a4cc891a39fbc274d72e0814255f47436f5e21d04b5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Page 1 of 3 Seat No: ______________                                Enrollment No: _________  \nPARUL UNIVERSITY  \nFACULTY OF ENGINEERING & TECHNOLOGY  \nB. Tech / Int. B.  Tech Summer  2024 - 25 Examination  \n \nSemester: 5/9                Date: 28/04/2025  \nSubject Cod e:  303105218               Time: 10:30am to 1 :00pm  \nSubject Name: Design and Analysis of Algorithm            Total Marks: 60  \n \nInstructions:   \n1. This question paper comprises of two section s. Write answer of both the section s in separate answer book s. \n2. From Section A, Q.1 is compulsory , From Section B , Q.1 is compulsory . \n3. Figures to the right indicate full marks.  \n4. Draw neat and clean drawings & Make suitable assumptions wherever necessary.  \n5. Start new question on new page.  \n6.BT- Blooms Taxonomy Levels \u2013 Remember -1, Under stand -2,Apply -3, Analyse -4,Evaluate -5, Create -6 \n \n \nSECTION -A Marks  CO BT \nQ.1 Answer the following questions.     \n A. Write appropriate answer only.      \n i. What technique do es the Rabin -Karp algorithm use for string matching?    [01] 4 1 \n ii. What is the main difference between BFS and DFS?   [01] 3 1 \n iii. The Travelling Salesman Problem (TSP) is classified under which \ncomplexity class?   [01] 5 2 \n iv. Which data structure is used in Kru shkal\u2019s algorithm for finding the \nMinimum Spanning Tree?   [01] 2 2 \n v. In a divide -and-conquer algorithm, the recurrence relation \nT(n)=2T(n/2)+O(n) represents the time complexity of which algorithm?   [01] 1 3 \n vi. Which data structure is commonly used in the Br anch and Bound algorithm \nto store nodes?   [01] 2 2 \n a. Answer the following questions.      \n i. Explain the difference between a directed and an undirected graph.   [02] 3 2 \n ii. Compare dynamic programming and divide -and-conquer approaches.   [02] 2 4 \n iii. Differenti ate between the three cases of the Master theorem.   [02] 1 4 \nQ.2 a) Apply the Rabin -Karp algorithm  to find all occurrences of the pattern \nABC  in the text ABCDABCABC using Base=101 and Modulus=13.   [04] 4 3 \n b) A thief  breaks into a house intending to steal val uable items . He carries a \nbag that can hold a maximum weight of 60 kg . Inside the house, there are 5 \nitems , each with a specific weight and value . What items should thief take \nif he can even take the fraction of any item with him? Given the following \ndetai ls: \nItem Weight (kg)  Value($)  \n1 10 60 \n2 20 100 \n3 30 120 \n4 15 90 \n5 25 75 \n  [05] 2 5 \n OR     \n b) Show the result of applying Algorithm Matrix -Chain -Multiplication to \nfind the minimum number of scalar multiplication required to compute the  [05] 2 5 \n   Page 2 of 3 product of the  following five matrices: M1 : 5 \u00d7 10, M2 : 10 \u00d7 4, M3 : 4 \u00d7 6, \nM4 : 6 \u00d7 10, M5 : 10 \u00d7 2.   \n \nQ.3 a) Design and discuss the relationships between the four complexity classes. \nProve that NP = P if and only if for some NP -complete problem X, X \u2208 P.  [04] 5 2 \n b) Suppose we run Dijkstra\u2019s single source shortest -path algorithm on the \nfollowing edge weighted directed graph with vertex P as the source. In what \norder do the nodes get included into the set of vertices for which the shortest \npath distances are f inalized?                                      \n  [05] 3 5 \n OR     \n b) What do you mean by spanning tree of a graph? Find the minimum spanning \ntree of the following graph using suitable algorithm which grows multiple \ntrees (i.e., a forest) at the same time a nd trees are merged together using safe \nedges.", "mimetype": "text/plain", "start_char_idx": 3, "end_char_idx": 3492, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "01bbab79-dcbd-416a-b6a6-df14d812c9c4": {"__data__": {"id_": "01bbab79-dcbd-416a-b6a6-df14d812c9c4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1_S2NDuSdATGgkSztCXjSbV1ISkRtfr0L", "node_type": "4", "metadata": {}, "hash": "351fe4e5b3084975dbe89977c7ce2792b6a5fa032efd5215b630ce41cb2416fa", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4b7e3973-523f-48d8-a8cb-d0316c5a468c", "node_type": "1", "metadata": {}, "hash": "79144008126cbcbd7a850202c4e7846178c5c087d64af7132dc63265174071ec", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q.3 a) Design and discuss the relationships between the four complexity classes. \nProve that NP = P if and only if for some NP -complete problem X, X \u2208 P.  [04] 5 2 \n b) Suppose we run Dijkstra\u2019s single source shortest -path algorithm on the \nfollowing edge weighted directed graph with vertex P as the source. In what \norder do the nodes get included into the set of vertices for which the shortest \npath distances are f inalized?                                      \n  [05] 3 5 \n OR     \n b) What do you mean by spanning tree of a graph? Find the minimum spanning \ntree of the following graph using suitable algorithm which grows multiple \ntrees (i.e., a forest) at the same time a nd trees are merged together using safe \nedges.  \n  [05] 3 5 \n   Page 3 of 3  \nSECTION -B    \nQ.1 Answer the following questions.     \n i. Explain the three  steps for proving correctness using the loop invariant technique.  [02] 1 1 \n ii. Why is the time complexity of Bubble Sort O(n2)? [02] 1 2 \n iii. Explain why Strassen\u2019s algorithm is more efficient than the standard matrix \nmultiplication algorithm for large matrice s. [02] 2 2 \n iv. What is the primary advantage of Merge Sort over Quick Sort?  [02] 1 2 \n v. Explain why the statement, \u201cThe running time of algorithm A is at least O (n2),\u201d is \nmeaningless.  [02] 1 3 \n vi. Design an algorithm using the Divide and Conquer approach to find both the \nmaximum and minimum elements in a given array . [02] 2 3 \n      \nQ.2 a) Define the binary search and describe its basic concept. Demonstrate the \nalgorithm with an example by performing binary search on a sorted array.   [04] 2 2 \n b) Explain the Prin ciple of Optimality  in Dynamic Programming  and discuss \nhow it differs from the Greedy Choice Property  in Greedy Algorithms . \nIllustrate the difference with suitable examples.   [05] 2 2 \n OR     \n b)  Explain the Activity Selection Problem  and how it can be sol ved using a \nGreedy Algorithm . You are given a list of activities with their start  and \nfinish times . You need to select the maximum number of activities  that can \nbe performed by a single person  without any overlap.  \n \nActivity  Start \nTime  Finish \nTime  \nA1 1 3 \nA2 2 5 \nA3 4 6 \nA4 6 8 \nA5 5 7 \nA6 8 9 \n  [05] 2 5 \nQ.3 a) How Dynamic Programming is different from Recursion and Memoization? \nIllustrate use of Memoization for finding Nth Fibonacci number?  \n  [04] 2 2 \n b) Describe the step -by-step procedure of the Merge Sort algorithm, including \nhow it follows the divide -and-conquer approach. Discuss the time and space \ncomplexity of Merge Sort algorithm in the best, worst, and average cases.   [05] 1 3 \n OR     \n b) Solve given recurrence relation using recursion tree method.  \n T(n) = T(n/4) + T(n/2) + c n2  [05] 1 4", "mimetype": "text/plain", "start_char_idx": 2760, "end_char_idx": 5513, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bcf697f9-d514-4cc8-8ac0-22181326e37e": {"__data__": {"id_": "bcf697f9-d514-4cc8-8ac0-22181326e37e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24c60fb8-d91e-4f8c-8a7a-4e39a8edbfc6", "node_type": "1", "metadata": {}, "hash": "65e5215231545ea417609c99bbb66461c3ea98ca19016978b6393157bd41f3a4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Artificial Intelligence\n\n1.Artificial Intelligence :A\nNew Synthesis, Harcourt\nPublishers (TextBook )By\nN.J.Nilsson |Harcourt\nPublishersBooks\n2.Artificial Intelligence\n(TextBook )By Elaine\nRich and Kevin Knight |\nTMH3.Artificial Intelligence -\nStructures and Strategies\nFor Complex Problem\nSolving ByGeorge F.Luger |\nPearson Education /PHI\n\n4.Artificial Intelligence -AModern\nApproach ByStewart Russell and\nPeter Norvig |Pearson Education/\nPrentice Hall ofIndia |2\n5.Artificial Intelligence \u2013A\nPractical Approach ByPatterson |\nTata McGraw Hill|3\nBooks\nIntroduction of Artificial Intelligence CHAPTER -1\n\nArtificial Intelligence\n\u201cArtificial Intelligence (AI) isthe field ofcomputer science that\naims tocreate systems that can perform tasks that typically\nrequire human intelligence, such aslearning, problem -solving,\ndecision -making, and perception .AIsystems utilize advanced\nalgorithms and techniques tomimic human cognitive abilities .\u201d\nWhat is Intelligence??\n\u2022According todictionary .com, \u201cthe capacity, forlearning, reasoning,\nunderstanding, and similar forms ofmental activity .\u201d.\n\u2022Intelligence =Knowledge +Search strategy forexploring KBto\ndraw useful conclusions .\n\u2022Thus, inAIour objective istosimulate KB and the search\nstrategies incomputers sothat they canbehave inaway similar to\nthehumans .\nExample of Intelligence\n\u2022How athree year oldchild learns with it\u2019s\nsurrounding and experience them, finally\nuses those perceptions intelligently with\nacquired knowledge .e.g.:Giving you a\ncassette, orasking toplay aparticular track\nmentioned onCD,Using electronic gadgets\nwithout theability ofreading and writing, or\nmoreover asking you intelligently toplay his\nfavorite cartoon channel .\n\nDefinition of Artificial Intelligence\n\u2022Definition based on two dimension\n1.Upper dimension concerned with \u201c Thought Processes\u201d & \nReasoning.\n2.Lower dimensions incorporating \u201c Behaviour \u201din m/c to make \nthem intelligent like humans.\n(A) Definitions Based on success in terms of fidelity to\nhuman performance\n(i) Systems that think humanly   (ii) Act Humanly\n(B) Definitions based on Rationality\n(i) Systems that think Rationally    (ii) Act Rationally\nActing H umanly: The Turing Test Approach\n\u2022The study ofhow tomake computers dothing atwhich, atthe\nmoment, people arebetter\u201d( Rich+ Knight, 1991 )\n\u2022NLP-Tocommunicate successfully inhuman language .\n\u2022Knowledge Representation -Toanswer questions and draw new\nconclusion .\n\u2022Automated Reasoning -To answer questions and draw new\nconclusion .\n\u2022Machine Learning -Toadapt tonew circumstances and todetect\nextrapolate patterns .\n\u2022Computer Vision :&speech recognition toperceive theworld .\n\u2022Robotics :Tomanipulate objects &move about .\nActing H umanly: The Turing Test Approach\n\u2022The Turing (1950) \"Computing machinery and \nintelligence\":\n\u2022Operational test for intelligent behavior: the \nImitation Game\n\u2022\"Can machines think?\" ,\"Can machines \nbehave intelligently?\"\n\u2022Predicted that by2000 ,amachine might have a30%chance of\nfooling alayperson for5minutes\n\u2022Suggested major components ofAI:knowledge, reasoning, language\nunderstanding, learning .\nContd \u2026\n\u2022Total Turing Test :\n\u2022Turing viewed thephysical simulation ofaperson asunnecessary\ntodemonstrate patterns .\n\u2022However researchers have proposed total Turing Test, which\nrequires interaction with objects and people inthereal world .\n\u2022Topass theTotal Turing Test, arobot will need computer vision,\nrobotics .\nThinking Humanly: The Cognitive Modeling Approach\n\u2022Human think inthree ways :\n1.Introspection :Trying tocatch our own\nthought asthey goby;\n2.Psychological experiments :Observing a\nperson inaction\n3.Brain imaging :observing the brain in\naction .\n\u2022Cognitive Science :Cognitive science brings\ntogether computer models from AIand\nexperimental techniques from psychology to\nconstruct precise and testable theories ofthe\nhuman mind .\n\nThinking Rationally: The \u201cLaw of Thought\u201d Approach\n\u2022 Aristotle: What are correct arguments/thought processes?\n\u2022 Several Greek schools developed various forms of logic:\nnotation and rules of derivation for thoughts; may or may not \nhave proceeded to the idea of mechanization.\n\u2022 Direct line through mathematics and philosophy to modern AI\nProblems: \n1. Not all intelligent behavior is mediated by logical deliberation\n2. What is the purpose of thinking? What thoughts should I \nhave?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4305, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "24c60fb8-d91e-4f8c-8a7a-4e39a8edbfc6": {"__data__": {"id_": "24c60fb8-d91e-4f8c-8a7a-4e39a8edbfc6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bcf697f9-d514-4cc8-8ac0-22181326e37e", "node_type": "1", "metadata": {}, "hash": "e7105be957517a4f6998f3396523ac6c7c68b62b26d3a28b02088d992cb9a6e4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d85977d6-6f3a-410e-a5bc-6cb60183cdb9", "node_type": "1", "metadata": {}, "hash": "a9f1cebf2f76600b511c51f573e3f0a8c73b6505aa50e21fcead6aa506cd079e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Thinking Humanly: The Cognitive Modeling Approach\n\u2022Human think inthree ways :\n1.Introspection :Trying tocatch our own\nthought asthey goby;\n2.Psychological experiments :Observing a\nperson inaction\n3.Brain imaging :observing the brain in\naction .\n\u2022Cognitive Science :Cognitive science brings\ntogether computer models from AIand\nexperimental techniques from psychology to\nconstruct precise and testable theories ofthe\nhuman mind .\n\nThinking Rationally: The \u201cLaw of Thought\u201d Approach\n\u2022 Aristotle: What are correct arguments/thought processes?\n\u2022 Several Greek schools developed various forms of logic:\nnotation and rules of derivation for thoughts; may or may not \nhave proceeded to the idea of mechanization.\n\u2022 Direct line through mathematics and philosophy to modern AI\nProblems: \n1. Not all intelligent behavior is mediated by logical deliberation\n2. What is the purpose of thinking? What thoughts should I \nhave?\nActing Rationally: The Rational Agent Approach\n\u2022Agent :AnAgent isjust something that acts.e.g.,computer\nprogram, human\n\u2022Rational Agent :\n\u2713Rational Agent isone that actsoastoachieve thebest outcome\nor,when there isuncertainty thebest expected outcome .\n\u2713AIfocuses onthe study &construction ofagents that \u201cdothe\nright things\u201d .\n\u2022\u201cLaw ofthought\u201d :correct inference toachieve rationality .\nMajor Areas of Artificial Intelligence\n\nArtificial Intelligence Techniques\nFigure: Flow chart of AI computing\nTechniques of Artificial Intelligence\nArtificial \nIntelligenceMachine \nLearnin\ngNatural \nLanguag\ne \nProcessi\nng\nDeep \nLearnin\ng\nComput\ner \nVision\nRobotic\nsData \nScienceReinforc\nement \nLearnin\ngExpert \nSystem\nTechniques of Artificial Intelligence\nDeep Learning\n\u2022Definition : A subset of \nmachine learning involving \nneural networks with \nmany layers.\n\u2022Components : Neurons, \nlayers, backpropagation.\n\u2022Applications :\nAutonomous vehicles, \nnatural language \nprocessing, game playing.Natural Language Processing (NLP)\n\u2022Definition :The ability of a computer \nprogram to understand human \nlanguage as it is spoken.\n\u2022Key Tasks :\n\u2022Text analysis\n\u2022Machine translation\n\u2022Sentiment analysis\n\u2022Applications :Virtual assistants, \nchatbots, language translation \nservices.\nTechniques of Artificial Intelligence\nComputer Vision\n\u2022Definition : The field of AI that \ntrains computers to interpret \nand understand the visual world.\n\u2022Key Techniques :\n\u2022Image classification\n\u2022Object detection\n\u2022Image generation\n\u2022Applications :Facial recognition, \nmedical imaging, autonomous \ndriving.Robotics\n\u2022Definition :The branch of AI that \ninvolves the design, construction, \noperation, and use of robots.\n\u2022Components :\n\u2022Sensors\n\u2022Actuators\n\u2022Control systems\n\u2022Applications : Manufacturing \nautomation, surgical robots, \ndrone technology.\nTechniques of Artificial Intelligence\nExpert Systems\n\u2022Definition : AI systems that \nuse reasoning capabilities to \nreach a conclusion.\n\u2022Components :\n\u2022Knowledge base\n\u2022Inference engine\n\u2022Applications : Diagnostic \nsystems, financial analysis, \nprocess control systems.\u2022Machine Learning\n\u2022Definition :A subset of AI that \nenables machines to learn from data \nand improve from experience.\n\u2022Types :\n\u2022Supervised Learning\n\u2022Unsupervised Learning\n\u2022Reinforcement Learning\n\u2022Applications :Image recognition, \nspeech recognition, medical \ndiagnosis.\nTechniques of Artificial Intelligence\nData Science\n\u2022Definition :Data Science involves using \nscientific methods, processes, \nalgorithms, and systems to extract \nknowledge and insights from structured \nand unstructured data.\n\u2022Key Features :\n\u2022Data Mining\n\u2022Predictive Analytics\n\u2022Data Visualization\n\u2022Data Cleaning\n\u2022Applications: Healthcare, Finance, \nMarketing, Retail, Sports.Reinforcement Learning\n\u2022Definition :Reinforcement Learning\n(RL) isatype ofmachine learning\nwhere an agent learns tomake\ndecisions byperforming actions inan\nenvironment tomaximize cumulative\nreward .Components :\n\u2022Agent\n\u2022Environment\n\u2022Actions\n\u2022Rewards Policy\n\u2022Applications : Gaming Robotics, \nAutonomous Vehicle, Health care.\nHistory of Artificial Intelligence\nArtificial Intelligence (AI) has arich and fascinating history, tracing itsroots\nback tothe mid-20thcentury .From the early pioneers who laid the\nfoundations tothe rapid advancements inrecent decades, AIhas come a\nlong way initsquest toemulate and enhance human intelligence .\nHistory of Artificial Intelligence\n1943 McCulloch & Pitts: Boolean circuit model of brain\n1950 Turing's \"Computing Machinery and Intelligence\"\n1956 Dartmouth meeting: \"Artificial Intelligence\" adopted\n1952 \u201469 Look , no hands!", "mimetype": "text/plain", "start_char_idx": 3394, "end_char_idx": 7871, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d85977d6-6f3a-410e-a5bc-6cb60183cdb9": {"__data__": {"id_": "d85977d6-6f3a-410e-a5bc-6cb60183cdb9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24c60fb8-d91e-4f8c-8a7a-4e39a8edbfc6", "node_type": "1", "metadata": {}, "hash": "65e5215231545ea417609c99bbb66461c3ea98ca19016978b6393157bd41f3a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2b514464-b8ce-474a-9147-ce94d4aa5301", "node_type": "1", "metadata": {}, "hash": "07aea5000aa6e3dc082c622a5c88e9caa0e6f1d3e1ef2d5278e488b99897b2c6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "History of Artificial Intelligence\nArtificial Intelligence (AI) has arich and fascinating history, tracing itsroots\nback tothe mid-20thcentury .From the early pioneers who laid the\nfoundations tothe rapid advancements inrecent decades, AIhas come a\nlong way initsquest toemulate and enhance human intelligence .\nHistory of Artificial Intelligence\n1943 McCulloch & Pitts: Boolean circuit model of brain\n1950 Turing's \"Computing Machinery and Intelligence\"\n1956 Dartmouth meeting: \"Artificial Intelligence\" adopted\n1952 \u201469 Look , no hands!\n1950s Early AI programs, including Samuel's checkers program, Newell & Simon's \nLogic Theorist, Gelernter's Geometry Engine\n1965 Robinson's complete algorithm for logical reasoning\n1966 \u201473 AI discovers computational complexity Neural network research almost \ndisappears\n1969 \u201479 Early development of knowledge -based systems\n1980 --AI becomes an industry\n1986 --Neural networks return to popularity\n1987 --AI becomes a science\n1995 --The emergence of intelligent agents, genetic algorithms \nHistory of Artificial Intelligence\nEarly Pioneers of AI:\nAlan Turing\nConsidered thefather of\ncomputer science,\nTuring's seminal work on\nthe Turing machine and\nthe Turing test laid the\ngroundwork forthefield\nofAI.John McCarthy\nCredited with coining the\nterm \"Artificial\nIntelligence\" in 1956 ,\nMcCarthy was akeyfigure\ninthe field, pioneering\nwork in logic -based\napproaches toAI.Marvin Minsky\nAco-founder ofthe\nMIT AIlab, Minsky\nmade significant\ncontributions to the\nfield, including work\non neural networks\nand the theory of\nintelligence .\n1.ALVINN :\nAutonomous Land Vehicle InaNeural Network\nIn1989 ,Dean Pomerleau atCMU created ALVINN .This isasystem\nwhich learns tocontrol vehicles bywatching aperson drive\n2.Deep Blue :\nIn1997 ,the Deep Blue chess program created byIBM, beat the\ncurrent world chess champion, Gary Kasparov .\n3.Machine translation :\nAsystem capable oftranslations between people speaking different\nlanguages will bearemarkable achievement ofenormous economic\nand cultural benefitHistory of Artificial Intelligence\n4.Autonomous agents :\nInspace exploration, robotic space probes autonomously monitor\ntheir surroundings, make decisions and acttoachieve their goals .\n5.Internet agents :\nThe explosive growth oftheinternet hasalso ledtogrowing interest\nininternet agents tomonitor users' tasks, seek needed information,\nand tolearn which information ismost usefulHistory ofArtificial Intelligence\nArtificial Intelligence Problem\n\n\u2022 Understand natural language robustly (e.g., read and understand \narticles in a newspaper)\n\u2022 Surf the web\n\u2022 Interpret an arbitrary visual scene\n\u2022 Learn a natural language\n\u2022 Construct plans in dynamic real -time domains\n\u2022 Exhibit true autonomy and intelligenceArtificial Intelligence Problem\nAgent\n\u2022What is an agent ?\n\u26abAn agent is anything that  perceiving its \nenvironment through sensors and \nacting upon that environment through \nactuators\n\u26abExample: \n\u2022Human is an agent\n\u2022A robot is also an agent with cameras and \nmotors\n\u2022A thermostat detecting room temperature. \n\nDiagram of Agent\nWhat AI should fill \nContd\u2026\nSimple Terms\nPercept\n\u26abAgent\u2019s perceptual inputs at any given instant\nPercept sequence\n\u26abComplete history of everything that the agent has ever perceive\n\u2022Agent function & program\n\u2022Agent\u2019s behavior is mathematically described by\n\u26abAgent function\n\u26abA function mapping any given percept sequence to \nan action\n\u2022Practically it is described by \n\u26abAn agent program\n\u26abThe real implementation\nVacuum -cleaner world\nPerception: Clean or Dirty? \nwhere it is in?\nActions: Move left, Move \nright, suck, do nothing\n\nVacuum -cleaner world\nProgram implements the agent function \ntabulated in Fig. 2.3\nFunction Reflex -Vacuum -\nAgent([ location,status ])  return an action\nIfstatus =  Dirty then return Suck\nelse if location = A then return Right\nelse if location = B then return left\nConcept of Rationality\nRational agent\n\u26abOne that does the right thing\n\u26ab= every entry in the table for the agent function is \ncorrect (rational).\nWhat is correct?\n\u26abThe actions that cause the agent to be most \nsuccessful\n\u26abSo we need ways to measure success.\nPerformance measure\nPerformance measure\n\u26abAn objective function that determines\n\u26abHow the agent does successfully\n\u26abE.g., 90% or 30% ?", "mimetype": "text/plain", "start_char_idx": 7333, "end_char_idx": 11574, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2b514464-b8ce-474a-9147-ce94d4aa5301": {"__data__": {"id_": "2b514464-b8ce-474a-9147-ce94d4aa5301", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d85977d6-6f3a-410e-a5bc-6cb60183cdb9", "node_type": "1", "metadata": {}, "hash": "a9f1cebf2f76600b511c51f573e3f0a8c73b6505aa50e21fcead6aa506cd079e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "edfc7015-bc4c-440f-91c4-ad69148e5daf", "node_type": "1", "metadata": {}, "hash": "01eefb09394b09ff884a9721512dc51850f7b8722c97ad773fb3233cdbea0a2b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "where it is in?\nActions: Move left, Move \nright, suck, do nothing\n\nVacuum -cleaner world\nProgram implements the agent function \ntabulated in Fig. 2.3\nFunction Reflex -Vacuum -\nAgent([ location,status ])  return an action\nIfstatus =  Dirty then return Suck\nelse if location = A then return Right\nelse if location = B then return left\nConcept of Rationality\nRational agent\n\u26abOne that does the right thing\n\u26ab= every entry in the table for the agent function is \ncorrect (rational).\nWhat is correct?\n\u26abThe actions that cause the agent to be most \nsuccessful\n\u26abSo we need ways to measure success.\nPerformance measure\nPerformance measure\n\u26abAn objective function that determines\n\u26abHow the agent does successfully\n\u26abE.g., 90% or 30% ?\nAn agent, based on its percepts\n\u26ab\naction sequence :\nif desirable, it is said to be performing well.\n\u26abNo universal performance measure for all agents\nPerformance measure\nA general rule:\n\u26abDesign performance measures according to\n\u26abWhat one actually wants in the environment\n\u26abRather than how one thinks the agent should behave\nE.g., in vacuum -cleaner world\n\u26abWe want the floor clean, no matter how the agent \nbehave\n\u26abWe don\u2019t restrict how the agent behaves\nRationality\nWhat is rational at any given time depends on \nfour things:\n\u26abThe performance measure defining the criterion of \nsuccess\n\u26abThe agent\u2019s prior knowledge of the environment\n\u26abThe actions that the agent can perform\n\u26abThe agents\u2019s percept sequence up to now\nRational Agent\nFor each possible percept sequence, \n\u26aban rational agent should select \n\u26aban action expected to maximize its performance \nmeasure, given the evidence provided by the percept \nsequence and whatever built -in knowledge the agent \nhas\nE.g., an exam\n\u26abMaximize marks, based on \nthe questions on the paper & your knowledge\nExample of Rational Agent\nActions that can perform\n\u26abLeft, Right, Suck and NoOp\nPercept sequences\n\u26abWhere is the agent?\n\u26abWhether the location contains dirt?\nUnder this circumstance, the agent is rational.\nOmniscience\nAn omniscient agent\n\u26abKnows the actual outcome of its actions in advance\n\u26abNo other possible outcomes\n\u26abHowever, impossible in real world\nAn example\n\u26abcrossing a street but died of the fallen cargo door \nfrom 33,000ft \n irrational? \nOmniscience\nBased on the circumstance, it is rational.\nAs rationality maximizes\n\u26abExpected performance\nPerfection maximizes\n\u26abActual performance\nHence rational agents are not omniscient .\nLearning\nDoes a rational agent depend on only current \npercept?\n\u26abNo, the past percept sequence should also be used\n\u26abThis is called learning\n\u26abAfter experiencing an episode, the agent \n\u26abshould adjust its behaviors  to perform better for the \nsame job next time.\nLearning\nDoes a rational agent depend on only current \npercept?\n\u26abNo, the past percept sequence should also be used\n\u26abThis is called learning\n\u26abAfter experiencing an episode, the agent \n\u26abshould adjust its behaviors  to perform better for the \nsame job next time.\nAutonomy\nIf an agent just relies on the prior knowledge of its \ndesigner rather than its own percepts then the agent \nlacks autonomy\nA rational agent should be autonomous -it should learn \nwhat it can to compensate for partial or incorrect prior \nknowledge.\nE.g., a clock\n\u26abNo input (percepts)\n\u26abRun only but its own algorithm (prior knowledge)\n\u26abNo learning, no experience, etc.\nSoftware Agents\nSometimes, the environment may not be the \nreal world\n\u26abE.g., flight simulator, video games, Internet\n\u26abThey are all artificial but very complex environments\n\u26abThose agents working in these environments are \ncalled\n\u26abSoftware agent ( softbots )\n\u26abBecause all parts of the agent are software\nTask environments\nTask environments arethe\nproblems\n\u26abWhile the rational agents are the\nsolutions\nSpecifying thetask environment\n\u26abPEAS description asfully aspossible\nIndesigning anagent, thefirst step must always be\ntospecify thetask environment asfully aspossible .\nUse automated taxi driver asan\nexamplePerformance Environment\nActuators Sensors\nTask environments\nPerformance measure\n\u26abHow can we judge the automated driver?", "mimetype": "text/plain", "start_char_idx": 10855, "end_char_idx": 14871, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "edfc7015-bc4c-440f-91c4-ad69148e5daf": {"__data__": {"id_": "edfc7015-bc4c-440f-91c4-ad69148e5daf", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2b514464-b8ce-474a-9147-ce94d4aa5301", "node_type": "1", "metadata": {}, "hash": "07aea5000aa6e3dc082c622a5c88e9caa0e6f1d3e1ef2d5278e488b99897b2c6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ef3ac94b-69df-4b1b-a820-0f7b82cf71c0", "node_type": "1", "metadata": {}, "hash": "ca6b5fb71eda69901adb8e936a6ddeeeffc64645dc91ec1037ef379329d8d871", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Software Agents\nSometimes, the environment may not be the \nreal world\n\u26abE.g., flight simulator, video games, Internet\n\u26abThey are all artificial but very complex environments\n\u26abThose agents working in these environments are \ncalled\n\u26abSoftware agent ( softbots )\n\u26abBecause all parts of the agent are software\nTask environments\nTask environments arethe\nproblems\n\u26abWhile the rational agents are the\nsolutions\nSpecifying thetask environment\n\u26abPEAS description asfully aspossible\nIndesigning anagent, thefirst step must always be\ntospecify thetask environment asfully aspossible .\nUse automated taxi driver asan\nexamplePerformance Environment\nActuators Sensors\nTask environments\nPerformance measure\n\u26abHow can we judge the automated driver?\n\u26abWhich factors are considered?\n\u26abgetting to the correct destination\n\u26abminimizing fuel consumption\n\u26abminimizing the trip time and/or cost\n\u26abminimizing the violations of traffic laws\n\u26abmaximizing the safety and comfort, etc.\nTask environments\nEnvironment\n\u26abA taxi must deal with a variety of roads\n\u26abTraffic lights, other vehicles, pedestrians, stray \nanimals, road works, police cars, etc.\n\u26abInteract with the customer\nTask environments\nActuators (for outputs)\n\u26abControl over the accelerator, steering, gear shifting and \nbraking\n\u26abA display to communicate with the customers\nSensors (for inputs)\n\u26abDetect other vehicles, road situations\n\u26abGPS (Global Positioning System) to know where the \ntaxi is \n\u26abMany more devices are necessary\nTask environments\nTask environments arethe\nproblems\n\u26abWhile therational agents arethe\nsolutions\n\nProperties of task environments\nFully observable vs. Partially observable\n\u26abIf an agent\u2019s sensors give it access to the complete \nstate of the environment at each point in time then \nthe environment is effectively and fully observable\n\u26abif the sensors detect all aspects\n\u26abThat are relevant to the choice of action\nProperties of task environments\nPartially observable\nAn environment might be Partially observable because of \nnoisy and inaccurate sensors or because parts of the \nstate are simply missing from the sensor data.\nExample:\n\u26abA local dirt sensor of the cleaner cannot tell\n\u26abWhether other squares are clean or not \nProperties of task environments\nDeterministic vs. stochastic \n\u26abnext state of the environment Completely determined by the \ncurrent state and the actions executed by the agent, then the \nenvironment is deterministic, otherwise, it is Stochastic.  \n\u26abStrategic environment:  deterministic except for actions of \nother agents\n-Cleaner and taxi driver are:\n\u26abStochastic because of some unobservable aspects \n noise or \nunknown\nProperties of task environments\nEpisodic vs. sequential \n\u26abAn episode = agent\u2019s single pair of perception & action\n\u26abThe quality of the agent\u2019s action does not depend on other \nepisodes \n\u26abEvery episode is independent of each other\n\u26abEpisodic environment is simpler\n\u26abThe agent does not need to think ahead\nSequential\n\u26abCurrent action may affect all future decisions\n-Ex. Taxi driving and chess.\nProperties of task environments\nStatic vs. dynamic \n\u26abA dynamic environment is always changing over time \n\u26abE.g., the number of people in the street\n\u26abWhile static environment \n\u26abE.g., the destination\nSemidynamic\n\u26abenvironment is not changed over time\n\u26abbut the agent\u2019s performance score does\nProperties of task environments\nDiscrete vs. continuous\n\u26abIf there are a limited number of distinct states, \nclearly defined percepts and actions, the \nenvironment is discrete \n\u26abE.g., Chess game\n\u26abContinuous: Taxi driving \nProperties of task environments\nSingle agent VS. multiagent\n\u26abPlaying a crossword puzzle \u2013single agent\n\u26abChess playing \u2013two agents\n\u26abCompetitive multiagent environment\n\u26abChess playing\n\u26abCooperative multiagent environment\n\u26abAutomated taxi driver\n\u26abAvoiding collision\nProperties of task environments\nKnown vs. unknown\nThis distinction refers not to the environment itslef but to the \nagent\u2019s (or designer\u2019s) state of knowledge about the \nenvironment.\n-In known environment, the outcomes for all actions are\ngiven.  ( example: solitaire card games).\n-If the environment is unknown, the agent will have to learn \nhow it works in order to make good decisions.( example: \nnew video game).", "mimetype": "text/plain", "start_char_idx": 14146, "end_char_idx": 18303, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ef3ac94b-69df-4b1b-a820-0f7b82cf71c0": {"__data__": {"id_": "ef3ac94b-69df-4b1b-a820-0f7b82cf71c0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "edfc7015-bc4c-440f-91c4-ad69148e5daf", "node_type": "1", "metadata": {}, "hash": "01eefb09394b09ff884a9721512dc51850f7b8722c97ad773fb3233cdbea0a2b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a0053a03-aa02-4e76-90f4-54435f9b90e7", "node_type": "1", "metadata": {}, "hash": "c7a2e74e5ca5bdba5c4849e1212e1af4d36d63151f6dbc877fc66cf5ea920330", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "multiagent\n\u26abPlaying a crossword puzzle \u2013single agent\n\u26abChess playing \u2013two agents\n\u26abCompetitive multiagent environment\n\u26abChess playing\n\u26abCooperative multiagent environment\n\u26abAutomated taxi driver\n\u26abAvoiding collision\nProperties of task environments\nKnown vs. unknown\nThis distinction refers not to the environment itslef but to the \nagent\u2019s (or designer\u2019s) state of knowledge about the \nenvironment.\n-In known environment, the outcomes for all actions are\ngiven.  ( example: solitaire card games).\n-If the environment is unknown, the agent will have to learn \nhow it works in order to make good decisions.( example: \nnew video game).\nExamples of Task Environments\n\nStructure of agents\nAgent = architecture + program\n\u26abArchitecture = some sort of computing device \n(sensors + actuators)\n\u26ab(Agent) Program = some function that implements \nthe agent mapping = \u201c?\u201d\n\u26abAgent Program = Job of AI\nAgent programs\nSkeleton design of an agent program\nAgent Programs\nP = the set of possible percepts\nT= lifetime of the agent\n\u26abThe total number of percepts it receives\nSize of the look up table\nConsider playing chess\n\u26abP =10, T=150\n\u26abWill require a table of at least 10150entries\nTypes of agent programs\nFour types\n\u26abSimple reflex agents\n\u26abModel -based reflex agents\n\u26abGoal -based agents\n\u26abUtility -based agents \nSimple reflex agents\nIt uses just condition -action rules\n\u26abThe rules are like the form \u201cif \n\u2026 then \u2026\u201d \n\u26abefficient but have narrow \nrange of applicability\n\u26abBecause knowledge \nsometimes cannot be stated \nexplicitly \n\u26abWork only \n\u26abif the environment is \nfully observable\n\nA Simple Reflex Agent in Nature\npercepts\n(size, motion)\nRULES:\n(1)  If small moving object,\nthen activate SNAP\n(2)  If large moving object,\nthen activate A VOID and inhibit SNAP\nELSE (not moving) then NOOP\nneeded for\ncompletenessAction: SNAP or A VOID or NOOP\nModel -based Reflex Agents \nFor the world that is partially observable\n\u26abthe agent has to keep track of an internal state\n\u26abThat depends on the percept history\n\u26abReflecting some of the unobserved aspects\n\u26abE.g., driving a car and changing lane\nRequiring two types of knowledge\n\u26abHow the world evolves independently of the agent\n\u26abHow the agent\u2019s actions affect the world\nModel -based Reflex Agents \n\nModel -based Reflex Agents \nThe agent is with memory\nGoal -based agents\nCurrent state of the environment is always not \nenough \nThe goal is another issue to achieve \n\u26abJudgment of rationality / correctness\nActions chosen \n goals, based on\n\u26abthe current state \n\u26abthe current percept \nGoal -based agents\nConclusion\n\u26abGoal -based agents are less efficient\n\u26abbut more flexible \n\u26abAgent \n Different goals \n different tasks\n\u26abSearch and planning \n\u26abtwo other sub -fields in AI \n\u26abto find out the action sequences to achieve its goal \nGoal -based agents\n\nUtility -based agents\nit is said state A has higher utility\n\u26abIf state A is more preferred than others\nUtility is therefore a function \n\u26abthat maps a state onto a real number\n\u26abthe degree of success \nUtility -based agents\n\nUtility -based agents\nit is said state A has higher utility\n\u26abIf state A is more preferred than others\nUtility is therefore a function \n\u26abthat maps a state onto a real number\n\u26abthe degree of success \nUtility -based agents\nUtility has several advantages: \n\u26abWhen there are conflicting goals, \n\u26abOnly some of the goals but not all can be achieved\n\u26abutility describes the appropriate trade -off \n\u26abWhen there are several goals \n\u26abNone of them are achieved certainly\n\u26abutility provides a way for the decision -making \nLearning Agents\nAfter an agent is programmed, can it work \nimmediately?", "mimetype": "text/plain", "start_char_idx": 17677, "end_char_idx": 21218, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a0053a03-aa02-4e76-90f4-54435f9b90e7": {"__data__": {"id_": "a0053a03-aa02-4e76-90f4-54435f9b90e7", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ef3ac94b-69df-4b1b-a820-0f7b82cf71c0", "node_type": "1", "metadata": {}, "hash": "ca6b5fb71eda69901adb8e936a6ddeeeffc64645dc91ec1037ef379329d8d871", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "37ad3b6d-7a5c-41b2-b8ba-d9465253165b", "node_type": "1", "metadata": {}, "hash": "cc30bb1623aca29c392ec79106de88d6ec3b4468291d676b251064db9bd14dd7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u26abNo, it still need teaching\nIn AI,\n\u26abOnce an agent is done\n\u26abWe teach it by giving it a set of examples\n\u26abTest it by using another set of examples\nWe then say the agent learns\n\u26abA learning agent\nLearning Agents\nFour conceptual components\n\u26abLearning element\n\u26abMaking improvement\n\u26abPerformance element\n\u26abSelecting external actions\n\u26abCritic\n\u26abTells the Learning element how well the agent is doing with respect \nto fixed performance standard.\n(Feedback from user or examples, good or not?)\n\u26abProblem generator\n\u26abSuggest actions that will lead to new and informative experiences.\nLearning Agents\n\nAI Applications in Medicine\nAI-powered \nsystems can analyze \nmedical images, \npatient data, and \nsymptoms to assist \nclinicians in making \nmore accurate and \ntimely diagnoses, \nimproving patient \noutcomes.AI algorithms can \naccelerate the drug \ndiscovery process by \nidentifying promising \ndrug candidates, \nsimulating drug \ninteractions, and \noptimizing clinical \ntrials.AI-driven design and \nmanufacturing \ntechniques are enabling \nthe creation of highly \ncustomized prosthetic \nlimbs that better fit and \nfunction for individual \npatients, enhancing \ntheir quality of life.AI-enabled wearable \ndevices and sensors \ncan continuously \nmonitor patients' vital \nsigns, activity levels, \nand other health \nindicators, allowing \nfor earlier \nintervention and more \nproactive care.\nAI Applications in E-Commerce\n\u2022Personalized Product Recommendations :\n\u2013AI analyzes past customer behavior, browsing history, and \npurchase history to suggest relevant products.\n\u2013Features like \u201cPeople also purchased\u201d or \u201cCustomers also \nviewed\u201d enhance the shopping experience1.\n\u2022Chatbots and Virtual Assistants :\n\u2013AI-powered chatbots handle customer inquiries, provide \nsupport, and assist with order tracking.\n\u2013They improve response time and enhance customer \nsatisfaction.\nAI Applications in E -Commerce\n\u2022Fraud Detection and \nPrevention :\n\u2013AI algorithms identify \nsuspicious transactions, \npatterns, and anomalies.\n\u2013This helps prevent \nfraudulent activities and \nprotects both customers and \nbusinesses.\n\nAI Applications in E -Commerce\n\u2022Dynamic Pricing :\n\u2013AI adjusts prices based on real -time data, competitor \npricing, and demand fluctuations.\n\u2013Businesses can maximize revenue while remaining \ncompetitive.\n\u2022Customer Churn Prediction :\n\u2013AI analyzes customer behavior to predict potential churn \n(when customers stop buying).\n\u2013Businesses can take proactive measures to retain customers .\nAI Applications in E -Commerce\n\u2022Inventory Management :\n\u2013AI optimizes inventory levels by predicting demand and \nautomating restocking.\n\u2013It ensures products are available when needed without \noverstocking .\n\u2022Generative AI:\n\u2013AI generates product descriptions, marketing content, and \neven designs.\n\u2013It enhances creativity and efficiency in content creation.\nAI Representation\n\u2022Representation in AI refers to how\nknowledge, data, and information are\nencoded and structured within an\nintelligent system . This internal\nrepresentation iscrucial for effective\nreasoning, decision -making, and problem -\nsolving capabilities .\n\u2022Knowledge representation techniques like\nmachine learning models, NLP, and\nknowledge graphs capture thecomplexities\nofthe real world, allowing AIsystems to\nunderstand context, infer relationships, and\nmake intelligent inferences .\n\nProperties of Internal Representation\n4 5 6\nFuture Scope of AI\n\nFuture Scope of AI\n\nIssues in the design of Search Algorithms\n\u2022Definition : Search algorithms are methods for locating specific \ndata within a larger dataset or finding solutions to \ncomputational problems.\n\u2022Importance: Efficient search algorithms are critical for \napplications in computer science, AI, data retrieval, and more.\n\u2022Common Issues in Search Algorithm Design\n\u2022Scalability:\n\u2013Challenge of maintaining performance with increasing \ndataset sizes.\n\u2013Example: Algorithms that perform well on small datasets \nmay become inefficient on larger ones.\n\u2022\nIssues in the design of Search Algorithms\n\u2022Complexity:\n\u2013Time Complexity: The algorithm's running time in relation to the input \nsize.\n\u2013Space Complexity: The amount of memory required by the algorithm.\n\u2013Need to balance between time and space efficiency.\n\u2022Accuracy and Precision:\n\u2013Ensuring the algorithm returns correct and relevant results.\n\u2013Handling false positives and false negatives.\n\u2022Robustness:\n\u2013Algorithm's ability to handle different types of data and edge cases.\n\u2013Example: Dealing with noisy, incomplete, or corrupted data.\nAI problems\n1- Common -Place Tasks : Recognizing People and Objects:\n\u2013Humans and some animals can effortlessly identify faces, objects, and \nscenes.\n\u2013Challenges in AI: Developing systems that can reliably and accurately \nperform visual recognition.\n\u2022Communicating Through Natural Language:\n\u2013Humans naturally understand and generate language.", "mimetype": "text/plain", "start_char_idx": 21219, "end_char_idx": 26014, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "37ad3b6d-7a5c-41b2-b8ba-d9465253165b": {"__data__": {"id_": "37ad3b6d-7a5c-41b2-b8ba-d9465253165b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a0053a03-aa02-4e76-90f4-54435f9b90e7", "node_type": "1", "metadata": {}, "hash": "c7a2e74e5ca5bdba5c4849e1212e1af4d36d63151f6dbc877fc66cf5ea920330", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b0d40a68-05a8-40db-bb83-d9b3b0fc87ab", "node_type": "1", "metadata": {}, "hash": "7713067db5b445c1b594fd08e4e10cbd5b43ce3f7c2bb54171ca3156bb3e43ce", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2013Example: Algorithms that perform well on small datasets \nmay become inefficient on larger ones.\n\u2022\nIssues in the design of Search Algorithms\n\u2022Complexity:\n\u2013Time Complexity: The algorithm's running time in relation to the input \nsize.\n\u2013Space Complexity: The amount of memory required by the algorithm.\n\u2013Need to balance between time and space efficiency.\n\u2022Accuracy and Precision:\n\u2013Ensuring the algorithm returns correct and relevant results.\n\u2013Handling false positives and false negatives.\n\u2022Robustness:\n\u2013Algorithm's ability to handle different types of data and edge cases.\n\u2013Example: Dealing with noisy, incomplete, or corrupted data.\nAI problems\n1- Common -Place Tasks : Recognizing People and Objects:\n\u2013Humans and some animals can effortlessly identify faces, objects, and \nscenes.\n\u2013Challenges in AI: Developing systems that can reliably and accurately \nperform visual recognition.\n\u2022Communicating Through Natural Language:\n\u2013Humans naturally understand and generate language.\n\u2013Challenges in AI: Achieving accurate natural language processing and \nunderstanding.\n\u2022Navigating Around Obstacles:\n\u2013Humans and animals navigate environments without collisions.\n\u2013Challenges in AI: Creating autonomous systems that can navigate \ndynamic and unstructured environments safely.\n\u2022\nAI problems\n2- Expert Tasks : \n\u2022Medical Diagnosis:\n\u2013Requires specialized knowledge and training.\n\u2013Achievements in AI: Systems capable of diagnostic assistance and \nanalysis.\n\u2022Mathematical Problem Solving:\n\u2013Involves high -level cognitive skills.\n\u2013Achievements in AI: Algorithms for symbolic integration, theorem \nproving.\n\u2022Playing Games like Chess:\n\u2013Requires strategic thinking and planning.\n\u2013Achievements in AI: Development of AI systems that can compete with \nhuman champions in chess.\nDefining State & State Space\n\u2013A state is a representation of problem elements at a given \nmoment.\n\u2013A State space is the set of all states reachable from the initial \nstate.\n\u2022A state space forms a graph in which the nodes are states and the \narcs between nodes are actions.\n\u2022In state space, a path is a sequence of states connected by a sequence \nof actions.\n\u2022The solution of a problem is part of the graph formed by the state \nspace.\n\u2022The state space representation forms the basis of most of the AI \nmethod s.\nContd \u2026\n\u2022Its structure corresponds to the structure of problem solving in \ntwo important ways:\n\u2013It allows for a formal definition of a problem as per the need \nto convert some given situation into some desired situation \nusing a set of permissible operations.\n\u2013It permits the problem to be solved with the help of known \ntechniques and control strategies to move through the \nproblem space until goal state is found .\nDefine the Problem as State Space Search\n\u2022Ex.1: -Consider the problem of Playing Chess\n\u2013To build a program that could play chess, we have to specify:\n\u2022The starting position of the chess board,\n\u2022The rules that define legal moves, and\n\u2022The board position that represents a win.\n\u2013The starting position can be described by an 8 X 8 array square in which \neach element square (x, y), (x varying from 1 to 8 & y varying from 1 to \n8) describes the board position of an appropriate piece in the official \nchess opening position.\n\u2013The goal is any board position in which the opponent does not have a \nlegal move and hisor her \u201cking\u201d is under attack.\n\u2013The legal moves provide the way of getting from initial state of final \nstate.\nEx.1 :-Consider the problem of Playing Chess\n\u2013The legal moves can be described as a set of rules consisting of two \nparts: A left side that gives the current position and the right side that \ndescribes the change to be made to the board position.\n\u2013An example is shown in the following figure.\n\u2022Current Position\n\u2022While pawn at square ( 5 , 2), AND Square ( 5 , 3 ) is empty, AND Square ( 5 , \n4) is empty.\n\u2022Changing Board Position\n\u2022Move pawn from Square ( 5 , 2 ) to Square ( 5 , 4 ) .\n\u2013The current position of a chess coin on the board is its state and the set \nof all possible states is state space .\n\u2013One or more states where the problem terminates are goal states.\nEx.1 :-Consider the problem of Playing Chess\n\u2013Chess has approximately 10120game paths. These positions comprise \nthe problem search space.\n\u2013Using above formulation, the problem of playing chess is defined as a \nproblem of moving around in a state space, where each state \ncorresponds to a legal position of the board .\n\u2013State space representation seems natural for play chess problem \nbecause the set of states, which corresponds to the set of board \npositions, is well organized.", "mimetype": "text/plain", "start_char_idx": 25042, "end_char_idx": 29593, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b0d40a68-05a8-40db-bb83-d9b3b0fc87ab": {"__data__": {"id_": "b0d40a68-05a8-40db-bb83-d9b3b0fc87ab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "37ad3b6d-7a5c-41b2-b8ba-d9465253165b", "node_type": "1", "metadata": {}, "hash": "cc30bb1623aca29c392ec79106de88d6ec3b4468291d676b251064db9bd14dd7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5e686433-3ec5-4267-8393-421d5c659ff1", "node_type": "1", "metadata": {}, "hash": "8f4a24200b08e9254cc2616315f06aca6049cb925c5def1b0e88cd92210cbf60", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Changing Board Position\n\u2022Move pawn from Square ( 5 , 2 ) to Square ( 5 , 4 ) .\n\u2013The current position of a chess coin on the board is its state and the set \nof all possible states is state space .\n\u2013One or more states where the problem terminates are goal states.\nEx.1 :-Consider the problem of Playing Chess\n\u2013Chess has approximately 10120game paths. These positions comprise \nthe problem search space.\n\u2013Using above formulation, the problem of playing chess is defined as a \nproblem of moving around in a state space, where each state \ncorresponds to a legal position of the board .\n\u2013State space representation seems natural for play chess problem \nbecause the set of states, which corresponds to the set of board \npositions, is well organized.\nDefine the Problem as State Space Search\nEx.2: -Consider Water Jug problem\n\u2013A Water Jug Problem: You are given two jugs, a 4 -gallon one and a 3 -\ngallon one, a pump which has unlimited water which you can use to fill \nthe jug, and the ground on which water may be poured. Neither jug has \nany measuring markings on it. How can you get exactly 2 gallons of \nwater in the 4 -gallon jug?\n\u2013Here the initial state is (0, 0). The goal state is (2, n) for any value of n.\n\u2013State Space Representation: we will represent a state of the problem as \na tuple (x, y) where x represents the amount of water in the 4 -gallon jug \nand y represents the amount of water in the 3 -gallon jug. Note that 0 \u2264 x \n\u2264 4, and 0 \u2264 y \u2264 3.\nEx.2: -Water Jug problem\n\u2013To solve this we have to make some assumptions not mentioned in the \nproblem. They are:\n\u2022We can fill a jug from the pump.\n\u2022We can pour water out of a jug to the ground.\n\u2022We can pour water from one jug to another.\n\u2022There is no measuring device available.\n\u2013Operators \u2013we must define a set of operators that will take us from one \nstate to another.\nEx.2: -Water Jug problem\nSr. Current state Next State Descriptions\n1 (x,y)if x< 4 (4,y) Fillthe4gallon jug\n2 (x,y)if y<3 (x,3) Fillthe3gallon jug\n3 (x,y)if x>0 (x-d,y) Pour some water outofthe4\ngallon jug\n4 (x,y)if y>0 (x,y-d) Pour some water outofthe3\ngallon jug\n5 (x,y)if x>0 (0, y) Empty the4gallon jug\n6 (x,y)if y>0 (x,0) Empty the3gallon jugonthe\nground\n7 (x,y)ifx+y>=\n4and y \n> 0(4,y-(4-x)) Pour water from the3gallon\njugintothe 4 gallon jug until the \n4 gallon jug is full\n8 (x,y)ifx+y>=\n3and \nx>0(x-(3-y),3)Pour water from the 4 gallon \njuginto the 3 -gallon jug until the \n3 gallon jug is full\n9 (x,y)ifx+y\n<=4\nand \ny>0(x+y, 0) Pour all the water from the 3 \ngallon jug into the 4 gallon jug10 (x,y)ifx+y\n<=3\nand \nx>0(0, x+y) Pour all the water from the \n4 gallon jug into the 3 \ngallon jug\n11 (0,2) (2,0) Pour the 2 gallons from 3 \ngallon jug into the 4 gallon \njug\n12 (2,y) (0,y) Empty the2gallons inthe\n4 gallon jugon the ground\nDefine the Problem as State Space Search\n\u2022Ex.3: -Consider 8 puzzle problem\n\u2022The8puzzle consists ofeight numbered, movable\ntiles setina3x3frame .One celloftheframe is\nalways empty thus making itpossible tomove an\nadjacent numbered tileintotheempty cell.Such a\npuzzle isillustrated infollowing diagram .\n\u2022The program istochange theinitial configuration\nintothegoal configuration .", "mimetype": "text/plain", "start_char_idx": 28850, "end_char_idx": 31997, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5e686433-3ec5-4267-8393-421d5c659ff1": {"__data__": {"id_": "5e686433-3ec5-4267-8393-421d5c659ff1", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b0d40a68-05a8-40db-bb83-d9b3b0fc87ab", "node_type": "1", "metadata": {}, "hash": "7713067db5b445c1b594fd08e4e10cbd5b43ce3f7c2bb54171ca3156bb3e43ce", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7eb92e06-26dd-4c4c-8584-6358f51ef161", "node_type": "1", "metadata": {}, "hash": "69fb110f51568c00400b8fc3eb255b54475ef5a8b3bb08e2d67e07983956f2fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022The program istochange theinitial configuration\nintothegoal configuration .\n\u2022Asolution tothe problem isanappropriate\nsequence ofmoves, such as\u201cmove tiles5to\n\u2022theright, move tile7totheleft,move tile6tothe\ndown\u201d etc\u2026\n\nEx.3: -Consider 8 puzzle problem\nSearch\n\nEx.3: -Consider 8 puzzle problem\nSearch\n\u2013To solve a problem, we must specify the global database, the rules, and \nthe control strategy.\n\u2013For the 8 puzzle problem that correspond to three components.\n\u2013These elements are the problem states, moves and goal.\n\u2013In this problem each tile configuration is a state.\n\u2013The set of all possible configuration in the problem space, consists of \n3,62,880 different configurations of the 8 tiles and blank space.\n\u2013For the 8 -puzzle, a straight forward description is a 3X3 array of matrix \nof numbers. Initial global database is this description of the initial \nproblem state. Virtually any kind of data structure can be used to \ndescribe states .\nEx.3: -Consider 8 puzzle problem\nSearch\n\u2013The 8 -puzzle is conveniently interpreted as having the following for \nmoves.\n\u2022Move empty space (blank) to the left, move blank up, move blank to the \nright and move blank down.\n\u2022These moves are modeled by production rules that operate on the state \ndescriptions in the appropriate manner.\n\u2013The goal condition forms the basis for the termination.\n\u2013The control strategy repeatedly applies rules to state descriptions until a \ndescription of a goal state is produced.\n\u2013It also keeps track of rules that have been applied so that it can \ncompose them into sequence representing the problem solution.\n\u2013A solution to the 8 -puzzle problem is given in fig. 1.\nProduction System\n\u2022Since search forms the basis of many AI systems, it is useful to \nstructure them in a way that facilitates describing and performing the \nsearch process. Production system provides such a structure.\n\u2022A Production System consists of \n(i)A set of rules of the form A       B\n(ii)One or more knowledge base (Static and Dynamic)\n(iii)A Control Strategy specifying the order in which rules are \nto be applied and a way to resolve the conflicts.\nProduction System\n\u2022Since search forms the basis of many AI systems, it is useful to \nstructure them in a way that facilitates describing and performing the \nsearch process. Production system provides such a structure.\n\u2022A Production System consists of \n(i)A set of rules of the form A       B\n(ii)One or more knowledge base (Static and Dynamic)\n(iii)A Control Strategy specifying the order in which rules are \nto be applied and a way to resolve the conflicts.\nStructure of Production System\n\nAdvantages of Production System\n\u2022Separation of KB and Control.\n\u2022The natural mapping into state space search.\n\u2022Modularity of production rules: \n\u201cThe scope of variables of the rules remain confined to an individual \nrule\u201d. This syntactic independence can support addition, deletion or \nmodification of rules.\n\u2022Opportunity for heuristic control of the search: Heuristics may be \nencoded in the form of production rules and kept stored in the KB.\nTypes of Production Systems\n\u2022Monotonic : Application of a rule at a state of problem never prohibits \nlater application of another rule that could have been applied when \nthe first rule was selected.\n\u2022Partially Commutative : If application of a sequence of rules converts \nthe state x to state y, then application of any allowable permutation of \nthese rules will also convert the state x into state y.\n\u2022Commutative: A PS which is both monotonic and partially \ncommutative.\nCharacteristics of Commutative Production System \n\u2022Any rule applicable to a state of problem is also applicable to the \nstate resulting from application of that rule at that state of the \nproblem .\n\u2022Ifthegoal state can bereached from astate byapplication ofa\nsequence ofrules, then itcan also bereached from the state\nresulting from application ofthat rule atthat state .\n\nEvaluation of Production System \n\u2022Efficiency/Cost of a PS is determined with the following costs\n\u2013Rule Application cost\n\u2013Cost of control\n\nDefining the Problem as a State Space Search\n\u2022Defining Problem & Search\n\u2013A problem is described formally as:\n\u2022Define a state space that contains all the possible configurations of \nrelevant objects.\n\u2022Specify one or more states within that space that describe possible \nsituations from which the problem solving process may start. These \nstates are called initial states.\n\u2022Specify one or more states that would be acceptable as solutions to \nthe problem. These states are called goal states.\n\u2022Specify a set of rules that describe the actions available.", "mimetype": "text/plain", "start_char_idx": 31921, "end_char_idx": 36486, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7eb92e06-26dd-4c4c-8584-6358f51ef161": {"__data__": {"id_": "7eb92e06-26dd-4c4c-8584-6358f51ef161", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ptCVQznOQy52jFVKbg2CgFnPpKMfDs-Q", "node_type": "4", "metadata": {}, "hash": "f228e35ea2c31ae0793f0657dc1fed5ab4b5affbfd728082d6df31d24ded23f3", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5e686433-3ec5-4267-8393-421d5c659ff1", "node_type": "1", "metadata": {}, "hash": "8f4a24200b08e9254cc2616315f06aca6049cb925c5def1b0e88cd92210cbf60", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Ifthegoal state can bereached from astate byapplication ofa\nsequence ofrules, then itcan also bereached from the state\nresulting from application ofthat rule atthat state .\n\nEvaluation of Production System \n\u2022Efficiency/Cost of a PS is determined with the following costs\n\u2013Rule Application cost\n\u2013Cost of control\n\nDefining the Problem as a State Space Search\n\u2022Defining Problem & Search\n\u2013A problem is described formally as:\n\u2022Define a state space that contains all the possible configurations of \nrelevant objects.\n\u2022Specify one or more states within that space that describe possible \nsituations from which the problem solving process may start. These \nstates are called initial states.\n\u2022Specify one or more states that would be acceptable as solutions to \nthe problem. These states are called goal states.\n\u2022Specify a set of rules that describe the actions available.\nContd...\n\u2013The problem can then be solved by using the rules, in \ncombination with an appropriate control strategy, to move \nthrough the problem space until a path from an initial state to a \ngoal state is found.\n\u2013This process is known as search.\n\u2013Search is fundamental to the problem -solving process.\n\u2013Search is a general mechanism that can be used when more direct \nmethod is not known.\n\u2013Search also provides the framework into which more direct \nmethods for solving subparts of a problem can be embedded.\nReferences\n1. \"Artificial Intelligence: A Modern Approach\" by Stuart Russell and Peter Norvig\nThis is one of the most comprehensive and widely used textbooks on AI, covering both the theoretical \nfoundations and practical applications of AI.\n2. \"Deep Learning\" by Ian Goodfellow , Yoshua Bengio , and Aaron Courville\nThis book provides an in -depth introduction to deep learning, a key area within AI, and covers a range of \ntopics from basic neural networks to advanced architectures.\n3. \"Superintelligence : Paths, Dangers, Strategies\" by Nick Bostrom\nThis book explores the potential future of AI, particularly the concept of superintelligent AI, and discusses \nthe ethical and strategic challenges that could arise.\n4. \"Human Compatible: Artificial Intelligence and the Problem of Control\" by Stuart Russell  \nIn this book, Stuart Russell discusses the alignment problem in AI and proposes ways to ensure that AI \nsystems are beneficial to humanity.\n5. \"The Master Algorithm: How the Quest for the Ultimate Learning Machine Will Remake Our World\" by \nPedro Domingos\nThis book provides an accessible overview of machine learning and explores different approaches to \ndeveloping a universal learning algorithm.\nwww.paruluniversity.ac.in", "mimetype": "text/plain", "start_char_idx": 35622, "end_char_idx": 38233, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b4193740-18da-49cf-99d2-1083b744b643": {"__data__": {"id_": "b4193740-18da-49cf-99d2-1083b744b643", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1BFPy-GLIB6IwW27gg1PyXr9FRD_E7VjX", "node_type": "4", "metadata": {}, "hash": "2f05a5a7051b8c486d46cad48ee3f4d232f1c55a1edea5c952272bfe061b55cc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Assignment# 3  \n1. Explain different types of Artificial Neural Network  \n2. Discuss two applications of fuzzy logic in real -world problems  \n \nLong Question:  \n1. Define Non Monotonic Reasoning and explain it with a suitable example.  \n2. Explain Architecture of an expert system. What are the examples of expert system?  \n3. Explain steps of Natural Language Processing?  \n4. What are the key differences between Matplotlib and Seaborn in Python for data \nvisualization, and in what scenarios would you choose one library over the other?  \n5. What are fuzzy set operations?  \n6. Explain membership functio ns in fuzzy logic.  \n7. Explain spell checking in NLP systems.  \n8.  Explain steps of Natural Language Processing?  \n9. Provide two case studies on expert systems, highlighting their architecture, knowledge \nrepresentation, and applications.  \n  \nParul Institute of Technology, Limda, Vadodara  \nSubject: Artificial Intelligence  (303105307)       Course: B.Tech  \nYear & Sem: B.Tech -III & Sem -V      Branch:  Artificial Intelligence", "mimetype": "text/plain", "start_char_idx": 6, "end_char_idx": 1050, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7fd9acd6-83e5-430e-8027-c46850cff6d2": {"__data__": {"id_": "7fd9acd6-83e5-430e-8027-c46850cff6d2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1y5BKWh5PJ0Rjnwnd8WaFUTggdxvJ7a7U", "node_type": "4", "metadata": {}, "hash": "1bd7bade67cfe3841ecb9548d6dad05f04a30393ca8d97678de01a3d4a6fa62e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Assignment# 2  \n1. Explain Inference Rules.  \n2. Explain how a Bayesian network can be used to represent uncertain knowledge.  \n3. Describe the difference between propositional logic and first -order logic. Give an example of \neach.  \n4. Give the logical translation of the statement: \u201cNone of my friends are perfect.\u201d [Hint: Use \npredicate logic]. List any three inference rules in predicate logic  \n5. Define classification and list the common types of classification algorithms used to solve \nvarious real -world problems in machine  \nLong Question:  \n1. Explain different issues in Knowledge Representation.?  \n2. Define Types of Reasoning.  \n3. Explain Baye\u2019s theorem and Bayesian network.  \n4. What do you mean by Resolution? Explain with example.  \n5. What do you understand by hidden markov models (HMM)?  \n6. Determine whether the following argument is valid : \n\u201cIf my brother stands first in the class, I gave him a T -shirt. Either he stood first or I was out \nof station.  \nI did not give my brother a t -shirt. Therefore   I was out of station.\u201d  \n7. Change the following facts using first order predicate logic:  \ni) All men\u2019s are mortal.  \nii) Some children like indoor games, some are not.  \niii) All Black and Some Blue pens are in working condition.  \niv) Who believes in god is need not be a good person and who does not believe in god  \n8. Rule base contains following rule se t. \nRule 1: If A & C then F  \nRule 2: If A & E then G  \nRule 3: If B then E  \nRule 4: If G then D  \nProblem: Prove if A & B true then D is true. Prove this by using forward and backward \nchaining.  \n  \nParul Institute of Technology, Limda, Vadodara  \nSubject: Artificial Intelligence  (303105307)       Course: B.Tech  \nYear & Sem: B.Tech -III & Sem -V      Branch:  Artificial Intelligence", "mimetype": "text/plain", "start_char_idx": 6, "end_char_idx": 1793, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "aeece331-a7ae-438d-956f-bb8481c57f23": {"__data__": {"id_": "aeece331-a7ae-438d-956f-bb8481c57f23", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1lBC_u8KS2OgVW2Vty9KWwdSLlJ2N7iXC", "node_type": "4", "metadata": {}, "hash": "5b2dc6fe60861071b0d879679572356097f1953b3a0d161ab6ab623158843218", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Assignment# 1  \n1. How can a problem be defined as State Space Search? Explain with a suitable example.  \n2. Briefly explain the concept of a heuristic function in search algorithms. How does it affect the \nsearch process?  \n3. What is the AO* algorithm, and how does it differ from traditional search algorithms like A*  \nLong Question:  \n1. Explain Best First Search algorithm with a suitable example?  \n2. Explain Constraint satisfaction with a suitable example?  \n3. Demonstrate the technique of Means -End Analysis with an example. Discuss its potential \napplications along with disadvantages in detail  \n4. What is an intelligent agent? Describe basic kinds of agents program.  \n5. Write the brief notes on the following  \ni) 8-Queen Problem  \nii) Hill climbing search.  \n6. Describe A* search technique  \n7. What do you mean by breadth -first and depth -first search strategies.  \n \n \n  \nParul Institute of Technology, Limda, Vadodara  \nSubject: Artificial Intelligence  (303105307)       Course: B.Tech  \nYear & Sem: B.Tech -III & Sem -V      Branch:  Artificial Intelligence", "mimetype": "text/plain", "start_char_idx": 8, "end_char_idx": 1091, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "70183aae-20df-436d-b07a-349f350e8a33": {"__data__": {"id_": "70183aae-20df-436d-b07a-349f350e8a33", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw", "node_type": "4", "metadata": {}, "hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b1680562-982f-492b-9729-3b1a1d96984a", "node_type": "1", "metadata": {}, "hash": "565d3d2b2b2ba1256295eff3dd5a7cd5608b77202094859a621b47b40a9a8d81", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "LAB MANNUAL  \nARTIFICIAL INTELLIGENCE  \nCourse: B.TECH         Semester: 5   \nBranch: AI  \n \n1. Practical -1: Simple Facts and Queries in Prolog  \nHere's an example Prolog program demonstrating facts and queries:  \nProlog  \n \n% Facts about favorite colors  \nfavorite_color(john, blue).  \nfavorite_color(mary, green).  \nfavorite_color(jane, red).  \n \n% Rule to determine someone's favorite color  \nfavorite_color( X, Color) :- \n  favorite_color( X, Color). \n \n% Sample queries  \n?- favorite_color(john, Color). \n% Output: Color  = blue (assuming john's favorite color is blue)  \n \n?- favorite_color( X, green).  \n% Output: X = mary (assuming mary's favorite color is green)  \n \n \n \n \n  \nParul Institute of Technology, Limda, Vadodara  \nSubject: Artificial Intelligence (303105308)        Course: B.Tech  \nYear & Sem: B.Tech -III & Sem -V      Branch:  Artificial Intelligence  \n   \n\n2.Practical -2 \n\u2022 Write a python program to print the multiplication table for the given number?  \n\u2022 Write a python program to check whether the given number is prime or not?  \n\u2022 Write a python program to find factorial of the given number?  \nPractical -2: Python Programs  \na) Multiplication Table:  \nPython  \n \ndef multiplication_table (num): \n  \"\"\"Prints the multiplication table for the given number.\"\"\"  \n  for i in range(1, 11): \n    print(f\"{num} x {i} = {num * i} \") \n \nnumber = int(input(\"Enter a number: \" )) \nmultiplication_table(number)  \n \n \nb) Prime Number Check:  \n \nPython  \n \ndef is_prime (num): \n  \"\"\"Checks if a number is prime.\"\"\"  \n  if num <= 1: \n    return False \n  for i in range(2, int(num**0.5) + 1): \n    if num % i == 0: \n      return False \n  return True \n \nnumber = int(input(\"Enter a number: \" )) \nif is_prime(number):  \n  print(f\"{number}  is a prime number.\" ) \nelse: \n  print(f\"{number}  is not a prime number.\" ) \n \n \nc) Factorial Calculation:  \n \nPython  \n \ndef factorial (num): \n  \"\"\"Calculates the factorial of a number.\"\"\"  \n  if num == 0: \n    return 1 \n  else: \n    return num * factorial(num - 1) \n \nnumber = int(input(\"Enter a number: \" )) \nresult = factorial(number)  \nprint(f\"The factorial of {number}  is {result} .\") \n \n \n3. Practical -3: Write a python program to implement simple Chatbot?  \n Simple Chatbot  \nPython  Code:  \ngreetings = [ \"hi\", \"hello\", \"hey\"] \nquestions = [ \"how are you?\" , \"what's up?\" ] \nresponses = [ \"I'm doing well, thanks for asking!\" , \"Just hanging \naround, what about you?\" ] \n \nwhile True: \n  user_input = input(\"You: \").lower()  \n  if user_input in greetings:  \n    print(\"Chatbot: Hi there!\" ) \n  elif user_input in questions:  \n    print(random.choice(responses))  \n  elif user_input == \"bye\": \n    print(\"Chatbot: Bye! Have a nice day.\" ) \n    break \n  else: \n    print(\"Chatbot: Sorry, I don't understand. Try asking something \nelse.\") \n \n \n4. Practical -4: \u2022 Write a python program to implement List operations (Nested List, \nLength, Concatenation, Membership, Iteration,  \nIndexing and Slicing)?  \n\u2022 Write a python program to implement List methods (Add, Append, Extend & Delete).  \nList Operations  \na) List Operations:  \n \nPython  \n \n# Nested List, Length, Concatenation, Membership  \nmy_list = [ 1, 2, [3, 4], \"hello\"] \nlength = len(my_list)  \ncombined_list = my_list + [ 5, 6] \nis_member = \"hello\" in my_list \n \nprint(f\"Nested List: {my_list} \") \nprint(f\"Length: {length} \") \nprint(f\"Combined List: {combined_list} \") \nprint(f\"Is 'hello' a member?", "mimetype": "text/plain", "start_char_idx": 10, "end_char_idx": 3428, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b1680562-982f-492b-9729-3b1a1d96984a": {"__data__": {"id_": "b1680562-982f-492b-9729-3b1a1d96984a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw", "node_type": "4", "metadata": {}, "hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "70183aae-20df-436d-b07a-349f350e8a33", "node_type": "1", "metadata": {}, "hash": "f2630bc6d8462401cb5ff2f6c4419b9eb4538232914343b35c20240116c2b874", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1e51d6b0-5915-4a00-ac60-f47b9943bd7f", "node_type": "1", "metadata": {}, "hash": "c6cdfb29178351f4641c7a9680b8ac3b01c5c4602c176b4cf29046220fb03dfd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Try asking something \nelse.\") \n \n \n4. Practical -4: \u2022 Write a python program to implement List operations (Nested List, \nLength, Concatenation, Membership, Iteration,  \nIndexing and Slicing)?  \n\u2022 Write a python program to implement List methods (Add, Append, Extend & Delete).  \nList Operations  \na) List Operations:  \n \nPython  \n \n# Nested List, Length, Concatenation, Membership  \nmy_list = [ 1, 2, [3, 4], \"hello\"] \nlength = len(my_list)  \ncombined_list = my_list + [ 5, 6] \nis_member = \"hello\" in my_list \n \nprint(f\"Nested List: {my_list} \") \nprint(f\"Length: {length} \") \nprint(f\"Combined List: {combined_list} \") \nprint(f\"Is 'hello' a member? {is_member} \") \n \n# Iteration  \nfor item in my_list:  \n  print(item)  \n \n# Indexing and Slicing  \nfirst_item = my_list[ 0] \nsublist = my_list[ 2:] \n \nprint(f\"First item: {first_item} \") \nprint(f\"Sublist: {sublist} \") \n \n \nb) List Methods:  \nPython  \nmy_list = [ 1, 2, 3] \n \n# Add a new element at the end  \nmy_list.append( 4) \n \n# Extend the list with another iterable  \nmy_list.extend([ 5, 6]) \n \n# Remove the first element  \nmy_list.pop( 0) \n \nprint(f\"Modified  List: {my_list} \") \n \n \n5. Practical -5: \u2022 Write a python program to Illustrate Different Set Operations?  \n\u2022 Write a python program to generate Calendar for the given month and year?  \n\u2022 Write a python program to implement Simple Calculator program?  \na) Set Operations:  \nPython  \nset1 = {1, 2, 3}  \nset2 = {2, 3, 4}  \n \n# Union (combines elements from both sets)  \nunion_set = set1 | set2  \nprint(\"Union:\", union_set)  \n \n# Intersection (elements present in both sets)  \nintersection_set = set1 & set2  \nprint(\"Intersection:\", intersection_set)  \n \n# Difference (elements in set1 but not set2)  \ndifference_set = set1 - set2 \nprint(\"Difference:\", difference_set)  \n \n# Symmetric Difference (elements in either set but not both)  \nsymmetric_difference = set1 ^ set2  \nprint(\"Symmetric Difference:\", symmetric_difference)  \n \n# Check if a set is a subset of another (all elements of set1 are in set2)  \nis_subset = set1.issubset(set2)  \nprint(\"Is set1 a subset of set2?\", is_subset)  \n \n# Check if a set is a superset of another (all element s of set2 are in \nset1) \nis_superset = set1.issuperset(set2)  \nprint(\"Is set1 a superset of set2?\", is_superset)  \n \n# Check if sets are disjoint (no common elements)  \nis_disjoint = set1.isdisjoint(set2)  \nprint(\"Are set1 and set2 disjoint?\", is_disjoint)  \nb) Calendar Generation:  \nPython  \nimport calendar  \n \ndef generate_calendar(month, year):  \n  \"\"\"Generates a calendar for the given month and year.\"\"\"  \n  print(calendar.monthcalendar(year, month))  \n \nmonth = int (input(\"Enter month (1 -12): \"))  \nyear = int(input(\"Enter year: \"))  \ngenerate_calendar(month, year)  \nUse code with caution.  \ncontent_copy  \nc) Simple Calculator:  \nPython  \ndef calculate(num1, operator, num2):  \n  \"\"\"Performs basic arithmetic operations.\"\"\"  \n  if operator == \"+\":  \n    return num1 + num2  \n  elif operator == \" -\": \n    return num1 - num2 \n  elif operator == \"*\":  \n    return num1 * num2  \n  elif operator == \"/\":  \n    if num2 == 0:  \n      print(\"Error: Division by zero\")  \n      return None  \n    else: \n      return num1 / num2  \n  else: \n    print(\"Invalid operator.", "mimetype": "text/plain", "start_char_idx": 2781, "end_char_idx": 6006, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1e51d6b0-5915-4a00-ac60-f47b9943bd7f": {"__data__": {"id_": "1e51d6b0-5915-4a00-ac60-f47b9943bd7f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw", "node_type": "4", "metadata": {}, "hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b1680562-982f-492b-9729-3b1a1d96984a", "node_type": "1", "metadata": {}, "hash": "565d3d2b2b2ba1256295eff3dd5a7cd5608b77202094859a621b47b40a9a8d81", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54848d0b-c7af-4b68-a393-fe2cd74318a2", "node_type": "1", "metadata": {}, "hash": "84ebb7ae359c3eaf3b101a8098b7cdce65cba29e35e59b5f4236d66e5ffca55b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "print(calendar.monthcalendar(year, month))  \n \nmonth = int (input(\"Enter month (1 -12): \"))  \nyear = int(input(\"Enter year: \"))  \ngenerate_calendar(month, year)  \nUse code with caution.  \ncontent_copy  \nc) Simple Calculator:  \nPython  \ndef calculate(num1, operator, num2):  \n  \"\"\"Performs basic arithmetic operations.\"\"\"  \n  if operator == \"+\":  \n    return num1 + num2  \n  elif operator == \" -\": \n    return num1 - num2 \n  elif operator == \"*\":  \n    return num1 * num2  \n  elif operator == \"/\":  \n    if num2 == 0:  \n      print(\"Error: Division by zero\")  \n      return None  \n    else: \n      return num1 / num2  \n  else: \n    print(\"Invalid operator. Please use +, -, *, or /\")  \n    return None  \n \nwhile True:  \n  num1 = float(input(\"Enter first number: \"))  \n  operator = input(\"Enter  operator (+, -, *, /): \")  \n  num2 = float(input(\"Enter second number: \"))  \n  result = calculate(num1, operator, num2)  \n \n  if result is not None:  \n    print(f\"Result: {result}\")  \n  else: \n    print(\"Calculation failed.\")  \n \n  choice = input(\"Do you want to continue? (y/n): \").lower()  \n  if choice != 'y':  \n    break \nUse code with caution.  \ncontent_copy  \n6. Practical -6: \u2022 Write a python program to Add Two Matrices.  \n\u2022 Write a python program to Transpose a Matrix.  \na) Matrix Addition:  \nPython  \ndef add_matrices(matrix1, matrix2):  \n  \"\"\"Adds two matrices with the same dimensions.\"\"\"  \n  if len(matrix1) != len(matrix2) or len(matrix1[0]) != len(matrix2[0]):  \n    print(\"Error: Matrices must have the same dimensions.\")  \n    return None  \n \n  rows, cols = len(matrix1), len(matrix1[0])  \n  result = [[0 for _ in range(cols)] for _ in range(rows)]  \n  for i in range(rows):  \n    for j in range(cols):  \n      result[i][j] = matrix1[i][j] + matrix2[i][j]  \n  return result  \n \nmatrix1 = [[1, 2], [3, 4]]  \nmatrix2 = [[5, 6], [7, 8]]  \n \nresult = add_matrices(matrix1, matrix2)  \nif result is not None:  \n  print(\"Resultant Matrix:\")  \n  for row in result:  \n    print(row)  \nUse code with caution.  \ncontent_copy  \nb) Matrix Transpose:  \nPython  \ndef transpose_matrix(matrix):  \n  \"\"\"Transposes a matrix.\"\"\"  \n  rows, cols = len(matrix), len(matrix[0])  \n  transposed = [[0 for _ in ra nge(rows)] for _ in range(cols)]  \n  for i in range(rows):  \n    for j in range(cols):  \n      transposed[j][i] = matrix[i][j]  \n  return transposed  \n \nmatrix = [[1, 2, 3], [4, 5, 6]]  \n \ntransposed = transpose_matrix(matrix)  \nprint(\"Transposed Matrix:\")  \nfor row in transposed:  \n  print(row)  \nUse code with caution.  \ncontent_copy  \n7. Practical -7: Write a python program to implement Breadth First Search Traversal?  \nBreadth -First Search (BFS)  \nPython  \nfrom collections import deque  \n \ndef bfs_traversal(graph, start_node):  \n  \"\"\"Performs Breadth -First Search traversal on a graph.\"\"\"  \n  visited = set()  \n  queue = deque([start_node])  \n \n  while queue:  \n    current_node = queue.popleft()  \n    visited.add(current_node)  \n    print(current_node, end=\" \")  \n \n    for neighbor in graph[current_node]:  \n      if neighbor not in visited:  \n        queue.append(neighbor)  \n \n# Example usage (replace with your actual graph structure)  \ngraph = {  \n  'A': ['B', 'C'],  \n  'B': ['D', 'E'],  \n  'C': ['F'],  \n  'D': [], \n  'E': ['F'],  \n  'F': [] \n} \n \nbfs_traversal(graph, 'A')  \n \n \n \nPractical -8 \nWrite a python program to implement Water Jug Problem?  \nPython  \ndef water_jug_problem(jug1_capacity, jug2_capacity, target):  \n  \"\"\"Solves the Water Jug Problem using backtracking.\"\"\"  \n \n  def backtrack(current_state, visited):  \n    \"\"\"Recursive function to explore possible states.\"\"\"", "mimetype": "text/plain", "start_char_idx": 5351, "end_char_idx": 8955, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "54848d0b-c7af-4b68-a393-fe2cd74318a2": {"__data__": {"id_": "54848d0b-c7af-4b68-a393-fe2cd74318a2", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw", "node_type": "4", "metadata": {}, "hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1e51d6b0-5915-4a00-ac60-f47b9943bd7f", "node_type": "1", "metadata": {}, "hash": "c6cdfb29178351f4641c7a9680b8ac3b01c5c4602c176b4cf29046220fb03dfd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "979a31c1-c1ee-4cfd-998b-9f3c54746861", "node_type": "1", "metadata": {}, "hash": "e244497991f7a4afab499956a98efb99f3694a7b476f5cd02e532f252eaf6c85", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Python  \ndef water_jug_problem(jug1_capacity, jug2_capacity, target):  \n  \"\"\"Solves the Water Jug Problem using backtracking.\"\"\"  \n \n  def backtrack(current_state, visited):  \n    \"\"\"Recursive function to explore possible states.\"\"\"  \n    if current_state == (target, 0):  # Goal state reached  \n      return True  \n \n    if current_state i n visited:  # Avoid revisiting states  \n      return False  \n \n    visited.add(current_state)  \n \n    # Explore all possible actions from the current state  \n    for action in [\"fill jug1\", \"fill jug2\", \"empty jug1\", \"empty jug2\", \n\"pour jug1 to jug2\", \"pour jug2 to jug1\"]: \n      new_state = perform_action(current_state, jug1_capacity, \njug2_capacity, action)  \n      if new_state is not None and backtrack(new_state, visited):  \n        return True  # Solution found  \n \n    return False  # No solution found from this state  \n \n  # Function to perform actions on the current state and return the new \nstate \n  def perform_action(state, jug1_capacity, jug2_capacity, action):  \n    jug1, jug2 = state  \n \n    if action == \"fill jug1\":  \n      return jug1_capacity, jug2  \n    elif action == \"fill  jug2\": \n      return jug1, jug2_capacity  \n    elif action == \"empty jug1\":  \n      return 0, jug2  \n    elif action == \"empty jug2\":  \n      return jug1, 0  \n    elif action == \"pour jug1 to jug2\":  \n      amount = min(jug1, jug2_capacity - jug2) \n      return jug1 - amount, jug2 + amount  \n    elif action == \"pour jug2 to jug1\":  \n      amount = min(jug2, jug1_capacity - jug1) \n      return jug1 + amount, jug2 - amount \n    else: \n      return None  # Invalid action  \n \n  # Start backtracking from the initial state (0, 0)  \n  visited = set()  \n  return backtrack((0, 0), visited)  \n \n# Example usage  \njug1_capacity = 5  \njug2_capacity = 3  \ntarget = 4  \n \nif water_jug_problem(jug1_capacity, jug2_capacity, target):  \n  print(\"Solution found!\")  \nelse: \n  print(\"No solution exists for the given parameters.\")  \n \n \nPractical -9: Write a program to implement Tic -Tac-Toe \ngame using python.  \nTic-Tac-Toe Game  \nPython  \ndef display_board(board):  \n  \"\"\"Displays the current state of the Tic -Tac-Toe board.\"\"\"  \n  for row in b oard: \n    print(\"|\", end=\"\")  \n    for cell in row:  \n      print(cell, end=\"|\")  \n    print() \n \ndef is_winner(board, player):  \n  \"\"\"Checks if a player has won.\"\"\"  \n  win_conditions = ((0, 1, 2), (3, 4, 5), (6, 7, 8),  \n                    (0, 3, 6), (1, 4, 7), (2, 5, 8),  \n                    (0, 4, 8), (2, 4, 6))  \n  for condition in win_conditions:  \n    if all(board[i] == player for i in condition):  \n      return True  \n  return False  \n \ndef is_board_full(board):  \n  \"\"\"Checks if all cells are occupied.\"\"\"  \n  return all(cell != ' ' for cell in board)  \n \ndef get_player_move(board):  \n  \"\"\"Gets a valid move from the current player.\"\"\"  \n  while True:  \n    move = int(input(\"Enter your move (1 -9): \")) - 1 \n    if 0 <= move <= 8 and board[move] == ' ': \n      return move  \n    else: \n      print(\"Invalid move. Please try again.\")  \n \ndef play_tic_tac_toe():  \n  \"\"\"Main function to play the Tic -Tac-Toe game.\"\"\"  \n  board = [' '] * 9  \n  current_player = 'X'  \n \n  while True:  \n    display_board(board)  \n    move = get_player_move(board)  \n    board[move] = current_player  \n \n    if is_winner(board, current_player):  \n      display_board(board)  \n      print(f\"Player {current_player} wins!\")  \n      break \n \n    if is_board_full(board):  \n      display_board(board)  \n      print(\"It's a tie!\")", "mimetype": "text/plain", "start_char_idx": 8723, "end_char_idx": 12226, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "979a31c1-c1ee-4cfd-998b-9f3c54746861": {"__data__": {"id_": "979a31c1-c1ee-4cfd-998b-9f3c54746861", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw", "node_type": "4", "metadata": {}, "hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54848d0b-c7af-4b68-a393-fe2cd74318a2", "node_type": "1", "metadata": {}, "hash": "84ebb7ae359c3eaf3b101a8098b7cdce65cba29e35e59b5f4236d66e5ffca55b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd843e93-899f-47bd-a35e-959d531cf641", "node_type": "1", "metadata": {}, "hash": "2cbe9220f6d139471a8673f039261f63d94f735d0d8702f4d4af21905cf100b1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "while True:  \n    move = int(input(\"Enter your move (1 -9): \")) - 1 \n    if 0 <= move <= 8 and board[move] == ' ': \n      return move  \n    else: \n      print(\"Invalid move. Please try again.\")  \n \ndef play_tic_tac_toe():  \n  \"\"\"Main function to play the Tic -Tac-Toe game.\"\"\"  \n  board = [' '] * 9  \n  current_player = 'X'  \n \n  while True:  \n    display_board(board)  \n    move = get_player_move(board)  \n    board[move] = current_player  \n \n    if is_winner(board, current_player):  \n      display_board(board)  \n      print(f\"Player {current_player} wins!\")  \n      break \n \n    if is_board_full(board):  \n      display_board(board)  \n      print(\"It's a tie!\")  \n      break \n \n    current_player = 'O' if current_player == 'X' else 'X'  \n \n# Start the game  \nplay_tic_tac_toe()  \nUse code with caution.  \ncontent_copy  \nPractical -10: \u2022 Write a python program to remove stop words for a given passage from \na text file using NLTK?  \n\u2022 Write a python program to implement stemming for a given sentence using NLTK?  \n\u2022 Write a python program to POS (Parts of Speech) tagging for the give sentence using \nNLTK?  \nNLTK T ext Processing  \na) Remove Stop Words:  \nPython  \nimport nltk  \nfrom nltk.corpus import stopwords  \n \nnltk.download('stopwords')  # Download stopwords corpus (first time only)  \n \ndef remove_stopwords(text):  \n  \"\"\"Removes stop words from a given text.\"\"\"  \n  stop_words = stopwords.words('english')  \n  words = [word for word in text.lower().split() if word not in stop_words]  \n  return ' '.join(words)  \n \n# Example usage  \ntext = \"This is a sample sentence for stop word removal.\"  \nclean_text = remove_stopwords(text)  \nprint(f\"Original text: {text}\")  \nprint(f\"Clean text (stop words removed): {clean_text}\")  \nb) Stemming:  \nPython  \nimport nltk  \nfrom nltk.stem import PorterStemmer  \n \nnltk.download('punkt')  # Download punkt corpus for sentence tokenization \n(first time only)  \n \ndef stemming_sentence(text):  \n  \"\"\"Stems words in a given sentence.\"\"\"  \n  stemmer = PorterStemmer()  \n  words = [stemmer.stem(word) for word in text.lower().split()]  \n  return ' '.join(words)  \n \n# Example usage  \nsentence = \"The cars were running very fast on the highway.\"  \nstemmed_sentence = stemming_sentence(sentence)  \nprint(f\"Original sentence: {sentence}\")  \nprint(f\"Stemmed sentence: {stemmed_sentence}\")  \n \nc) POS Tagging:  \nPython  \nimport nltk  \nfrom nltk import word_tokenize  \n \nnltk.download('punkt')  # Download punkt corpus (first time only)  \n \ndef pos_tagging(text):  \n  \"\"\"Performs Part -of-Speech tagging on a sentence.\"\"\"  \n  words = word_tokenize(text)  \n  tagged_words = nltk.pos_tag(words)  \n  return tagged_words  \n \n# Example usage  \nsentence = \"The quick brown fox jumps over the lazy dog.\"  \ntagged_words = pos_tagging(sentence)  \nprint(f\"Sentence: {sentence}\")  \nprint(f\"POS Tags: {tagged_words}\")  \n \n \nPractical -11: \u2022 Write a python program to implement Lemmatization using NLTK?  \n\u2022 Write a python program to for Text Classification for the give sentence using NLTK?  \n NLTK Text Processing  \na) Lemmatization:  \nPython  \nimport nltk  \nfrom nltk.stem import WordNetLemmatizer  \n \nnltk.download('wordnet')  # Download WordNet  corpus (first time only)  \n \ndef lemmatization_sentence(text):  \n  \"\"\"Lemmatizes words in a given sentence.\"\"\"  \n  lemmatizer = WordNetLemmatizer()  \n  words = [lemmatizer.lemmatize(word) for word in text.lower().split()]  \n  return ' '.join(words)  \n \n# Example usage  \nsentence = \"The cars were running very fast on the highway.\"", "mimetype": "text/plain", "start_char_idx": 11561, "end_char_idx": 15072, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "dd843e93-899f-47bd-a35e-959d531cf641": {"__data__": {"id_": "dd843e93-899f-47bd-a35e-959d531cf641", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1q6mgBeKbTRI5xmPDA4KpJrlbEsN0i9Jw", "node_type": "4", "metadata": {}, "hash": "9bc288bd70c634332d53223bfdb2faacf3bcc2dfb03321a026437eb4107f70f1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "979a31c1-c1ee-4cfd-998b-9f3c54746861", "node_type": "1", "metadata": {}, "hash": "e244497991f7a4afab499956a98efb99f3694a7b476f5cd02e532f252eaf6c85", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Write a python program to for Text Classification for the give sentence using NLTK?  \n NLTK Text Processing  \na) Lemmatization:  \nPython  \nimport nltk  \nfrom nltk.stem import WordNetLemmatizer  \n \nnltk.download('wordnet')  # Download WordNet  corpus (first time only)  \n \ndef lemmatization_sentence(text):  \n  \"\"\"Lemmatizes words in a given sentence.\"\"\"  \n  lemmatizer = WordNetLemmatizer()  \n  words = [lemmatizer.lemmatize(word) for word in text.lower().split()]  \n  return ' '.join(words)  \n \n# Example usage  \nsentence = \"The cars were running very fast on the highway.\"  \nlemmatized_sentence = lemmatization_sentence(sentence)  \nprint(f\"Original sentence: {sentence}\")  \nprint(f\"Lemmatized sentence: {lemmatized_sentence}\")  \n \nb) Text Classification (Simple Example):  \nPython  \nimport nltk  \nfrom nltk.classify import NaiveBayesClassifier  \n \nnltk.download('punkt')  # Download punkt corpus (first time only)  \n \n# Sample training data with sentiment labels  \ndocuments = [  \n    (\"The movie was awesome\", \"positive\"),  \n    (\"The food was awful\", \"negative\"),  \n    (\"This is a great book!\", \"positive\"),  \n    (\"I don't like this movie\", \"negative\"),  \n    (\"This class is very interesting\", \"positive\")  \n] \n \n# Feature extraction function: bag -of-words \ndef feature_extraction (document):  \n  words = set(document.lower().split())  \n  features = {}  \n  for word in words:  \n    features[word] = True  \n  return features  \n \n# Train the Naive Bayes classifier  \nfeatures = [feature_extraction(d) for d, _ in documents]  \nlabels = [l for _, l in documents]  \nclassifier = NaiveBayesClassifier.train(features)  \n \n# Test the classifier with a new sentence  \nsentence = \"This is a bad movie.\"  \nfeatures = feature_extraction(sentence)  \npredicted_label = classifier.classify(features)  \nprint(f\"Sentence: {sentence}\")  \nprint(f\"Predicted sentiment: {predicted_label}\")", "mimetype": "text/plain", "start_char_idx": 14496, "end_char_idx": 16374, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "99fe27e4-ad97-4b98-90a8-6a74a105a187": {"__data__": {"id_": "99fe27e4-ad97-4b98-90a8-6a74a105a187", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "18R8yKqzrNvRvGbr0t1NqcqFCKuV1_drC", "node_type": "4", "metadata": {}, "hash": "f0d871625f58cc001f53010056415c52466ab9d173f308c57b4007414671c34d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3baa6dd8-732a-4641-bb20-2a9b1b0b0490", "node_type": "1", "metadata": {}, "hash": "abf5c846c757e13cb3a5eedc6d9df1b20cb0fec503d63bce5c1a715be92fdb46", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Semester:\n 5\nPrerequisite:\n Data structures, Fundamental of programming\nRationale:\n Analyze the asymptotic performance of algorithms. Write rigorous correctness proofs for algorithms. Demonstrate a \nfamiliarity with major algorithms and data structures. Apply important algorithmic design paradigms and methods of analysis. \nSynthesize efficient algorithms in common engineering design situations.\nTeaching and Examination Scheme\nTeaching Scheme\nCredit\nExamination Scheme\nTotal\nLecture\nHrs/Week\nTutorial\nHrs/Week\nLab\nHrs/Week\nHrs/Week\nInternal Marks\nExternal Marks\nT\nP\nT\nP\n3\n0\n0\n0\n3\n20\n-\n60\n-\n100\nSEE\n - Semester End Examination, \nCIA\n - Continuous Internal Assessment (It consists of Assignments/Seminars/Presentations/MCQ Tests, etc.)\nCE\n20\nCourse:\n BTech\nCourse Content\nW \n- Weightage (%) , \nT \n- Teaching hours\nSr.\nTopics\nW\nT\n1\nIntroduction and Analysis of Algorithms:\nAlgorithm: Definition, Properties, Types of Algorithms, Writing an Algorit\nAlgorithm Analysis: Parameters, Design \nTechniques of Algorithms\n \nAsymptotic Analysis: Big Oh, Big Omega & Big Theta Notations, Lower Bound, Upper Bound and Tight Bound, Best \nCase, Worst Case, Average Case\n \nAnalyzing control statement, Loop invariant and the correctness of the algorithm, Recurrences- substitution \nmethod, recursion tree method, master method. \n \nSorting Techniques with analysis: Bubble Sort, Selection Sort, Insertion sort. \n20\n10\n2\nDivide & Conquer Algorithms:\nStructure of divide-and-conquer algorithms, examples: Binary search, quick sort, Merge sort\n, \nStrassen \nMultiplication; Max-Min problem\n20\n6\n3\nGreedy Algorithms:\nIntroduction, Elements of Greedy Strategy\n \n- Minimum Spanning Tree: Kruskal's & Prim's Algorithm, Dijkstra\n\u2019\ns Algorithm, Knapsack Problem, Activity Selection \nProblem, Huffman Codes\n20\n8\n4\nDynamic Programming:\nPrincipal of Optimality, \n0/1\n Knapsack Problem, Making Change problem, Chain \nmatrix multiplication, Longest \nCommon Subsequence, All pair shortest paths: Warshall\n\u2019\ns and Floyd\n\u2019\ns algorithms\n20\n8\n5\nExploring Graphs:\nAn introduction using graphs and games, Undirected Graph, Directed Graph, Traversing Graphs, Depth First Search, \nBreath First Search, Topological sort\n5\n3\n6\nBacktracking and Branch & Bound:\nIntroduction to Backtracking, Introduction to Branch & Bound, \n0/1\n Knapsack Problem, N-Queens Problem, Travelling \nSalesman Problem\n5\n4\n7\nString Matching & NP Completeness:\nString Matching:\n \n- \nIntroduction to String Matching, \nNaive String Matching, Rabin-Karp Algorithm, Kruth-Morris-Pratt Algorithm, String \nMatching using Finite Automata\n \nNP Completeness:\n \n- Introduction to NP Completeness,  \nP class Problems, NP Class Problems, Hamiltonian Cycle\n10\n6\nPage 1 of 2\nPrinted on : 08-06-2024 10:38 AM\nSubject Syllabus \n303105218 - Design and Analysis of Algorithm\n\nCourse Outcome\nAfter Learning the Course the students shall be able to:\nCourse Outcome: After learning the course the students will be able to: \n1\n. Develop the ability to analyze the running time of any given algorithm using asymptotic analysis and prove the correctness of \nbasic algorithms.\n2\n. Design efficient algorithms for computational problems, using various algorithm design techniques taught in the course.\n3\n. Explain the major graph algorithms and their analyses. Employ graphs to model engineering problems, when appropriate.\n4\n. Analyze String matching algorithms.\n5\n. Explain the complexity classes P, NP, and NP-Complete, and demonstrate the NP-Completeness of a specific problems.\nReference Books\n1.\nIntroduction to Algorithms, \n4\nTH Edition, Thomas H Cormen, Charles E Lieserson, Ronald L Rivest and Clifford Stein, MIT \nPress/McGraw-Hill. (TextBook)\n2.\nFundamentals of Algorithms \n\u2013 \nE. Horowitz et al. (TextBook)\n3.\nAlgorithm Design, \n1\nST Edition, Jon Kleinberg and \u00c9vaTardos, Pearson\n4.\nAlgorithm Design: Foundations, Analysis, and Internet Examples, Second Edition, Michael T Goodrich and Roberto \nTamassia, Wiley.\n5.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3930, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3baa6dd8-732a-4641-bb20-2a9b1b0b0490": {"__data__": {"id_": "3baa6dd8-732a-4641-bb20-2a9b1b0b0490", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "18R8yKqzrNvRvGbr0t1NqcqFCKuV1_drC", "node_type": "4", "metadata": {}, "hash": "f0d871625f58cc001f53010056415c52466ab9d173f308c57b4007414671c34d", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99fe27e4-ad97-4b98-90a8-6a74a105a187", "node_type": "1", "metadata": {}, "hash": "65431af21a306fb90c12ddce815419c922952173fd2b6969204542c046638f36", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3\n. Explain the major graph algorithms and their analyses. Employ graphs to model engineering problems, when appropriate.\n4\n. Analyze String matching algorithms.\n5\n. Explain the complexity classes P, NP, and NP-Complete, and demonstrate the NP-Completeness of a specific problems.\nReference Books\n1.\nIntroduction to Algorithms, \n4\nTH Edition, Thomas H Cormen, Charles E Lieserson, Ronald L Rivest and Clifford Stein, MIT \nPress/McGraw-Hill. (TextBook)\n2.\nFundamentals of Algorithms \n\u2013 \nE. Horowitz et al. (TextBook)\n3.\nAlgorithm Design, \n1\nST Edition, Jon Kleinberg and \u00c9vaTardos, Pearson\n4.\nAlgorithm Design: Foundations, Analysis, and Internet Examples, Second Edition, Michael T Goodrich and Roberto \nTamassia, Wiley.\n5.\nAlgorithms\n\u2014\nA Creative Approach,\n3\nRD Edition, UdiManber, Addison-Wesley, Reading, MA\nMiscellaneous\nExam Requirement\nIt consists of Assignments/Seminars/Presentations/Quizzes/Surprise Tests (Summative/MCQ) etc\nPage 2 of 2\nPrinted on : 08-06-2024 10:38 AM\nSubject Syllabus \n303105218 - Design and Analysis of Algorithm", "mimetype": "text/plain", "start_char_idx": 3207, "end_char_idx": 4249, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "38584628-c8e4-454f-9e83-ff1306495cf3": {"__data__": {"id_": "38584628-c8e4-454f-9e83-ff1306495cf3", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1TMdwwLSTkuoQx3FzCL6psqndi2mi905r", "node_type": "4", "metadata": {}, "hash": "b2fde2939c8af2388e334cf78b787f3d5015de6dab931543f55cd140e4638eeb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed59aec0-74ca-4ea8-91a0-fee9a1edcb0f", "node_type": "1", "metadata": {}, "hash": "a2f2f85b4de9c93c7385b79f9c17cf474df1338a7763cc1501853b2bd8b8da42", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "QUESTION BANK (DESCRIPTIVE)  \n \nUnit 1: Introduction  \n1. What is Artificial Intelligence (AI)?  \n2. Identify and describe the major areas of AI.  \n3. List and explain various AI techniques.  \n4. Outline the historical development of AI.  \n5. What are some common problems in AI?  \n6. Describe production systems in the context of AI.  \n7. Discu ss the characteristics of problems that AI aims to solve.  \n8. Define an intelligent agent.  \n9. Describe the architecture of an intelligent agent.  \n10. How is AI applied in e -commerce?  Describe the use of AI in medicine.  \n11. Explain different types of Artificial Neural Network .  \n12. Explain AI representation and its properties.  \n13. Discuss the future scope of AI.  \n14. What are the common issues in designing search algorithms?  \n15. Provide an overview of various AI problems and applications.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \nParul Institute of Technology, Limda, Vadodara  \nSubject with Code: AI(303105307)      Course & Branch: B.Tech - AI \nYear & Sem: III-B.Tech & V -Sem        \n\n \n \n \n \n \n \n \n \n \nUnit 2: Search Techniques  \n1. Explain the generate -and-test method.  \n2. Describe the hill climbing search technique.  \n3. What is best -first search?  \n4. Discuss the problem reduction technique.  \n5. Explain constraint satisfaction problems.  \n6. Describe means -ends analysis.  \n7. Define heuristic search.  \n8. Compare hill climbing and be st-first search.  \n9. Discuss mean and end analysis.  \n10. Explain constraint satisfaction in detail.  \n11. Describe the A* algorithm and its applications.  \n12. Explain the AO* algorithm and its use cases.  \n13. What are the basic concepts of knowledge representati on? \n14. Discuss different knowledge representation paradigms.  \n15. Explain propositional logic.  \n16. List and explain inference rules in propositional logic.  \n17. How is knowledge represented using predicate logic?  \n18. Define predicate calculus.  \n19. Explain predicates and arguments.  \n20. Describe the ISA hierarchy.  \n21. How can a problem be defined as State Space Search? Explain with a \nsuitable  example.  \n22. Briefly explain the concept of a heuristic function in search algorithms. How \ndoes it affect the search process?  \n23. What is the AO* algorithm, and how does it differ from traditional search \nalgorithms like A*  \n24. Explain Best First Search algorithm with a suitable example?  \n25. Explain Constraint satisfaction with a suitable example?  \n26. Demonstrate t he technique of Means -End Analysis with an example. \nDiscuss its potential applications along with disadvantages in detail  \n \n \n  \nVadodara,Gujrat  \nQUESTION BANK (DESCRIPTIVE)  \nSubject with Code : AI(203105322 )     Course & Branch: B.Tech - AI \nYear & Sem: III-B.Tech & V -Sem      Regulation:  \n\n \n \n \n \n \n \n \n \n \n \nUnit 3: Knowledge Representation  \n1. What is knowledge representation? Discuss representation and mappings.  \n2. Describe different approaches to knowledge representation.  \n3. Identify issues in knowledge representation.  \n4. Explain how simple facts are represented in predicate logic.  \n5. How are instances and ISA relationships represented in knowledge systems?  \n6. What are computable functions and predicates?  \n7. Describe the resolution process in logic.  \n8. Ex plain representation and inference in propositional logic.  \n9. Discuss various reasoning patterns.  \n10. Describe the resolution method in logical reasoning.  \n11. How is information represented in first -order logic?  \n12. Explain inference in first -order logic.  \n13. Discuss reasoning patterns and resolution in first -order logic.  \n14. Explain Inference Rules.  \n15. Explain how a Bayesian network can be used to represent uncertain \nknowledge.  \n16. Describe the difference between propositional logic and first -order logic.  \nGive an example of each.  \n17. Give the logical translation of the statement: \u201cNone of my friends are \nperfect.\u201d [Hint: Use predicate logic]. List any three inference rules in predicate \nlogic  \n18.", "mimetype": "text/plain", "start_char_idx": 16, "end_char_idx": 4013, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ed59aec0-74ca-4ea8-91a0-fee9a1edcb0f": {"__data__": {"id_": "ed59aec0-74ca-4ea8-91a0-fee9a1edcb0f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1TMdwwLSTkuoQx3FzCL6psqndi2mi905r", "node_type": "4", "metadata": {}, "hash": "b2fde2939c8af2388e334cf78b787f3d5015de6dab931543f55cd140e4638eeb", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "38584628-c8e4-454f-9e83-ff1306495cf3", "node_type": "1", "metadata": {}, "hash": "d9629ff75aa13804dbd569b8ea02cc9046e307d40bd5319d74501fb6502189bc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "6. What are computable functions and predicates?  \n7. Describe the resolution process in logic.  \n8. Ex plain representation and inference in propositional logic.  \n9. Discuss various reasoning patterns.  \n10. Describe the resolution method in logical reasoning.  \n11. How is information represented in first -order logic?  \n12. Explain inference in first -order logic.  \n13. Discuss reasoning patterns and resolution in first -order logic.  \n14. Explain Inference Rules.  \n15. Explain how a Bayesian network can be used to represent uncertain \nknowledge.  \n16. Describe the difference between propositional logic and first -order logic.  \nGive an example of each.  \n17. Give the logical translation of the statement: \u201cNone of my friends are \nperfect.\u201d [Hint: Use predicate logic]. List any three inference rules in predicate \nlogic  \n18. Define classification and list the common types of classificat ion algorithms \nused to solve various  real-world problems in machine  \n \n \n \n \n \n \n\\ \n \n  \nVadodara,Gujrat  \nQUESTION BANK (DESCRIPTIVE)  \nSubject with Code: AI(203105322 )    Course & Branch: B.Tech - AI \nYear & Sem: III-B.Tech & V -Sem       \n\n \n \n \n \n \n \n \nUnit 4: Uncertainty  \n1. What is non -monotonic reasoning?  Explain it with an example.  \n2. Describe logics for non -monotonic reasoning.  \n3. Explain forward rules and backward rules.  \n4. What are justification -based truth maintenance systems?  \n5. Describe semantic nets.  \n6. Explain statistical reasoning.  \n7. Discuss the concepts of probability and Bayes\u2019 theorem.  \n8. Explain Bayesian networks.  \n9. Describe Markov networks.  \n10. Explain the hidden Markov model.  \n11. Discuss the basis of utilit y theory and utility functions  \n \n \n \n \nUnit 5: Fuzzy Sets and Fuzzy Logic  \n1. What are fuzzy set operations?  \n2. Explain membership functions in fuzzy logic.  \n3. Define fuzzy logic.  \n4. What are hedges in fuzzy logic?  \n5. Describe fuzzy propositions and inference rules.  \n6. Explain the components and functioning of fuzzy systems.  \n7. Discuss two applications of fuzzy logic in real -world problems  \n \n \n \n \n \n \n \n \n \n  \nVadodara,Gujrat  \nQUESTION BANK (DESCRIPTIVE)  \nSubject with Code: AI(203105322 )     Course & Branch: B.Tech - AI \nYear & Sem: III-B.Tech & V -Sem       \n\n \n \n \n \n \n \nUnit 6: Natural Language Processing  \n1. Provide an introduction to natural language processing (NLP).  \n2. Explain syntactic processing in NLP.  \n3. Discuss semantic analysis in NLP.  \n4. What is discourse processing in NLP?  \n5. Describe  pragmatic processing.  \n6. Explain spell checking in NLP systems.  \n7. Explain steps of Natural Language Processing?  \n \n \nUnit 7: Neural Networks and Expert Systems  \n1. Provide an introduction to neural networks.  \n2. Explain perception and qualitative analysis in neural networks.  \n3. Describe the architecture of neural networks.  \n4. Discuss various applications of neural networks.  \n5. Explain the utilization and functionality of neural networks.  \n6. What is the architecture of an expert system?  \n7. How is kn owledge represented in expert systems?  \n8. Provide two case studies on expert systems, highlighting their architecture, \nknowledge representation, and applications.   \nVadodara,Gujrat  \nQUESTION BANK (DESCRIPTIVE)  \nSubject with Code: AI(203105322 )     Course & Branch: B.Tech - AI \nYear & Sem: III-B.Tech & V -Sem", "mimetype": "text/plain", "start_char_idx": 3175, "end_char_idx": 6527, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4dd8126b-6010-4654-bb02-fa2d2efc3358": {"__data__": {"id_": "4dd8126b-6010-4654-bb02-fa2d2efc3358", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1t55p_gzM0o8Mn59Ie7kGy_5tfgWfu2Rj", "node_type": "4", "metadata": {}, "hash": "1590320091c0b9a784488f90f2904a4350a8af1c4698e9bad58d7ced97c78150", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Seat No:  .....................  Enrollment No : .....................\n \nPARUL  UNIVERSITY\nFACUL TY OF ENGINEERING & TECHNOLOGY\nB.Tech, Summer  2024-25 Examination\n \nSemester: VI / V Date: 19-04-2025\nSubject Code: 303105307 Time: 2.00 pm to 4.30 pm\nSubject Name: Artificial Intelligence Total Marks: 60\n \nInstructions:\n1. This question paper comprises of two sections. Write answer of both the sections in separate answer books.\n2. From Section A, Q.1 is compulsory , From Section B, Q.1 is compulsory .\n3. Figures to the right indicate full marks\n4. Draw neat and clean drawings & Make suitable assumptions wherever necessary .\n5. Start new question on new page.\n6. BT - Blooms Taxonomy Levels \u2013 Remember -1, Understand -2, Apply-3, Analyse-4, Evaluate-5, Create-6\n \n \nSECTION - A \nQ.1Answer the following questions. Marks CO BT\n A. (A) Define ISA  hierarchy .\n(B) List the advantages of using ISA  hierarchy in AI.\n(C) Explain its application in natural language processing.06 CO3 BT1\n B. (A) Define knowledge representation.\n(B) List its components.\n(C) Explain its role in AI problem-solving.06 CO1 BT5\nQ.2A. Define knowledge representation using frames and explain its role. 04 CO1 BT1\n B. Explain the role of Forward and Backward inference rules in non-monotonic\nreasoning systems.05 CO1 BT2\n OR    \n B. Justify the need for Statistical Reasoning in AI. 05 CO1 BT5\nQ.3A. State the main advantages of Depth-First Search in solving search problems. 04 CO4 BT1\n B. Define fuzzy set and explain its properties. 05 CO1 BT2\n OR    \n B. State the various operations on fuzzy sets. 05 CO2 BT1\n \nSECTION - B \nQ.1Answer the following questions. Marks CO BT\n A. (A) Discuss the history of AI.\n(B) Identify key milestones in AI development.\n(C) Justify the significance of AI's early history in shaping today's AI.06 CO1 BT2\n B. (A) State the role of Isa relationships in knowledge representation.\n(B) Define the role of Instance relationships.\n(C) Justify how they impact knowledge sharing.06 CO4 BT2\nQ.2A. Justify the significance of agent architectures in AI problem-solving. 04 CO1 BT1\n B. State and explain the future scope of AI in the field of medicine. 05 CO3 BT1\n OR    \n B. Define neural network training and explain the dif ference between batch\nand online training.05 CO4 BT2\nQ.3A. Define an AI problem and explain its types with examples. 04 CO4 BT1\n B. Define lexical semantics and explain its role in word sense disambiguation. 05 CO4 BT2\n OR    \n B. List the steps involved in syntactic processing of natural language. 05 CO2 BT1", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2541, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5fe7f664-78f8-4027-a331-fdccb3fc9042": {"__data__": {"id_": "5fe7f664-78f8-4027-a331-fdccb3fc9042", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1rrXAzl7sUuQxB92hu79t-TEIECl9m03S", "node_type": "4", "metadata": {}, "hash": "4e3fd4f94d1c73937185e96f41b4d0b6418205cdaa61c9912818e07f3d76d323", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Page 1 of 2 Seat No: ______________                 Enrollment No: ____________________  \nPARUL UNIVERSITY  \nFACULTY OF ENGINEERING & TECHNOLOGY  \nB.Tech / M.Tech  . Winter 202 4 - 25 Examination  \nSemester:  5          Date: 18/11/2024  \nSubject Code: 303105307         Time: 2:00pm  to 4:30pm  \nSubject Name: Artificial Intelligence        Total Marks: 60  \n \nInstructions:   \n1. This question paper comprises of two section s. Write answer of both the section s in separate answer book s. \n2. From Section A, Q.1 is compulsory, attempt any THREE from Q. 2 to Q. 5 \n3. From Section B, Q.1 is compulsory, attempt any THREE from Q. 2 to Q. 5  \n4. Make suitable assumptions wherever necessary.  \n5. Start new question on new page.  \n \nSection -A (30 Marks)  \nQ.1 Objective Type Questions  - (State, Define, List,  etc)   \n(All are compulsory and each of two mark s) (6) CO PO Bloom\u2019s \nTaxonomy  \n 1. Define Artificial Intelligence.   1 1 Remembering  \n 2. State two advantages of heuristic search in AI.   3 2 Understanding  \n 3. List the basic operations of fuzzy sets.   3 2 Remembering  \nQ.2 Answer the following questions .      \n A)  Differentiate between hill climbing and best -first search.  (3) 3 2 Analyzing  \n B)  Discuss the architecture and functionality of intelligent agents.  (5) 1 1 Evaluating  \nQ.3 Answer the following questions .      \n A)  Describe the \u201cj ustification -based truth maintenance systems \u201d. (3) 3 2 Understanding  \n B)  Explain how spell checking is implemented in NLP systems.  (5) 4 3 Understanding  \nQ.4 Answer the following questions .      \n A)  Explain non -monotonic reasoning in AI.  (3) 3 2 Understanding  \n B)  Explain Bayes\u2019 theorem and its importance in AI.  (5) 3 2 Understanding  \nQ.5 Answer the following questions .      \n A)  Describe fuzzy logic and its application in decision -making.  (3) 3 2 Understanding  \n B)  Describe the  architecture of neural network . (5) 3 1 Understanding  \nSection -B (30 Marks)  \nQ.1 Objective Type Questions  - (State, Define, List, etc)   \n(All are compulsory and each of two marks)  (6)    \n 1. List two applications of AI in E -commerce   1 1 Remembering  \n 2.   Define the term \"generate -and-test\" search technique.   3 2 Remembering  \n 3.   Define \"semantic analysis\" in NLP.   4 3 Remembering  \nQ.2 Answer the following questions .      \n A)  Explain ISA hierarchy in AI.  (3) 2 1 Understanding  \n B)  Discuss the future scope of  AI and the challenges it faces.  (5) 1 6 Evaluating  \nQ.3 Answer the following questions .      \n A)  Differentiate between propositional logic and predicate logic.  (3) 2 1 Analyzing  \n B)  Change the following facts using first order predicate logic:  \nC) Krishna loves  music.  \nD) All musician and some dancers enjoy the music.   (5) 2 1 Understanding  \n   Page 2 of 2 E) Some people like to watch football but mostly like to watch cricket.  \nF) All children like chocolate therefore they suffer from cavity.  \nG) If you work hard then definitely you should get good marks  \nQ.4 Answer the following questions .      \n A)  Describe the role of hidden Markov models in AI.  (3) 3 2 Understanding  \n B)  Discuss the role of neural networks in AI, highlighting their \narchitecture and applications.  (5) 4 3 Evaluating  \nQ.5 Answer  the following questions .      \n A)  Differentiate between monotonic reasoning  and non-monotonic \nreasoning . (3) 3 2 Analyzing  \n B)  Discuss the main goals and challenges of Natural Language \nProcessing (NLP).  (5) 1 6 Evaluating", "mimetype": "text/plain", "start_char_idx": 3, "end_char_idx": 3492, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fc9b2d5a-95fe-4c40-a007-6d13d1e9780e": {"__data__": {"id_": "fc9b2d5a-95fe-4c40-a007-6d13d1e9780e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1TRXFu5vEtdfL1AFq8xcJlnGLufSBx6KY", "node_type": "4", "metadata": {}, "hash": "46eba87f92a6b5418059373a63b08d2b8ee410fcc7641b1c1a4c480f27c2d5c6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Semester:\n 5\nPrerequisite:\n Calculus, Data Structures, and Algorithms\nCourse Objective:\n Formal Language & Automata Theory helps in natural language processing to solve a problem on a model of \ncomputation, using an algorithm. It enables to learn in which machine can be made to think.\nReference Books\n1.\nIntroduction to Automata theory, languages and Computation (TextBook)\nBy John E. Hopcroft, Rajiv Motwani and Jeffery D. Ullman | Pearson\n2.\nElements of the Theory of Computation\nBy Harry R.Lewis and Christos H. Papadimitriou | Pearson Education Asia\n3.\nIntroduction to the Theory of Computation\nBy Michael Sipser | PWS Publishing\n4.\nIntroduction to Languages and the Theory of Computation\nBy John C. Martin | McGraw Hill\n5.\nAutomata and Computability\nBy Dexter C. Kozen | Undergraduate Texts in Computer Science, Springer\nTeaching and Examination Scheme\nTeaching Scheme\nCredit\nExamination Scheme\nTotal\nLecture\nHrs/Week\nTutorial\nHrs/Week\nLab\nHrs/Week\nHrs/Week\nInternal Marks\nExternal Marks\nT\nP\nT\nP\n3\n0\n0\n0\n3\n20\n-\n60\n-\n100\nSEE\n - Semester End Examination, \nT\n - Theory, \nP\n - Practical\nCE\n20\nCourse:\n BTech\nCourse Content\nW \n- Weightage (%) , \nT \n- Teaching hours\nSr.\nTopics\nW\nT\n1\nIntroduction:\nAlphabet, languages and grammars, productions and derivation, Chomsky hierarchy of languages\n5\n2\n2\nRegular languages and finite automata:\nRegular expressions and languages, deterministic finite automata -\n(DFA) and equivalence with regular \nexpressions,\nMoore machines and mealy machines, Conversion from Mealy to Moore and vice versa, \n\u00a0nondeterministic\u00a0finite\u00a0automata\u00a0(NFA)\u00a0and\u00a0equivalence\u00a0with\u00a0DFA,\u00a0regular\u00a0grammars\u00a0and\u00a0equivalence\u00a0with\u00a0finite\u00a0\nautomata, properties of regular languages, pumping lemma for regular languages, minimization of finite automata.\n30\n12\n3\nGrammars:\nContext-free grammars (CFG) and languages (CFL), Chomsky normal forms, nondeterministic pushdown automata \n(PDA) and equivalence with CFG, parse trees, ambiguity in CFG, pumping lemma for context-free languages, \ndeterministic pushdown automata, closure properties of CFLs.\n , \nContext-sensitive languages: Context-sensitive \ngrammars (CSG) and languages.\n35\n15\n4\nTuring machines:\nThe basic model for Turing machines (TM), Turing-recognizable (recursively\n \nenumerable) and Turing- decidable \n(recursive) languages and their closure properties, variants of Turing machines, nondeterministic TMs and \nequivalence with deterministic TMs, unrestricted grammars and \nequivalence with Turing machines, TMs as \nenumerators.\n25\n10\n5\nUndecidability:\nChurch Turing thesis, universal Turing machine, the universal and diagonalization languages\n5\n6\nPage 1 of 2\nPrinted on : 25-04-2025 10:21 AM\nSubject Syllabus \n303105306 - Theory of Computation\n\nCourse Outcome\nAfter Learning the Course the students shall be able to:\nAfter Learning the course, the students shall be able to:\n1\n. Recognize the basic concepts and applications of theory of Computation. \n2\n. Solve Computational Problems using Regular Languages and Finite Automata. \n3\n. Solve Computational Problems using Context free Grammar and Push Down Automata. \n4\n. Design Turing Machine for simple computational Problems. \n5\n. Analyze various concepts of undecidability and Computable Function.\nPage 2 of 2\nPrinted on : 25-04-2025 10:21 AM\nSubject Syllabus \n303105306 - Theory of Computation", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3315, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2db2d2f0-c6f6-4195-b3b0-3dc59ea7ac8b": {"__data__": {"id_": "2db2d2f0-c6f6-4195-b3b0-3dc59ea7ac8b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12euCEx8S2H9bVeyf9lllhl_b-6S_R9zq", "node_type": "4", "metadata": {}, "hash": "65f485a472300c56ffcfe1d03f835768bcf0dbaeb01d4d4eea9123b29ef71c35", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Unit 1: Introduction  \n1. Define an alphabet and a language. Give three examples of each.  \n2. Explain what a grammar is and list the types of grammars as per Chomsky hierarchy.  \n3. For the grammar G=(V, \u03a3,R,S) with productions S\u2192aSb\u2223\u03f5,  list the strings generated by GGG of \nlength 4.  \n4. Draw the Chomsky hierarchy and explain each level with examples.  \n5. Differentiate between language, grammar, and automaton.  \nUnit 2: Regular Languages and Finite Automata  \n1. Convert the regular expression (a+b)\u2217abb into a DFA.  \n2. Design a Moore machine to detect the sequence \"101\" in an input bit stream.  \n3. Given the following NFA, convert it into an equivalent DFA:  \no States: {q0, q1}  \no Alphabet: {0,1}  \no Transitions: \u03b4(q0,0) = {q0,q1}, \u03b4(q0,1) = {q0}, \u03b4(q1,1) = {q1}  \n4. Write a regular grammar corresponding to the language L={anbm\u2223n,m\u22650}. \n5. Use the pumping lemma to prove that the language L={anbn\u2223n\u22650} is not regular.  \n6. Minimize the following DFA (provide a transition table):  \no States: {A, B, C, D}  \no Alphabet: {0,1}  \no Transitions: A\u21920\u2192B, A\u21921\u2192C, B\u21920\u2192A, B\u21921\u2192D, C\u21920\u2192D, C\u21921\u2192A, D\u21920\u2192C, \nD\u21921\u2192B  \n7. List and prove closure properties of regular languages under union, concatenation, and \nKleene star.  \n \nUnit 3: Grammars  \n1. Construct a CFG for the language L={anbn\u2223n\u22650}. \n2. Convert the following CFG into Chomsky Normal Form:  \no S\u2192ASA\u2223aB \no A\u2192B\u2223S \no B\u2192b\u2223\u03f5 \n3. Draw parse trees for the string \"aabb\" using the grammar from Q1.  \n4. Explain ambiguity with an example grammar and show how to remove ambiguity.  \n5. Prove using the pumping lemma that the language L={anbncn\u2223n\u22650} is not context -free.  \n6. Design a PDA that accepts the language L={anbn\u2223n\u22650} by empty stack method.  \n7. State closure properties of CFLs and give examples where closure fails.  \n8. Differentiate between deterministic and nondeterministic PDA with examples.  \n9. Explain context -sensitive languages and give an example grammar for the language \n{anbncn\u2223n\u22651} \n \nUnit 4: Turing Machines  \n1. Design a TM that accepts the language L={anbn\u2223n\u22651}. \n2. Explain the difference between Turing -decidable and Turing -recognizable languages with \nexamples.  \n3. Prove that the class of Turing -decidable languages is closed under union and intersection.  \n4. Describe the working of a nondeterministic Turing machine and explain its equivalence with \ndeterministic TM.  \n5. Show that unrestricted grammars are equivalent in power to Turing machines.  \n6. Explain the concept of TM as an enumerator with an example.  \n7. Write the formal definition of a Turing machine and explain each component.  \n \nUnit 5: Undecidability  \n1. State and explain the Church -Turing thesis.  \n2. Describe the construction of a universal Turing machine.  \n3. Explain the diagonalization language and how it proves certain languages are undecidable.  \n4. List at least three undecidable problems and explain why they are undecidable.  \n5. Discuss the halting problem and prove its undecidability.  \n6. Explain the significance of universal Turing machine in computability theory.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3053, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "99eb0697-6ac5-40c3-8ee5-d2e42933ee76": {"__data__": {"id_": "99eb0697-6ac5-40c3-8ee5-d2e42933ee76", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1g0HXmmom8Ge3D12GQ8xzAWZRgAOztlld", "node_type": "4", "metadata": {}, "hash": "822204096fdb9a763f95fdca5a78199ff7564a3a03646946dcfd572ae307bbee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "45526eaf-842e-4846-b66e-f3fd999e4aab", "node_type": "1", "metadata": {}, "hash": "4aa7ab504cd8988b0c13c4a6e9321f2626af34ba019c024d965e2e71e6c0ac7c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Undecidability  \nProf. Riddhi Atulkumar Mehta  \nCSE, PIT  \nParul University  \n \n Study Guide  \n                      \n \n \n \n \n \n1. Church Turing thesis ............................................................................................ ................... 1 \n2. Universal Turing Machine \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. \u2026\u2026\u2026\u2026 \u2026..\u2026.\u2026..2 \n3. The Universal and Diagonalization Languages \u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026.. .2 \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1 \n \n5.1 Church Turing thesis  \nHistorical Background  \n\uf0b7 Alonzo Church  (1936): Introduced \u03bb-calculus , a formal system for expressing computation via function \nabstraction and application.  \n\uf0b7 Alan Turing  (1936): Independently developed the Turing Machine , a theoretical machine to model \nalgorithmic processes.  \n\uf0b7 Both proved the same class of computable functions \u2014leading to the Church -Turing Thesis . \n \nThe Church -Turing Thesis  \n \n\u2022 \u201cA function is effectively computa ble if and only if it is computable by a Turing machine.\u201d  \n\u2022 \u201cEffectively computable\u201d = can be computed by a human or machine using an algorithm, without \nintuition or guesswork.  \n\u2022 The thesis is not a formal theorem, but a philosophical hypothesis supported by overwhelming evidence.  \n \nFormal Models of Computation  \nModel  Inventor  Year  Description  \nTuring Machine  Alan Turing  1936  Machine with infinite tape \nand head for reading/writing \nsymbols  \n\u03bb-Calculus  Alonzo Church  1936  Formal system based on \nvariable binding and  \nsubstitution  \nRecursive Functions  G\u00f6del/Kleene  1930s  Functions built using basic \noperations and recursion  \nPost Systems  Emil Post  1943  Production rules on strings \n(rewriting systems)  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    2 \n \n \nTuring Machine  \n \n\u2022 A Turing Machine is a mathematical model  of computation that operates on an infinite tape with a finite \nset of rules.  \n\u2022 Capable of simulating any algorithm.  \n\u2022 Forms the basis of modern computing models.  \n \nWhat Does \u201cComputable\u201d Mean?  \n \n\u2022 A function f: N\u2192N is computable  if there exists an algorithm (or TM) that produces f(n)  for every input n.  \n\u2022 Example : \n\u2022 Computable: Addition, multiplication, sorting  \n\u2022 Non -computable: Halting problem, truth of arbitrary mathematical statements  \n \n5.2 Universal Turing Machine  \nUniversal Turing M achine  \n\u2022 A Universal Turing Machine is a theoretical model that can simulate any other Turing machine. Which is \nlittle complicated but we will see how it actually works.  \n\u2022 If we think about a regular Turing machine as a device built to perform one specific tas k. So, for example, \nwe might have a Turing machine to add two numbers together or check if a word is a palindrome or not. \nThese machines are task -specific; they do one thing and do it well.  \n\u2022 On the other hand, a Universal Turing Machine can perform any task  that a regular Turing machine can \ndo. By taking a description of that machine (let us call it M) and the input for that machine (let us call it \nX). The Universal Turing Machine, which we will denote as U, processes M and X and then outputs the \nresult of M  operating on X.  \n\u2022 The functional block diagram of the machine looks like this \u2013\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    3 \n \n \n \nHow Does a Universal Turing Machine Work?  \nTo understand how a Universal Turing Machine works, let us break down its process:  \n\u2022 Inputs  \u2212 The Universal Turing Machine takes two inputs:  \n\u2022 A description of another Turing machine (M),  \n\u2022 The input that this machine should process (X).  \n\u2022 Processing  \u2212 The Universal Turing Machine reads the description of M and interprets it as a set of \ninstructions.  \n\u2022 Simulation  \u2212 Using these instructions, the  Universal Turing Machine simulates the operations of M on the \ninput X.  \n\u2022 Output  \u2212 The result of this simulation is what M would produce when given X as input.  \n5.3 The Universal and Diagonalization Languages  \nThe Universal Language \ud835\udc3f\ud835\udc62 \nDefinition : \n\u2022 Lu={\u27e8M,w\u27e9\u2223M is a TM and M accepts  w}  \n\u2022 It contains all encodings of TMs and inputs such that the machine accepts the input.  \n\u2022 Captures the behavior of any TM on any input.", "mimetype": "text/plain", "start_char_idx": 66, "end_char_idx": 4620, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "45526eaf-842e-4846-b66e-f3fd999e4aab": {"__data__": {"id_": "45526eaf-842e-4846-b66e-f3fd999e4aab", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1g0HXmmom8Ge3D12GQ8xzAWZRgAOztlld", "node_type": "4", "metadata": {}, "hash": "822204096fdb9a763f95fdca5a78199ff7564a3a03646946dcfd572ae307bbee", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99eb0697-6ac5-40c3-8ee5-d2e42933ee76", "node_type": "1", "metadata": {}, "hash": "3e71a6b41c6bec11b10750faeab11f822815678c83d14387a725e2b3e660b484", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Processing  \u2212 The Universal Turing Machine reads the description of M and interprets it as a set of \ninstructions.  \n\u2022 Simulation  \u2212 Using these instructions, the  Universal Turing Machine simulates the operations of M on the \ninput X.  \n\u2022 Output  \u2212 The result of this simulation is what M would produce when given X as input.  \n5.3 The Universal and Diagonalization Languages  \nThe Universal Language \ud835\udc3f\ud835\udc62 \nDefinition : \n\u2022 Lu={\u27e8M,w\u27e9\u2223M is a TM and M accepts  w}  \n\u2022 It contains all encodings of TMs and inputs such that the machine accepts the input.  \n\u2022 Captures the behavior of any TM on any input.  \n \nProperties of \ud835\udc3f\ud835\udc62 \n\u2022 Recursively Enumerable (RE) : \nThere exists a TM (UTM)  that accepts all strings  in Lu  \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    4 \n \n\u2022 Not Recursive (Decidable) : \nThere is no TM  that can decide for every  input whether it\u2019s in Lu . \n The Halting Problem  is reducible to Lu  \n \nDiagonalization Language \ud835\udc3f\ud835\udc51 \nDefinition : \n\u2022 Ld={\u27e8M\u27e9\u2223M is a TM and M does  not accept  \u27e8M\u27e9} \n\u2022 Think of M being run on its own description . \n\u2022 Ld contains all TMs that do NOT accept themselves . \n \nSummary of Languages", "mimetype": "text/plain", "start_char_idx": 4020, "end_char_idx": 5290, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1213d792-c8d3-4919-af63-31f65d7e74b9": {"__data__": {"id_": "1213d792-c8d3-4919-af63-31f65d7e74b9", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE", "node_type": "4", "metadata": {}, "hash": "eb0386bd4c2b207144d51f0ff964333123f877925ef3e3ad8d0f2b9fcd1bc4d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "40b90bba-307b-45fd-a76d-18f13b6fc778", "node_type": "1", "metadata": {}, "hash": "2b842bfb710c5f3f787ed18345ed11da760d6e17518c6ef9a061fa6cb3ba39bc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Turing Machines  \nProf. Riddhi Atulkumar Mehta  \nCSE, PIT  \nParul University  \n \n Study Guide  \n                      \n \n \n \n \n \n1. The basic model for Turing machines (TM) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. ........... .............. 1 \n2. Turing -Recognizable and Turing -Decidable Languages \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026 \u2026..\u2026.\u2026..2 \n3. Variants of Turing Machines & Nondeterminism \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. .2 \n4. Unrestricted Grammars & Turing Machine Equivalence \u2026\u2026\u2026. \u2026\u2026\u2026\u2026... \u2026\u2026\u2026\u2026\u2026 ..\u2026\u2026\u2026\u2026 \u2026.3 \n5. Turing Machines as Enumerators \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026..\u2026\u2026\u2026\u2026 \u2026.4 \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1 \n \n4.1 The basic model for Turing machines (TM)  \nTuring Machine  \n\uf0b7 A Turing Machine is an accepting device which accepts the languages (recursively enumerable set) \ngenerated by type 0 grammars. It was invented in 1936 by Alan Turing.  \n\uf0b7 Turing Machines (TM) play a crucial role in the Theory of Computation (TOC). They are abstract \ncomputational devices used to explore the limits of what can be computed.  \n\uf0b7 Turing Machines help prove that certain languages and problems have no algorithmic solution.  \n\uf0b7 A Turing Machine (TM) is a mathematical model which consists of an infinite length tape divided into cells \non which  input is given.  \n\uf0b7 It consists of a head which reads the input tape. A state register stores the state of the Turing machine.  \n\uf0b7 After reading an input symbol, it is replaced with another symbol, its internal state is changed, and it \nmoves from one cell to the  right or left.  \n\uf0b7 If the TM reaches the final state, the input string is accepted, otherwise rejected.  \n\uf0b7 In the context of automata theory and the theory of computation, Turing machines are used to study the \nproperties of algorithms and to determine what prob lems can and cannot be solved by computers.  \n\uf0b7 They provide a way to model the behavior of algorithms and to analyze their computational complexity, \nwhich is the amount of time and memory they require to solve a problem.  \n\uf0b7 A TM can be formally described as a 7-tuple (Q, X, \u2211, \u03b4, q0, B, F)  \n \nDefinition of a Turing Machine  \n \nA TM can be formally described as a 7 -tuple (Q, X, \u2211, \u03b4, q 0, B, F) where \u2212  \n\u2022 Q is a finite set of states  \n\u2022 X is the tape alphabet  \n\u2022 \u2211 is the input alphabet  \n\u2022 \u03b4 is a transition function; \u03b4 : Q \u00d7 X \u2192 Q \u00d7 X \u00d7 {Left_shift, Right_shift}.  \n\u2022 q0 is the initial state  \n\u2022 B is the blank symbol  \n\u2022 F is the set of final states  \n \nTape and Head  \n\u2022 The tape is infinite in one or both directions  \n\u2022 The head moves left (L) or right (R)  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    2 \n \n\u2022 Can read , write, and move  \n \nTM vs Finite Automata  \n \nFeature  Finite Automaton  Turing Machine  \nMemory  Finite  Infinite Tape  \nRewrite Tape  No Yes \nMove Head  Right only  Left & Right  \nRecognizes  Regular Langs  RE Languages  \n \n \n4.2 Turing -Recognizable and Turing -Decidable \nLanguages  \nRecursively Enumerable languages  \n\u2022 If any Turing Machine can be designed to accept all string of the given language, then the language is \ncalled recursively enumerable language.  \n\u2022 Recursively enumerable languages are the formal languages that can be decide -able, (fully or partially).  \n\u2022 According to the Chomsky hierarchy of formal languages,  we can see the recursively enumerable \nlanguages as type 0 languages.  \n\u2022 An RE language can be accepted or recognized by Turing machine which means it will enter into final \nstate for the strings of language and may or may not enter into rejecting state for the strings which are \nnot part of the language.  \n\u2022 It means TM can loop forever for the strings which are not a part of the language. RE languages are also \ncalled as Tu ring recognizable languages.  \nRecursive Language (REC)  \n\u2022 A recursive language (subset of RE) can be decided by Turing machine which means it will enter into  final \nstate for the strings of language and rejecting state for the strings which are not part of the language.  \n\u2022 e.g.", "mimetype": "text/plain", "start_char_idx": 66, "end_char_idx": 4292, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "40b90bba-307b-45fd-a76d-18f13b6fc778": {"__data__": {"id_": "40b90bba-307b-45fd-a76d-18f13b6fc778", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE", "node_type": "4", "metadata": {}, "hash": "eb0386bd4c2b207144d51f0ff964333123f877925ef3e3ad8d0f2b9fcd1bc4d8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1213d792-c8d3-4919-af63-31f65d7e74b9", "node_type": "1", "metadata": {}, "hash": "fdded3400c3fec51576ee0055e800451cc1dce9af0ed7ec49ac3f553a4c001ec", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50e0fb59-ded3-4db5-9c0e-e2774eacbfed", "node_type": "1", "metadata": {}, "hash": "ce83fa40770dc2ed192d87a257b03a97a58fad6a77fca398170dc64ae25a4a2a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Recursively enumerable languages are the formal languages that can be decide -able, (fully or partially).  \n\u2022 According to the Chomsky hierarchy of formal languages,  we can see the recursively enumerable \nlanguages as type 0 languages.  \n\u2022 An RE language can be accepted or recognized by Turing machine which means it will enter into final \nstate for the strings of language and may or may not enter into rejecting state for the strings which are \nnot part of the language.  \n\u2022 It means TM can loop forever for the strings which are not a part of the language. RE languages are also \ncalled as Tu ring recognizable languages.  \nRecursive Language (REC)  \n\u2022 A recursive language (subset of RE) can be decided by Turing machine which means it will enter into  final \nstate for the strings of language and rejecting state for the strings which are not part of the language.  \n\u2022 e.g.; L= {anbncn|n>=1} is recursive because we can construct a turing machine which will move to final \nstate if the string is of the form anbncn else move to non -final state.  \n\u2022 So the TM will always halt in this case. REC languages are also called as Turing decidable languages.  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    3 \n \n \nRecognizable vs Decidable  \nFeature  Turing -Recognizable (RE)  Turing -Decidable (Recursive)  \nHalts on all inputs?  No Yes \nAccepts members?  Yes Yes \nRejects non -members?  Not guaranteed  Yes \nExample  Halting problem (RE)  Palindromes (Decidable)  \nClosure Properties: Turing -Decidable Languages  \nClosed under:  \n\u2022 Union  \n\u2022 Intersection  \n\u2022 Complement  \n\u2022 Concatenation  \n\u2022 Kleene star  \nClosure Properties: Turing -Recognizable Languages  \nClosed under:  \n\u2022 Union  \n\u2022 Intersection  \n\u2022 Concatenation  \n\u2022 Kleene star  \n\u274c Not closed under: Complement  \n4.3 Variants of Turing Machines & Nondeterminism  \nVariations of Turing Machine  \n\uf0b7 Turing machines are powerful computational models that can simulate any algorithmic process.  \n\uf0b7 A standard Turing machine consists of a single tape and a single read -write head. However, there are \nvariations of Turing machine that have been developed to addr ess different computational challenges.  \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    4 \n \n\uf0b7 These variations differ mainly in structure and operation, but they all have the same computational \npower as the standard Turing machine.  \nMulti -tape Turing Machine  \n\uf0b7 As the name suggests, a multi -tape Turing machine i s an extension of the standard Turing machine where \nmultiple tapes are available for input, output, and computation.  \n\uf0b7 Each tape has its own read -write head, and the machine's transition function is based on the current \nstate and the symbols read by each he ad. \n \nMulti -head Turing Machine  \n\uf0b7 In a multi -head Turing machine, a single tape is used, but it has multiple read -write heads.  \n\uf0b7 These heads can independently read and write symbols, enabling the machine to perform complex tasks \nmore efficiently.  \n \nTwo -way Infinite Tape Turing Machine  \n\uf0b7 A two -way infinite tape Turing machine allows the tape to extend infinitely in both directions, unlike the \nstandard machine where the tape extends infinitely in only one direction.  \n\uf0b7 This removes the boundary on the left side of  the tape.  \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    5 \n \n \nK-dimensional Turing Machine  \n\uf0b7 A K-dimensional Turing machine extends the concept of the tape to multiple dimensions.  \n\uf0b7 For example, a two -dimensional Turing machine as given in the following diagram, has a tape that \nextends infinitely in both t he X and Y directions.  \n \nEnumerator Turing Machine  \n\uf0b7 An enumerator Turing machine is designed to generate strings of a language. It is equipped with a work \ntape and an output tape.  \n\uf0b7 The machine writes symbols to the output tape, which is then printed.  \n \n \nNon -deterministic Turing Machine  \n\u2022 In a Non -Deterministic Turing Machine, for every state and symbol, there are a group of actions the TM \ncan have.  \n\u2022 So, here the transitions are not deterministic. The computation of a non -deterministic Turing Machine is \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    6 \n \na tree of configurations that can be reached from the start configuration.  \n\u2022 An input is accepted if there is at least one node of the tree which is an accept configuration, otherwise it \nis not accepted.  \n\u2022 If all branches of the computational tree halt on all i nputs, the non -deterministic Turing Machine is called \na Decider and if for some input, all branches are rejected, the input is also rejected.", "mimetype": "text/plain", "start_char_idx": 3410, "end_char_idx": 8511, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "50e0fb59-ded3-4db5-9c0e-e2774eacbfed": {"__data__": {"id_": "50e0fb59-ded3-4db5-9c0e-e2774eacbfed", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE", "node_type": "4", "metadata": {}, "hash": "eb0386bd4c2b207144d51f0ff964333123f877925ef3e3ad8d0f2b9fcd1bc4d8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "40b90bba-307b-45fd-a76d-18f13b6fc778", "node_type": "1", "metadata": {}, "hash": "2b842bfb710c5f3f787ed18345ed11da760d6e17518c6ef9a061fa6cb3ba39bc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b5f5ead1-40b1-4335-90d9-e191cf130192", "node_type": "1", "metadata": {}, "hash": "af7ec35e7e3fdfbe1039e0978d54cc3110a875e108abe5bcc5ac838c5cdb56d0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is equipped with a work \ntape and an output tape.  \n\uf0b7 The machine writes symbols to the output tape, which is then printed.  \n \n \nNon -deterministic Turing Machine  \n\u2022 In a Non -Deterministic Turing Machine, for every state and symbol, there are a group of actions the TM \ncan have.  \n\u2022 So, here the transitions are not deterministic. The computation of a non -deterministic Turing Machine is \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    6 \n \na tree of configurations that can be reached from the start configuration.  \n\u2022 An input is accepted if there is at least one node of the tree which is an accept configuration, otherwise it \nis not accepted.  \n\u2022 If all branches of the computational tree halt on all i nputs, the non -deterministic Turing Machine is called \na Decider and if for some input, all branches are rejected, the input is also rejected.  \nA non -deterministic Turing machine can be formally defined as a 6 -tuple (Q, X, \u2211, \u03b4, q 0, B, F) where \u2212  \n\u2022 Q is a fini te set of states  \n\u2022 X is the tape alphabet  \n\u2022 \u2211 is the input alphabet  \n\u2022 \u03b4 is a transition function;  \n\u2022 \u03b4 : Q \u00d7 X \u2192 P(Q \u00d7 X \u00d7 {Left_shift, Right_shift}).  \n\u2022 q0 is the initial state  \n\u2022 B is the blank symbol  \n\u2022 F is the set of final states  \n4.4 Unrestricted Grammars & Turing Machine \nEquivalence  \nUnrestricted Grammar  \n\u2022 Unrestricted grammar  is a type of formal grammar that is defined without any restrictions on the form of \nits production rules.  \n\u2022 Formally, a grammar  G = (V N, \u03a3, P, S)  is called an unrestricted grammar if all its produ ctions are in the \nform  LS \u2192 RS, where  LS is a string of non -terminal and terminal symbols, and  RS is a string of non -\nterminal and terminal symbols or the empty string.  \n\u2022 This form of grammar is known as  Type 0 grammar  in the  Chomsky hierarchy, and it is the  most general \nform of grammar.  \n \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    7 \n \n \n\u2022 The lack of restrictions allows for a more flexible and powerful method of string generation, which leads \nto the capabilities of a Turing machine.  \n\u2022 Every language that can be generated by an unrestricted grammar can be recognized by a Turing \nmachine, and vice versa.  \n\u2022 This states the idea that the set of languages generated by unrestricted grammar is equivalent to the set \nof recursively enumerable lang uages.  \nAn unrestricted grammar  (Type -0) is a 4 -tuple:  \nG = (V, \u03a3, R, S)  where:  \n\u2022 V: Variables (non -terminals)  \n\u2022 \u03a3: Terminals  \n\u2022 R: Rules of the form \u03b1 \u2192 \u03b2 , where:  \n\u2022 \u03b1 \u2208 (V \u222a \u03a3)^+ (\u03b1 \u2260 \u03b5)  \n\u2022 \u03b2 \u2208 (V \u222a \u03a3)^*  \n\u2022 S: Start symbol  \n \nEquivalence of Unrestricted Grammars and Turing Machines  \n\u2022 Theorem:  A language is generated by an unrestricted grammar if and only if it is recursively enumerable \n(i.e., it is semidecided by some Turing machine M).  \n\u2022 Proof:  \n\u2022 Only if (grammar \u2192 TM): by construction of a nondeterministic Turing machine.  \n\u2022 If (TM \u2192 grammar): by construction of a grammar that mimics backward computations of M.  \n \nDirection 1 \u2013 Grammar \u21d2 TM \nGiven an unrestricted grammar G, we can construct a TM M such that:  \n\u2022 M simulates leftmost derivation of G on input string w  \n\u2022 If derivation leads to w, M accepts  \n\ud83d\udee0 Method:  \n\u2022 Encode derivations on the TM tape  \n\u2022 Simulate rule application step -by-step  \nDirection 2 \u2013 TM \u21d2 Grammar  \nGiven a TM M, we can construct an unrestricted grammar G such that:  \n\u2022 G generates all strings accepted by M  \n\ud83d\udee0 Idea:  \n\u2022 Simulate  TM configurations as strings  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    8 \n \n\u2022 Use productions to mimic TM transitions  \n4.5 Turing Machines as Enumerators  \nWhat is an Enumerator?  \n\u2022 An enumerator is a Turing machine with an attached printer (output device)  \n\u2022 It prints (enumerates) strings of a language L possib ly in infinite sequence  \n\u2022 Strings may appear in any order, possibly with repetition  \n\u2022 There are different variations of Turing Machines, which are quite powerful and useful in several cases.  \n\u2022 We have a variation of the Turing machine called the Enumerator, whi ch plays a different but equally \nimportant role.", "mimetype": "text/plain", "start_char_idx": 7515, "end_char_idx": 11990, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b5f5ead1-40b1-4335-90d9-e191cf130192": {"__data__": {"id_": "b5f5ead1-40b1-4335-90d9-e191cf130192", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1t3nyi1WM3mJyxb7am0hKhgL3IgrGAKwE", "node_type": "4", "metadata": {}, "hash": "eb0386bd4c2b207144d51f0ff964333123f877925ef3e3ad8d0f2b9fcd1bc4d8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50e0fb59-ded3-4db5-9c0e-e2774eacbfed", "node_type": "1", "metadata": {}, "hash": "ce83fa40770dc2ed192d87a257b03a97a58fad6a77fca398170dc64ae25a4a2a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 An enumerator is a Turing machine with an attached printer (output device)  \n\u2022 It prints (enumerates) strings of a language L possib ly in infinite sequence  \n\u2022 Strings may appear in any order, possibly with repetition  \n\u2022 There are different variations of Turing Machines, which are quite powerful and useful in several cases.  \n\u2022 We have a variation of the Turing machine called the Enumerator, whi ch plays a different but equally \nimportant role.  \n\u2022 In this type of machine, instead of simply determining whether a string is in a language, an enumerator \ngenerates or lists all the strings that belong to a language.  \n \nAn Enumerator  is similar to a Turing ma chine in structure but with a distinct purpose.  \n\u2022 Like a Turing machine, an enumerator has a tape that extends infinitely and a finite state control that \nguides its operations.  \n\u2022 The key difference is that an enumerator also has a  printer . \n\u2022 This printer allows the enumerator to produce strings, effectively generating a sequence of strings that \nmake up a language.  \n \n \n \nKey Characteristics of Enumerator Turing Machine  \n \n\u2022 Tape \u2212  The tape of an enumerator is initially empty, and unlike a standard Turing machine, there is no \ninput string provided to it.  \n\u2022 Finite State Control \u2212  The control unit of an enumerator functions similarly to that of a Turing machine, \nguiding the machine's operations based on its current state and the symbols on the tape.  \n\u2022 Printer \u2212  The printer is a unique feature of the enumerator, enabling it to output strings that belong to \nthe language it is enumerating.  \n\u2022 Operations \u2212 The operation of an enumerator is straightforward. It begins with an empty tape and \nproduces strings by writing them onto the tape and then printing them out. The enumerator lists all the \nstrings in a language, effectively defining that language through enumeration.  \n\u2022 Halting and Looping \u2212 An enumerator can either halt after producing a certain number of strings or it \nmay continue to loop indefinitely, generating more strings. For infinite la nguages an enumerator will run \nforever, printing out an endless list of strings.  \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    9 \n \n \nFormal Definition  \n \nAn enumerator is a Turing machine E that:  \n\u2022 Has no input  \n\u2022 Prints strings to an output tape  \n\u2022 The set of strings printed is L(E) \u2014 the language enumerated by E  \n \n \n \nReferences:  \n1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, \nLanguages, and Computation  (3rd ed.). Pearson Education. \u2014 Chapter 9: Introduction to Turing \nMachines (Sections on Turing Machines, Variants, and Unrestricted Grammars).  \n2. GeeksforGeeks. (n.d.). Turing Machine . Retrieved from https://www.geeksforgeeks.org/turing -\nmachine/  \n3. TutorialsPoi nt. (n.d.). Turing Machine . Retrieved from \nhttps://www.tutorialspoint.com/automata_theory/turing_machine.htm  \n \n    \n \n \n \n \n \n  \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1", "mimetype": "text/plain", "start_char_idx": 11538, "end_char_idx": 14789, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1f563a14-97b1-476b-bdca-6df43c08b366": {"__data__": {"id_": "1f563a14-97b1-476b-bdca-6df43c08b366", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9", "node_type": "4", "metadata": {}, "hash": "db7e6da0714fe30737fc23a8c181c856286e537edf3857190c31c6a62f6c7ab1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f359db91-4586-4829-8f61-06a133bd91d8", "node_type": "1", "metadata": {}, "hash": "8fd3007d196361a28fd0f32569f5678f0c8e2ba5c80bd2ffe37efc7be50bb6a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Grammars  \nProf. Riddhi Atulkumar Mehta  \nCSE, PIT  \nParul University  \n \n Study Guide  \n                      \n \n \n \n \n \n1. Context -free grammars (CFG) and languages (CFL), Chomsky normal forms ........... .............. 1 \n2. Non-deterministic pushdown automata  (PDA) and equivalence with CFG  \u2026\u2026\u2026\u2026\u2026 \u2026..\u2026.\u2026..2 \n3. Parse trees, ambiguity in CFG, pumping lemma for context -free languages \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. .2 \n4. Deterministic pushdown automata, closure properties of CFLs \u2026\u2026\u2026\u2026... \u2026\u2026\u2026\u2026\u2026 ..\u2026\u2026\u2026\u2026 \u2026.3 \n5. Context -sensitive languages: Context -sensitive grammars (CSG) and languages \u2026..\u2026\u2026\u2026\u2026 \u2026.4 \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1 \n \n3.1 Context -free grammars (CFG) and languages (CFL), \nChomsky normal forms  \nDefinition of CFG  \nA CFG is defined as a 4 -tuple:  \nG = (V, \u03a3, R, S)  \n \n\uf0b7 V \u2192 Set of variables (non -terminals)  \n\uf0b7 \u03a3 \u2192 Set of terminals  \n\uf0b7 R \u2192 Set of production rules (A \u2192 \u03b1)  \n\uf0b7 S \u2192 Start symbol (S \u2208 V) \nExample of CFG : \nGrammar G = ({S}, {a, b}, R, S) with:  \n\uf0b7 S \u2192 aSb | \u03b5  \nGenerates strings:  \n\uf0b7 \u0395 \n\uf0b7 Ab \n\uf0b7 Aabb  \n\uf0b7 Aaabbb  \n\uf0b7 \u2705 Language: L = { a\u207fb\u207f | n \u2265 0 }  \n \nDerivations in CFGs : \nLeftmost derivation:  Expand the leftmost  non-terminal  \nRightmost derivation:  Expand the rightmost  non-terminal  \nParse tree  visualizes the derivation  \nExample for S \u2192 aSb | \u03b5  \nDerivation for aaabbb:  \nS \u21d2 aSb \u21d2 aaSbb \u21d2 aaaSbbb \u21d2 aaabbb  \nAmbiguity in CFGs : \n\uf0b7 A grammar is ambiguous  if a string has more than one parse tree  \n\uf0b7 Ambiguity is undesirable in programming languages  \nExample:  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    2 \n \nGrammar:  \nS \u2192 S + S | S * S | a  \nString: a + a * a  \nTwo parse trees possible \u21d2 ambiguous  \nNormal Forms in CFGs  \n\uf0b7 Normal forms are restricted forms of CFGs used in algorithms like parsing and simplification.  \n\uf0b7 Two main types:  \n1. Chomsky Normal Form (CNF)  \n2. Greibach  Normal Form (GNF)  \nChomsky Normal Form (CNF) : \nEvery production is of the form:  \n1. A \u2192 BC (non -terminals only)  \n2. A \u2192 a (terminal only)  \n3. S \u2192 \u03b5 (if \u03b5 \u2208 L) \n \nRestrictions:  \n\uf0b7 B, C \u2208 V (non -terminals), B \u2260 start symbol  \n\uf0b7 a \u2208 \u03a3 (terminal)  \nSteps for CNF Conversion  \n1. Eliminate \u03f5\\epsilon \u03f5-productions (except possibly S\u2192 \u03f5S \\rightarrow \\epsilonS\u2192 \u03f5). \n2. Eliminate unit productions: A\u2192BA \\rightarrow BA\u2192B.  \n3. Eliminate useless symbols:  \n4. Non -generating symbols.  \n5. Non -reachable symbols.  \n6. Convert terminals in long rules to single -terminal productio ns. \n7. Break long right -hand sides into binary productions using new variables.  \n \n3.2 Non -deterministic Pushdown Automata (NPDA) and \nEquivalence with CFG  \nIntroduction  \n\uf0b7 What is a Pushdown Automaton (PDA)?  \n A PDA is a finite automaton equipped with a stack.  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    3 \n \n Used  to recognize context -free languages (CFLs).", "mimetype": "text/plain", "start_char_idx": 66, "end_char_idx": 3283, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f359db91-4586-4829-8f61-06a133bd91d8": {"__data__": {"id_": "f359db91-4586-4829-8f61-06a133bd91d8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9", "node_type": "4", "metadata": {}, "hash": "db7e6da0714fe30737fc23a8c181c856286e537edf3857190c31c6a62f6c7ab1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1f563a14-97b1-476b-bdca-6df43c08b366", "node_type": "1", "metadata": {}, "hash": "915b9d907ae94053f79f8b403032bd4946c73a10480c14752d1c9c269f7be570", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8a2238e7-e350-4289-a58b-c5e29689cb76", "node_type": "1", "metadata": {}, "hash": "5cda7d424855d2673632bd3dea93b4594abca58dbb44aa0b472c4c2f065b0484", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Eliminate \u03f5\\epsilon \u03f5-productions (except possibly S\u2192 \u03f5S \\rightarrow \\epsilonS\u2192 \u03f5). \n2. Eliminate unit productions: A\u2192BA \\rightarrow BA\u2192B.  \n3. Eliminate useless symbols:  \n4. Non -generating symbols.  \n5. Non -reachable symbols.  \n6. Convert terminals in long rules to single -terminal productio ns. \n7. Break long right -hand sides into binary productions using new variables.  \n \n3.2 Non -deterministic Pushdown Automata (NPDA) and \nEquivalence with CFG  \nIntroduction  \n\uf0b7 What is a Pushdown Automaton (PDA)?  \n A PDA is a finite automaton equipped with a stack.  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    3 \n \n Used  to recognize context -free languages (CFLs).  \n\uf0b7 Two types:  \n Deterministic PDA (DPDA)  \n Non -deterministic PDA (NPDA)  \nFormal Definition of NPDA : \nNPDA is a 7 -tuple:  \nM=(Q,\u03a3,\u0393,\u03b4,q0,Z0,F)   \nwhere:  \n\uf0b7 Q: set of states  \n\uf0b7 \u03a3: input alphabet  \n\uf0b7 \u0393: stack alphabet  \n\uf0b7 \u03b4: transition function  \n\uf0b7 q0: start state  \n\uf0b7 Z0: initial stack symbol  \n\uf0b7 F: set of accepting states  \nNPDA Transition Function  \n\ud835\udeff:\ud835\udc44\u00d7(\u03a3\u222a{\ud835\udf16})\u00d7\u0393\u2192\ud835\udc43(\ud835\udc44\u00d7\u0393\u2217) \nMeaning:  \n\uf0b7 Based on current state, input symbol (or \u03b5), and top of the stack.  \n\uf0b7 Can move to new states and update the stack.  \nExample of NPDA  \nDesign a non deterministic PDA for accepting the language L = {an bn | n>=1}, i.e.,  \nL = {ab, aabb, aaabbb, aaaabbbb, \u2026\u2026}  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    4 \n \n \nStack transition functions  \n\ud835\udf73 (q0, a, z)  \u251c (q0, az) [ push a on empty stack]  \n\ud835\udf73 (q0, a, a) \u251c (q0, aa) [push a \u2019s ] \n\ud835\udf73 (q0, b, a) \u251c (q1, \ud835\udf50  ) [pop a when b comes(state change)]  \n\ud835\udf73 (q1, b, a) \u251c (q1, \ud835\udf50 )  [pop a for each b]  \n\ud835\udf73 (q1, \ud835\udf50 , z) \u251c (qf, z)   [final state]  \n \nEquivalence to CFG  \n\uf0b7 CFG \u21d2 NPDA : For any CFG, construct an NPDA that simulates leftmost derivations.  \n\uf0b7 NPDA \u21d2 CFG: For any NPDA, construct a CFG by simulating transitions with grammar rules.  \nThus, CFL = Language accepted by NPDAs = Language generated by CFGs.  \n3.3 Parse Trees, Ambiguity in CFG, Pumping Lemma for \nCFLs  \nParse Tree  \n\uf0b7 A parse tree visually represents how  a string is derived from a CFG.  \n\uf0b7 Structure:  \n\uf0b7 Root: Start symbol  \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    5 \n \n\uf0b7 Internal nodes: Non -terminals (variables)  \n\uf0b7 Leaves: Terminals or \u03b5 (empty string)  \n\uf0b7 Reading the leaves from left to right gives the derived string.  \nDefinition:  \nGrammar:  \n\ud835\udc46\u2192\ud835\udc4e\ud835\udc46\ud835\udc4f \u2223 \ud835\udf00 S\u2192aSb \u2223 \u03b5 \nString: aabb  \nDerivation:  \n\ud835\udc46 \u21d2 \ud835\udc4e\ud835\udc46\ud835\udc4f \u21d2 \ud835\udc4e\ud835\udc4e\ud835\udc46\ud835\udc4f\ud835\udc4f  \u21d2 \ud835\udc4e\ud835\udc4e\ud835\udc4f \u21d2 \ud835\udc4e\ud835\udc4e\ud835\udc4f\ud835\udc4f  \n         S \n      / | \\ \n     a  S  b \n        /|\\ \n       a S b  \n          | \n          \u03b5 \nEach step replaces a non -terminal with its production.  \nAmbiguity in CFG : \n\uf0b7 A CFG is ambiguous  if there exists at least one string that has:  \n\uf0b7 More than one parse tree , or \n\uf0b7 More than one leftmost or rightmost derivation  \n\uf0b7 Ambiguity leads to confusion in interpretation, especially in compilers.", "mimetype": "text/plain", "start_char_idx": 2476, "end_char_idx": 5709, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8a2238e7-e350-4289-a58b-c5e29689cb76": {"__data__": {"id_": "8a2238e7-e350-4289-a58b-c5e29689cb76", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9", "node_type": "4", "metadata": {}, "hash": "db7e6da0714fe30737fc23a8c181c856286e537edf3857190c31c6a62f6c7ab1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f359db91-4586-4829-8f61-06a133bd91d8", "node_type": "1", "metadata": {}, "hash": "8fd3007d196361a28fd0f32569f5678f0c8e2ba5c80bd2ffe37efc7be50bb6a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27c38ba3-43d0-4408-91df-391f2ce25746", "node_type": "1", "metadata": {}, "hash": "af4829cf3acff07f6c6c2c31a6dc6171d588239c71967eb81bbf61e1a705d3a9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Ambiguity in CFG : \n\uf0b7 A CFG is ambiguous  if there exists at least one string that has:  \n\uf0b7 More than one parse tree , or \n\uf0b7 More than one leftmost or rightmost derivation  \n\uf0b7 Ambiguity leads to confusion in interpretation, especially in compilers.  \nPumping Lemma for CFLs  \n\uf0b7 Used to prove that a language is not context -free \n\uf0b7 For every context -free language L, there exists a constant p (pumping length) such that:  \nThen there is a pumping length n such that any string w \u03b5L of length>=n can be written as follows \u2212  \n|w|>=n  \nWe can break w into 5 strings, w=uvxyz, such as  the ones given below  \n\uf0b7 |vxy| >=n  \n\uf0b7 |vy| # \u03b5  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    6 \n \n\uf0b7 For all k>=0, the string uvkxyyz\u2208L \n3.4 Deterministic Pushdown Automata (DPDA), Closure \nProperties of CFLs  \nWhat is a DPDA?  \n\uf0b7 A pushdown automaton is a way to implement a context -free grammar in a similar way we design DFA \nfor a regular grammar.   \n\uf0b7 A DFA can remember a finite amount of information, but a PDA can remember an infinite amount of \ninformation.  \n\uf0b7 Basically a pushdown automaton is \u2212  \n\uf0b7 \"Finite state machine\" + \"a stack\"  \n\uf0b7 A pushdown automaton has three components \u2212  \n\uf0b7 an input tape,  \n\uf0b7 a control unit, and  \n\uf0b7 a stack with infinite size.  \n\uf0b7 The stack head scans the top symbol of the stack.  \n\uf0b7 A stack does two operations \u2212  \n\uf0b7 Push \u2212 a new symbol is added at the top.  \n\uf0b7 Pop \u2212 the top symbol is read and removed  \n \n \nFormal Definition:  \nA PDA can be  formally described as a 7 -tuple (Q, \u2211, S, \u03b4, q 0, I, F) \u2212  \n \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    7 \n \n\uf0b7 Q is the finite number of states  \n\uf0b7 \u2211 is input alphabet  \n\uf0b7 S is stack symbols  \n\uf0b7 is the transition function: Q \u00d7 (\u2211 \u222a {\u03b5}) \u00d7 S \u00d7 Q \u00d7 S*  \n\uf0b7 q0 is the initial state (q 0 \u2208 Q) \n\uf0b7 I is the initial stack top symbol (I \u2208 S) \n\uf0b7 F is a set of accepting states (F \u2208 Q) \nExample : \nConstruct a PDA that accepts L = {0n 1n | n \u2265 0}  \n \n\uf0b7 Initially we put a special symbol $ into the empty stack.  \n\uf0b7 Then at state q2, if we encounter input 0 and top is Null, we  push 0 into stack. This may iterate. And if we \nencounter input 1 and top is 0, we pop this 0.  \n\uf0b7 Then at state q3, if we encounter input 1 and top is 0, we pop this 0. This may also iterate. And if we \nencounter input 1 and top is 0, we pop the top element.  \n\uf0b7 If the special symbol $ is encountered at top of the stack, it is popped out and it finally goes to the \naccepting state q4.  \nConstruct a PDA that accepts L = { wwR | w = (a+b)* }  \n \n\uf0b7 Initially we put a special symbol $ into the empty stack.  \n\uf0b7  At state q2, the w  is being read.  \n\uf0b7 In state q3, each 0 or 1 is popped when it matches the input. If any other input is given, the PDA will go to \na dead state. When we reach that special symbol $, we go to the accepting state q4.  \n \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    8 \n \n \nDifference Between NPDA and DPDA  \n \nClosure  Properties  \nOperation  CFLs (NPDA)  DCFLs (DPDA)  \nUnion  \u2714 \u2718 \nConcatenation  \u2714 \u2718 \nKleene Star  \u2714 \u2718 \nIntersection  \u2718 \u2718 \nComplement  \u2718 \u2714 \nHomomorphism  \u2714 \u2714 \nInverse Homomorphism  \u2714 \u2714 \n \n3.5 Context -Sensitive Grammars (CSG) and Languages \n(CSL)  \nContext -Sensitive Languages (CSLs)  \nBefore we enter context -sensitive languages, it's essential to understand the context -free languages (CFLs), as \nthey form the foundation for our discussion.  \nWhat is Context -Free Grammar?", "mimetype": "text/plain", "start_char_idx": 5461, "end_char_idx": 9253, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "27c38ba3-43d0-4408-91df-391f2ce25746": {"__data__": {"id_": "27c38ba3-43d0-4408-91df-391f2ce25746", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1bXz7sOPBKMffadkn10eBX4rosgaafaR9", "node_type": "4", "metadata": {}, "hash": "db7e6da0714fe30737fc23a8c181c856286e537edf3857190c31c6a62f6c7ab1", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8a2238e7-e350-4289-a58b-c5e29689cb76", "node_type": "1", "metadata": {}, "hash": "5cda7d424855d2673632bd3dea93b4594abca58dbb44aa0b472c4c2f065b0484", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "When we reach that special symbol $, we go to the accepting state q4.  \n \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    8 \n \n \nDifference Between NPDA and DPDA  \n \nClosure  Properties  \nOperation  CFLs (NPDA)  DCFLs (DPDA)  \nUnion  \u2714 \u2718 \nConcatenation  \u2714 \u2718 \nKleene Star  \u2714 \u2718 \nIntersection  \u2718 \u2718 \nComplement  \u2718 \u2714 \nHomomorphism  \u2714 \u2714 \nInverse Homomorphism  \u2714 \u2714 \n \n3.5 Context -Sensitive Grammars (CSG) and Languages \n(CSL)  \nContext -Sensitive Languages (CSLs)  \nBefore we enter context -sensitive languages, it's essential to understand the context -free languages (CFLs), as \nthey form the foundation for our discussion.  \nWhat is Context -Free Grammar?  \nA context -free language is generated by a  context -free grammar  (CFG). In a CFG, production rules have the form: \nA \u2192 X, Where \u2212  \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    9 \n \n\uf0b7 A is a variable (non -terminal)  \n\uf0b7 X is any string of terminals or variables  \n \n\uf0b7 CSLs are languages generated by Context -Sensitive Grammars  \n\uf0b7 Can be recognized by Linear Bounded Au tomata (LBA)  \n\uf0b7 Proper superset of CFLs: CFL \u2282 CSL \n\uf0b7 Used to describe more complex syntax rules, like type agreement in natural language  \n\uf0b7 The context -sensitive languages extend the concept of CFLs by allowing production rules to depend on \nthe context in which variables appear.  \n\uf0b7 This seemingly small change leads to a significant increase in expressive power.  \n\uf0b7 A context -sensitive grammar has pr oduction rules of the form: \u03b1A\u03b2 \u2192 \u03b1X\u03b2, where \u2212  \n\uf0b7 \u03b1, \u03b2 are strings of terminals and/or variables (can be empty)  \n\uf0b7 A is a variable  \n\uf0b7 X is a non -empty string of terminals or variables  \n \nContext Sensitive Grammar  \nProper superset of CFL.  \nClosed under: union, intersect ion, concatenation, Kleene star, complement.  \nDifferences with Other Grammars : \n  \nGrammar Type  Example Language  Automaton  \nRegular  a\u2217 Finite Automaton  \nContext -Free (CFG)  a^nb^n  Pushdown Automaton  \nContext -Sensitive  A^nb^nc^n  Linear Bounded Automaton  \nRecursively Enumerable  All computable languages  Turing Machine  \n \n \n \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    10 \n \nReferences:  \n1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, \nLanguages, and Computation (3rd ed.). Pearson Education. \u2014 Chapter 5: Context -Free Grammars \nand Languages.  \n2. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). \u2014 Chapter 6: Pushdown Automata.  \n3. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). \u2014 Chapter 7: Properties of Context -Free \nLanguages.  \n4. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). \u2014 Chapter 9: Introduction to Turing \nMachines (Sections on Context -Sensitive Languages and Linear Bounded Automata).  \n5. GeeksforGeeks. (n.d.). Chomsky Normal Form (CNF) in Theory of Computation. Retrieved from \nhttps://www.geeksforgeeks.org/chomsky -normal -form/  \n6. GeeksforGeeks. (n.d.). Pumping Lemma for Context -Free Languages. Retrieved from \nhttps://www.geeksforgeeks.org/pumping -lemma -for-context -free-languages/  \n7. TutorialsPoint. (n.d.). Pushdown Automata. Retrieved from \nhttps://www.tutorialspoint.com/automata_t heory/pushdown_automata.htm  \n \n    \n \n \n \n \n \n  \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1", "mimetype": "text/plain", "start_char_idx": 8463, "end_char_idx": 12238, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4da78344-86da-40aa-af18-00f5db737fe0": {"__data__": {"id_": "4da78344-86da-40aa-af18-00f5db737fe0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4", "node_type": "4", "metadata": {}, "hash": "3496a81807420226245be3194c9571f38e589f17b0b7dfa3a64ad6d406066bb0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1e598a59-7f28-459e-8e30-c7a9c42fe6fb", "node_type": "1", "metadata": {}, "hash": "724806948b1f80e16dd3ada960f34e121cdeda9c0d23c5a09b96fd060763ba57", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Regular languages and \nfinite automata  \nProf. Riddhi Atulkumar Mehta  \nCSE, PIT  \nParul University  \n \n Study Guide  \n                      \n \n \n \n \n \n1. Regular expressions and languages ...\u2026\u2026\u2026\u2026...\u2026... ........................ ............................ .............. 1 \n2. Deterministic Finite Automata -(DFA) and equivalence with regular  expressions \u2026\u2026\u2026.\u2026.\u2026..2 \n3. Moore machines and mealy machines , Conversion from Mealy to Moore and vice versa  \u2026.2 \n4. Non-Deterministic Finite automata (NFA) and equivalence with DFA \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026.3 \n5. regular grammars and equivalence with finite  automata \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026.4 \n6. properties of regular languages, pumping  lemma for regular languages \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u20264  \n7. minimization of finite automata \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u20265  \n \n \n \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     1 \n \n2.1 Regular Expressions and Languages  Grammars  \nRegular Expressions  \nRegular expressions (REs) are symbolic notations used to represent regular languages . They are built using a \nfinite alphabet and operators.  \nPurpose:  \nTo specify regular languages, which are the simplest class in the Chomsky hierarchy.  \n \nSyntax:  \nGiven an alphabet \u03a3:  \n\uf0b7 \u2205 denotes the empty language  \n\uf0b7 \u03b5 denotes the empty string  \n\uf0b7 a \u2208 \u03a3 denotes the language {a}  \n\uf0b7 If r and s are regular expressions, then:  \no r + s denotes the union (alternation)  \no rs denotes concatenation  \no r* denotes the Kleene star (zero or more repetitions)  \nExample:  \nFor \u03a3 = {0, 1}, the RE 0*1*  represents all strings with all 0s followed by all 1s (e.g., \u03b5, 0, 1, 00011).  \nRegular Languages  \nA language is regular if it can be expressed using a regular expression  or accepted by a finite automaton.  \nExample:  \nR = (ab)*  \n\u2192 L(R) = {\u03b5, ab, abab, ababab, ...}  \nClosure Properties:  \nRegular languages are closed under:  \n  \nOperation  Explanation  \nUnion  L\u2081 \u222a L\u2082 is regular  \nConcatenation  L\u2081L\u2082 is regular  \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     2 \n \nKleene Star  L* is regular  \nComplementation  If L is regular, so is its complement  \nIntersection  L\u2081 \u2229 L\u2082 is regular  \nDifference  L\u2081 - L\u2082 is regular  \nApplications of Regular Expressions  \n\uf0b7 Text editors (search and replace)  \n\uf0b7 Lexical analyzers (tokenization in compilers)  \n\uf0b7 Pattern matching in programming (e.g., Python, JavaScript, grep)  \n\uf0b7 Validation (email, password formats)  \n \n2.2 Deterministic Finite Automata (DFA) and \nEquivalence with Regular Expressions  \nDeterministic Finite Automaton (DFA)  \nA DFA is a mathematical model for a machine that accept s regular languages with deterministic transitions.", "mimetype": "text/plain", "start_char_idx": 66, "end_char_idx": 2950, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1e598a59-7f28-459e-8e30-c7a9c42fe6fb": {"__data__": {"id_": "1e598a59-7f28-459e-8e30-c7a9c42fe6fb", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4", "node_type": "4", "metadata": {}, "hash": "3496a81807420226245be3194c9571f38e589f17b0b7dfa3a64ad6d406066bb0", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4da78344-86da-40aa-af18-00f5db737fe0", "node_type": "1", "metadata": {}, "hash": "47984a89a806d538249be5561a96ad881ad70fa35a5f984069df0d4d155175a0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9ad75fd1-8018-4764-b823-bf3c21acdd43", "node_type": "1", "metadata": {}, "hash": "63e269274f08a7b91419b5d78f597015c1dc9567312d927feaea0f27d233f399", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Formal Definition:  \nA DFA is a 5 -tuple (Q, \u03a3, \u03b4, q\u2080, F) where:  \n\uf0b7 Q: finite set of states  \n\uf0b7 \u03a3: input alphabet  \n\uf0b7 \u03b4: transition function, \u03b4: Q \u00d7 \u03a3 \u2192 Q  \n\uf0b7 q\u2080 \u2208 Q: start state  \n\uf0b7 F \u2286 Q: set of accepting (final) states  \nDFA Example  \nAlphabet: \u03a3 = {0, 1}  \nLanguage: Strings ending with '01\u2019  \nStates: Q = {q\u2080, q\u2081, q\u2082}  \nStart state: q\u2080  \nAccept state: q\u2082  \nTransitions:  \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     3 \n \n\u03b4(q\u2080, 0) = q\u2080  \n\u03b4(q\u2080, 1) = q\u2081  \n\u03b4(q\u2081, 0) = q\u2082  \n\u03b4(q\u2081, 1) = q\u2081  \n\u03b4(q\u2082, 0/1) = q\u2080 (or dead state)  \n \nDFA Example   \nDraw a DFA for the  language accepting strings starting with \u2018ab\u2019 over input alphabets \u2211 = {a, b}  \nRegular expression for the given language = ab(a + b)*  \n \n \nDFA Example  \nDraw a DFA for the language accepting strings starting with \u2018a\u2019 over input alphabets \u2211 = {a, b}  \n \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     4 \n \nRegular ex pression for the given language = a(a + b)*  \n \nEquivalence to Regular Expressions  \n\uf0b7 Kleene\u2019s Theorem : \no Every regular expression has an equivalent DFA.  \no Every DFA can be converted into an equivalent regular expression.  \nConversion Techniques:  \n1. RE to NFA (Thompson\u2019s Construction) \u2192 NFA to DFA  \n2. DFA to RE (State Elimination Method)  \n2.3 Moore and Mealy Machines  \nMoore Machine  \n\uf0b7 A finite state machine where output is associated with states . \nDefinition:  \nA 6-tuple (Q, \u03a3, \u0394, \u03b4, \u03bb, q\u2080), where:  \n\uf0b7 Q: set of states  \n\uf0b7 \u03a3: inpu t alphabet  \n\uf0b7 \u0394: output alphabet  \n\uf0b7 \u03b4: Q \u00d7 \u03a3 \u2192 Q (transition function)  \n\uf0b7 \u03bb: Q \u2192 \u0394 (output function)  \n\uf0b7 q\u2080 \u2208 Q: initial state  \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     5 \n \nOutput is produced on entry to the state.  \nMoore Machine \u2013 Example  \nDesign a Moore machine to generate 1\u2019s complement of a given binary number.  \n \n \nMealy Machine  \n\uf0b7 A finite state machine where output is associated with transitions . \nDefinition:  \nA 6-tuple (Q, \u03a3, \u0394, \u03b4, \u03bb, q\u2080), where:  \n\uf0b7 Q: set of states  \n\uf0b7 \u03a3: input alphabet  \n\uf0b7 \u0394: output alphabet  \n\uf0b7 \u03b4: Q \u00d7 \u03a3 \u2192 Q  \n\uf0b7 \u03bb: Q \u00d7 \u03a3 \u2192 \u0394  \nOutput is produced on reading the input symbol.  \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     6 \n \nMealy Machine \u2013 Example  \nDesign a Mealy machine to generate the first complement of any given binary input.  \n \n \nConversion Between Moore and Mealy  \nMealy \u2192 Moore:  \n\uf0b7 For each state/input/output pair, create a new Moore state.  \n\uf0b7 Adjust transitions to match  new states and outputs.  \nConversion: Mealy \u2192 Moore Example  \nConsider the following Mealy Machine  \n \n \nAs in the above Mealy Machine,  \n\uf0b7 q0 is the start state, (0,1) are inputs, and \u201ca\u201d is the output.  \n\uf0b7 Every entering input in the state q0 having the similar output  \u201ca\u201d. \n\uf0b7 So, simply cut the output \u201ca\u201d over the arrow and place it along with the state \u201cq0\u201d.  \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     7 \n \nMoore \u2192 Mealy:  \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     8 \n \nMoore vs Mealy \u2013 Comparison Table  \n \n2.4 Non -Deterministic Finite Automata (NFA) and \nEquivalence with DFA  \nNon -Deterministic Finite Automata (NFA)  \nNFAs allow multiple or zero transitions for a given input, including \u03b5 -transitions.  \nDefinition:  \nAn NFA is a 5 -tuple (Q, \u03a3, \u03b4, q\u2080, F), where:  \n\uf0b7 \u03b4: Q \u00d7 (\u03a3 \u222a {\u03b5}) \u2192 2^Q (can go to zero or more states)  \nAcceptance:  \nA string is accepted if at least one computation path ends in a final state.", "mimetype": "text/plain", "start_char_idx": 2953, "end_char_idx": 7118, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9ad75fd1-8018-4764-b823-bf3c21acdd43": {"__data__": {"id_": "9ad75fd1-8018-4764-b823-bf3c21acdd43", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4", "node_type": "4", "metadata": {}, "hash": "3496a81807420226245be3194c9571f38e589f17b0b7dfa3a64ad6d406066bb0", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1e598a59-7f28-459e-8e30-c7a9c42fe6fb", "node_type": "1", "metadata": {}, "hash": "724806948b1f80e16dd3ada960f34e121cdeda9c0d23c5a09b96fd060763ba57", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a0d72357-d55f-4b2b-a11f-763293803fb5", "node_type": "1", "metadata": {}, "hash": "ba0cee63b72a70527b0cf3f4b890ba72f7d245f66d7f5abf91edbe8b508172d7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "THEORY  OF COMPUTATION                                                                                                                                                     7 \n \nMoore \u2192 Mealy:  \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     8 \n \nMoore vs Mealy \u2013 Comparison Table  \n \n2.4 Non -Deterministic Finite Automata (NFA) and \nEquivalence with DFA  \nNon -Deterministic Finite Automata (NFA)  \nNFAs allow multiple or zero transitions for a given input, including \u03b5 -transitions.  \nDefinition:  \nAn NFA is a 5 -tuple (Q, \u03a3, \u03b4, q\u2080, F), where:  \n\uf0b7 \u03b4: Q \u00d7 (\u03a3 \u222a {\u03b5}) \u2192 2^Q (can go to zero or more states)  \nAcceptance:  \nA string is accepted if at least one computation path ends in a final state.  \nEquivalence with DFA  \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     9 \n \n\uf0b7 Subset Construction Algorithm  (also called powerset construction) is used to convert an NFA to an \nequivalent DFA.  \nExample:  \nNFA with \u2211 = {0, 1} accepts all strings with 01.  \n \n  \nPresent State  Next state for Input 0  Next State of Input 1  \n\u2192q0  q1 \u03b5 \nq1 \u03b5 q2 \n*q2 q2 q2 \n \nDesign an NFA with \u2211 = {0, 1} accepts all string ending with 01.  \n \n \n \nKey Point:  \nNFAs and DFAs recognize the same class of languages  (regular languages), but NFAs can be exponentially more \nsuccinct.  \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     10 \n \n2.5 Regular Grammars and Equivalence with Finite \nAutomata  \nRegular Grammar  \nA formal grammar with production rules that generate regular languages.  \nTypes:  \n\uf0b7 Right -linear : A \u2192 aB or A \u2192 a or A \u2192  \u03b5 \n\uf0b7 Left-linear : A \u2192 Ba or A \u2192 a or A \u2192 \u03b5  \nEquivalence with FA  \n\uf0b7 Every regular grammar can be converted to a finite automaton, and vice versa.  \n\uf0b7 The direction:  \no Grammar \u2192 FA : Create states for variables, transitions for productions.  \no FA \u2192 Grammar : States become variables, transitions become productions.  \nRegular Grammar \u27a1 Finite Automaton Example  \nEliminating Epsilon Productions: A Step -by-Step Approach:  \nS \u2192 a, aA | bB  \nA \u2192 aA | aS  \nB \u2192 cS  \nS \u2192 \u03b5  \nB \u2192 \u03b5  \n \nStep 1: Identifying Epsilon Productions  \nFirst, we identify the epsilon productions in our grammar. In this case, they are \u2212  \nS \u2192 \u03b5  \nB \u2192 \u03b5  \nStep 2: Generating Non -Epsilon Productions  \nWe list all the productions that do not involve epsilon. These are the productions that form the basis of our \nepsilon -free grammar \u2212  \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     11 \n \nS \u2192 a, aA | bB  \nA \u2192 aA | aS  \nB \u2192 cS  \nStep 3: Replacing Epsilon Productions  \nNow, we systematically replace all occurrences of non -terminals with epsilon productions in the right -hand sides \nof our productions.  \nIn 'A \u2192 aA | aS', replacing 'S' with '\u03b5' yields 'A \u2192 aA | \u03b5'. Since '\u03b5' is the empty string, we can simplify this to 'A \u2192 \naA'. \nIn 'B \u2192 cS', replacing 'S' with '\u03b5' yields 'B \u2192 c'.  \nIn 'S \u2192 aA | bB', replacing 'B' with '\u03b5' yields 'S \u2192 aA | b'.  \nThe final productions will be like,  \nS \u2192 a, aA | b  \nA \u2192 aA | aS | a   \nB \u2192 cS | c  \n \nStep 4: Handling the Start Symbol  \nThe start symbol 'S' has an epsilon production. This means that the start symbol can derive the empty string, \nwhich is often acceptable in finite automata.  \nHowever, if the start symbol has an epsilon production, we need to add a new start symbol ('S1' in our example) \nthat inherits all the productions of the original start symbol, including the epsilon production. This new start \nsymbol ensures that the empty string can be accepted by the automata.", "mimetype": "text/plain", "start_char_idx": 6261, "end_char_idx": 10267, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a0d72357-d55f-4b2b-a11f-763293803fb5": {"__data__": {"id_": "a0d72357-d55f-4b2b-a11f-763293803fb5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4", "node_type": "4", "metadata": {}, "hash": "3496a81807420226245be3194c9571f38e589f17b0b7dfa3a64ad6d406066bb0", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9ad75fd1-8018-4764-b823-bf3c21acdd43", "node_type": "1", "metadata": {}, "hash": "63e269274f08a7b91419b5d78f597015c1dc9567312d927feaea0f27d233f399", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a110e3ab-067d-47bf-8752-3d2dfdb29f8b", "node_type": "1", "metadata": {}, "hash": "05752280d4962b4724c9c335e9cb70299b6243767f1593bd7296e1b6dad0da5c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In 'B \u2192 cS', replacing 'S' with '\u03b5' yields 'B \u2192 c'.  \nIn 'S \u2192 aA | bB', replacing 'B' with '\u03b5' yields 'S \u2192 aA | b'.  \nThe final productions will be like,  \nS \u2192 a, aA | b  \nA \u2192 aA | aS | a   \nB \u2192 cS | c  \n \nStep 4: Handling the Start Symbol  \nThe start symbol 'S' has an epsilon production. This means that the start symbol can derive the empty string, \nwhich is often acceptable in finite automata.  \nHowever, if the start symbol has an epsilon production, we need to add a new start symbol ('S1' in our example) \nthat inherits all the productions of the original start symbol, including the epsilon production. This new start \nsymbol ensures that the empty string can be accepted by the automata.  \nS1 \u2192 a | aA | b | bB | \u03b5  \nS \u2192 a, aA | b  \nA \u2192 aA | aS | a  \nB \u2192 cS | c  \n \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     12 \n \n \nFinite Automaton \u27a1 Regular Grammar  \nSteps:  \nFor each transition from state A to B on input a, add production A \u2192 aB  \nFor each final state F, add production F \u2192 \u03b5  \n \nLet\u2019s consider a Finite automaton (FA) as given below \u2013 \n \nPick the start state A and output is on symbol \u2018a\u2019 going to state B  \n      A\u2192aB  \nNow we will pick state B and then we will go on each output  \n      i.e B\u2192aB  \n      B\u2192bB  \n      B\u2192\u03b5  \nTherefore,  \nFinal grammar is as follows \u2212  \n      A\u2192aB  \n      B\u2192aB/bB/\u03b5  \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     13 \n \n2.6 Properties of Regular Languages and Pumping \nLemma  \nProperties (Closure)  \nRegular languages are closed under:  \n\uf0b7 Union  \n\uf0b7 Concatenation  \n\uf0b7 Kleene Star  \n\uf0b7 Intersection  \n\uf0b7 Complement  \n\uf0b7 Difference  \n\uf0b7 Reversal  \nPumping Lemma  \nUsed to prove that a language is not regular . \nStatement:  \nFor any regular language L, there exists a constant p (pumping length), such that any string s \u2208 L with |s| \u2265 p can \nbe divided into:  \n\uf0b7 s = xyz  \no |xy| \u2264 p  \no |y| \u2265 1  \no \u2200i \u2265 0, xy\u2071z \u2208 L \nProof Technique:  \n\uf0b7 Assume L is regular.  \n\uf0b7 Let s \u2208 L, |s| \u2265 p.  \n\uf0b7 Show no division xyz satisfies the conditions \u2192 contradiction.  \n2.7 Minimization of Finite Automata  \nObjective:  \nTo reduce the number of states in a DFA while preserving its language.  \nSteps:  \n1. Remove Unreachable States  \n\uf0b7 Perform DFS/BFS from the initial state.  \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     14 \n \n2. Distinguish States Using Partitioning:  \n\uf0b7 Initially partition states into two sets: final and non -final.  \n\uf0b7 Iteratively refine the partition by distinguishing states with different future behavior.  \nExample:  \n \nStep -01: \nThe given DFA contains no dead states an d inaccessible states.  \n \nStep -02: \nDraw a state transition table - \na b  \n\u2192q0 q1 q2 \nq1 q1 q3 \nq2 q1 q2 \nq3 q1 *q4 \n*q4 q1 q2 \n \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     15 \n \nStep -03:  \nNow using Equivalence Theorem, we have - \nP0 = { q 0 , q1 , q2 , q3 } { q 4 } \nP1 = { q 0 , q1 , q2 } { q 3 } { q 4 } \nP2 = { q 0 , q2 } { q 1 } { q 3 } { q 4 } \nP3 = { q 0 , q2 } { q 1 } { q 3 } { q 4 } \n  \nSince P 3 = P 2, so we stop.  \nFrom P 3, we infer that states q 0 and q 2 are equivalent and can be merged together.  \n \n \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     16 \n \n \nReferences:  \n1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, \nand Computation  (3rd ed.). Pearson Education.", "mimetype": "text/plain", "start_char_idx": 9570, "end_char_idx": 13537, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a110e3ab-067d-47bf-8752-3d2dfdb29f8b": {"__data__": {"id_": "a110e3ab-067d-47bf-8752-3d2dfdb29f8b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1fceIuH1hhY9bcoUSi4nz9h21Ar8DuhM4", "node_type": "4", "metadata": {}, "hash": "3496a81807420226245be3194c9571f38e589f17b0b7dfa3a64ad6d406066bb0", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a0d72357-d55f-4b2b-a11f-763293803fb5", "node_type": "1", "metadata": {}, "hash": "ba0cee63b72a70527b0cf3f4b890ba72f7d245f66d7f5abf91edbe8b508172d7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "From P 3, we infer that states q 0 and q 2 are equivalent and can be merged together.  \n \n \n\n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     16 \n \n \nReferences:  \n1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, \nand Computation  (3rd ed.). Pearson Education. \u2014 Chapter 3: Regular Expressions and Languages.  \n2. TutorialsPoint. (n.d.). Formal Grammar and Language . Retrieved from \nhttps://www.tutorialspoint.com/automata_theory/formal_grammar.htm  \n3. GeeksforGeeks. (n.d.). Chomsky Hierarchy in Theory of Computation. \nhttps: //www.geeksforgeeks.org/chomsky -hierarchy/  \n4. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, \nand Computation . \u2014 Section on finite -state transducers (Moore and Mealy machines).  \n5. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). \u2014 Chapter 2: NFAs, \u03b5 -NFAs and DFA \nEquivalence.  \n6. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). \u2014 Chapter 3: Regular Grammars and their \nCorrespondence with Automata.  \n7.  Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). \u2014 Chapte r 4: DFA Minimization Algorithms \n(Table -Filling and Hopcroft's Algorithm).  \n    \n \n \n \n \n \n  \n \n \n \n   \n     THEORY  OF COMPUTATION                                                                                                                                                     1", "mimetype": "text/plain", "start_char_idx": 13090, "end_char_idx": 14631, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "09490052-257f-4dc4-a554-955adb5ad279": {"__data__": {"id_": "09490052-257f-4dc4-a554-955adb5ad279", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1QVRbvrNOHuzYH0CuDpjq3dgfL5dQ6jRL", "node_type": "4", "metadata": {}, "hash": "d6f179dcc8d53c813dbc25704b6b737028d427d7b31c989b98a00539bc2d4908", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "61938782-0715-4710-85a1-b61b46e205ae", "node_type": "1", "metadata": {}, "hash": "66d2103e898439a45459ec7cd3a36c52f4405ee3ca4f5e4b18da75df85665d1e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction   \nProf. Riddhi Atulkumar Mehta  \nCSE, PIT  \nParul University  \n \n Study Guide  \n                      \n \n \n \n \n \n1. Introduction to Alphabet, Languages, and \nGrammars ...\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026\u2026...\u2026... ........................ ............................ .............. 1 \n2. Productions and Derivation \u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026.\u2026.\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026 .\u2026..2 \n3. Chomsky Hierarchy of Languages \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 ..\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026. \u2026..\u2026\u20263 \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1 \n \n1.1 Introduction to Alphabet, Languages, and \nGrammars  \nAlphabet (\u03a3)  \n\uf0b7 An alphabet  is a finite set of symbols.  \n\uf0b7 Symbols are atomic units used to construct strings.  \n\uf0b7 Denoted by \u03a3 (capital Greek sigma).  \n\uf0b7 Examples:  \no \u03a3 = {0, 1} \u2192 Binary alphabet  \no \u03a3 = {a, b, c, ..., z} \u2192 Lowercase English letters  \no \u03a3 = {a, b} \u2192 Simple two -symbol alphabet  \nStrings  \n\uf0b7 A string  is a finite sequence of symbols from an alphabet.  \n\uf0b7 Length  of a string w is denoted by |w| . \n\uf0b7 Empty string:  \u03b5 (epsilon), with |\u03b5| = 0  \n\uf0b7 Example:  \no If \u03a3 = {a, b}, then:  \n\uf0a7 \u201cab\u201d, \u201caa\u201d, \u201cbba\u201d are strings.  \n\uf0a7 \u201cc\u201d is not a valid string over \u03a3.  \nLanguage (L)  \n\uf0b7 A language  is a set of strings formed from an alphabet.  \n\uf0b7 Formally: L \u2286 \u03a3* (Kleene star denotes all possi ble strings over \u03a3 including \u03b5)  \n\uf0b7 Examples:  \no L = {w \u2208 {0,1}* | w contains an even number of 0s}  \no L = {a\u207fb\u207f | n \u2265 1} \u2192 Strings like \u201cab\u201d, \u201caabb\u201d, \u201caaabbb\u201d  \nGrammar  \n\uf0b7 A formal grammar  is a system that describes how strings in a language can be generated.  \n\uf0b7 Defined as  a 4-tuple:  \nG = (V, \u03a3, P, S)  \nwhere:  \no V: A finite set of variables (non -terminal symbols)  \no \u03a3: A finite set of terminal symbols (alphabet), disjoint from V  \no P: A finite set of production rules  \no S: A special start symbol (S \u2208 V) \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    2 \n \n1.2 Productions and Derivation  \nProductions  \n\uf0b7 Also called rewrite rules . \n\uf0b7 Used to replace a variable with another variable or string.  \n\uf0b7 Format: A \u2192 \u03b1 , where:  \no A \u2208 V (non -terminal)  \no \u03b1 \u2208 (V \u222a \u03a3)* (string of terminals/non -terminals)  \n\uf0b7 Example:  \no A \u2192 aB  \no B \u2192 b  \nDerivation  \n\uf0b7 A derivation  is a sequence of ru le applications starting from the start symbol.  \n\uf0b7 Shows how strings in the language are generated.  \n\uf0b7 Written as:  \no S \u21d2 \u03b1\u2081 \u21d2 \u03b1\u2082 \u21d2 ... \u21d2 w, where w is a string in \u03a3*  \n\ud83d\udccc Leftmost Derivation  \n\uf0b7 In each step, replace the leftmost  non-terminal first.  \n\ud83d\udccc Rightmost Derivation  \n\uf0b7 In each step, replace the rightmost  non-terminal first.  \n\ud83c\udfaf Sentential Form  \n\uf0b7 A string derived from the start symbol, possibly containing both terminals and non -terminals.  \n\u2705 Example Derivation  \nGiven grammar:  \n\uf0b7 S \u2192 aSb | \u03b5  \nDerive \"aabb\":  \n\uf0b7 S \u21d2 aSb \u21d2 aaSbb \u21d2 aabb  \n \n \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    3 \n \n1.3 Chomsky Hierarchy of Languages  \nNoam Chomsky categorized formal languages into a hierarchy based on the complexity of their grammars \nand the computational machines that recognize them.", "mimetype": "text/plain", "start_char_idx": 66, "end_char_idx": 3454, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "61938782-0715-4710-85a1-b61b46e205ae": {"__data__": {"id_": "61938782-0715-4710-85a1-b61b46e205ae", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1QVRbvrNOHuzYH0CuDpjq3dgfL5dQ6jRL", "node_type": "4", "metadata": {}, "hash": "d6f179dcc8d53c813dbc25704b6b737028d427d7b31c989b98a00539bc2d4908", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "09490052-257f-4dc4-a554-955adb5ad279", "node_type": "1", "metadata": {}, "hash": "9e3bd30a887840a496265c6af04b382489d23b1856006d223cb7a5995912e82b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\ud83d\udccc Rightmost Derivation  \n\uf0b7 In each step, replace the rightmost  non-terminal first.  \n\ud83c\udfaf Sentential Form  \n\uf0b7 A string derived from the start symbol, possibly containing both terminals and non -terminals.  \n\u2705 Example Derivation  \nGiven grammar:  \n\uf0b7 S \u2192 aSb | \u03b5  \nDerive \"aabb\":  \n\uf0b7 S \u21d2 aSb \u21d2 aaSbb \u21d2 aabb  \n \n \n \n \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    3 \n \n1.3 Chomsky Hierarchy of Languages  \nNoam Chomsky categorized formal languages into a hierarchy based on the complexity of their grammars \nand the computational machines that recognize them.  \nType -0: Unrestricted Grammar  \n\uf0b7 Grammar rules:  \u03b1 \u2192 \u03b2 (where \u03b1 \u2260 \u03b5, \u03b1 and \u03b2 are strings with at least one non -terminal in \u03b1)  \n\uf0b7 Language class:  Recursively enumerable languages  \n\uf0b7 Recognized by:  Turing Machine  \n\uf0b7 Most general class  \u2013 no restriction on production rules  \nType -1: Context -Sensitive Grammar (CS G) \n\uf0b7 Grammar rules:  \u03b1A\u03b2 \u2192 \u03b1\u03b3\u03b2 (where |\u03b3| \u2265 1)  \n\uf0b7 A can be replaced by \u03b3 only when it appears in context \u03b1 and \u03b2.  \n\uf0b7 Language class:  Context -sensitive languages  \n\uf0b7 Recognized by:  Linear Bounded Automaton (LBA)  \n\uf0b7 Example language:  L = {a\u207fb\u207fc\u207f | n \u2265 1}  \nType -1: Context -Sensitive Grammar (CSG)  \n\uf0b7 Grammar rules:  \u03b1A\u03b2 \u2192 \u03b1\u03b3\u03b2 (where |\u03b3| \u2265 1)  \n\uf0b7 A can be replaced by \u03b3 only when it appears in context \u03b1 and \u03b2.  \n\uf0b7 Language class:  Context -sensitive languages  \n\uf0b7 Recognized by:  Linear Bounded Automaton (LBA)  \n\uf0b7 Example language:  L = {a\u207fb\u207fc\u207f | n \u2265 1}  \nType -3: Regular Grammar  \n\uf0b7 Grammar rules:  A \u2192 aB or A \u2192 a (Right -linear or Left -linear)  \n\uf0b7 Language class:  Regular languages  \n\uf0b7 Recognized by:  Finite Automaton (DFA/NFA)  \n\uf0b7 Simplest class , used in lexical analysis  \n\uf0b7 Example:  L = {a*b*}  \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    4 \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    5 \n \n \nReferences:  \n1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, \nLanguages, and Computation (3rd ed.). Pearson Education.  \n2. Chomsky, N. (1959). On Certain Formal Properties of Grammars. Information and Control, 2(2), \n137\u2013167. https://do i.org/10.1016/S0019 -9958(59)90362 -6 \n3. GeeksforGeeks. (n.d.). Chomsky Hierarchy in Theory of Computation . Retrieved May 10, 2025, \nfrom https://www.geeksforgeeks.org/chomsky -hierarchy/  \n4. TutorialsPoint. (n.d.). Formal Grammar and Language . Retrieved May 10, 2025, from \nhttps://www.tutorialspoint.com/automata_theory/formal_grammar.htm  \n5. Wikipedia contributors. (n.d.). Chomsky hierarchy . Wikipedia. Retrieved May 10, 2025, from \nhttps://en.wik ipedia.org/wiki/Chomsky_hierarchy  \n \n    \n \n \n \n \n \n  \n \n \n \n   \n     THEORY OF COMPUTATIO N                                                                                                                                                    1", "mimetype": "text/plain", "start_char_idx": 2761, "end_char_idx": 5979, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ce1e20f1-b556-48b8-bf4b-6a41824a09b6": {"__data__": {"id_": "ce1e20f1-b556-48b8-bf4b-6a41824a09b6", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1t1piaiKQMfJFypnF7GJmbonCIqXMqaPK", "node_type": "4", "metadata": {}, "hash": "c3a3d532b3c3875b5ab8275577d8fce03d188c8bbd15c81d19279efb78a467d0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nUnrestricted Grammars & Turing\nMachine Equivalence\nChapter 4: Turing machines\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Unrestricted Grammar\u2026\u2026\u2026..\u2026\u2026\u2026.\u2026\u2026\u2026.....  1\n2. Equivalence of Unrestricted Grammars and\nTuring Machines\u2026\u2026\u2026\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026........  2\n3. Direction 1 \u2013 Grammar \u21d2TM  \u2026\u2026.\u2026\u2026\u2026\u2026\u2026  3\n4. Direction 2 \u2013 TM \u21d2Grammar\u2026\u2026\u2026\u2026\u2026.\u2026\u2026.   4ContentINDEX\nUnrestricted Grammar\n\u007fUnrestricted grammar is a type of formal grammar that is defined without any\nrestrictions on the form of its production rules.\n\u007fFormally, a grammar G=( VN,\u03a3,P ,S ) is called an unrestricted grammar if all its\nproductions are in the form LS\u2192RS, where LSis a string of non-terminal and terminal\nsymbols, and RSis a string of non-terminal and terminal symbols or the empty string.\n\u007fThis form of grammar is known as Type 0 grammar in the Chomsky hierarchy , and it is\nthe most general form of grammar.\nUnrestricted Grammar\n\nUnrestricted Grammar\n\u007fThe lack of restrictions allows for a more flexible and powerful method of string\ngeneration, which leads to the capabilities of a Turing machine.\n\u007fEvery language that can be generated by an unrestricted grammar can be recognized\nby a Turing machine, and vice versa.\n\u007fThis states the idea that the set of languages generated by unrestricted grammar is\nequivalent to the set of recursively enumerable languages.\nUnrestricted Grammar\nAnunrestricted grammar (Type-0) is a 4-tuple:\nG = (V, \u03a3, R, S) where:\n\u007fV: Variables (non-terminals)\n\u007f\u03a3: Terminals\n\u007fR: Rules of the form \u03b1 \u2192 \u03b2, where:\n\u007f\u03b1\u2208(V\u222a\u03a3)^+ ( \u03b1 \u2260 \u03b5)\n\u007f\u03b2\u2208(V\u222a\u03a3)^*\n\u007fS: Start symbol\nEquivalence of Unrestricted Grammars and Turing Machines\n\u007fTheorem: A language is generated by an unrestricted grammar if and only if it is\nrecursively enumerable (i.e., it is semidecided by some Turing machine M).\n\u007fProof:\n\u007fOnly if (grammar \u2192TM): by construction of a nondeterministic Turing machine.\n\u007fIf (TM \u2192grammar): by construction of a grammar that mimics backward\ncomputations of M.\nDirection 1 \u2013 Grammar \u21d2TM\nGiven an unrestricted grammar G, we can construct a TM Msuch that:\n\u007fM simulates leftmost derivation of G on input string w\n\u007fIf derivation leads to w, M accepts\nMethod:\n\u007fEncode derivations on the TM tape\n\u007fSimulate rule application step-by-step\nDirection 2 \u2013 TM \u21d2Grammar\nGiven a TM M, we can construct an unrestricted grammar G such that:\n\u007fG generates all strings accepted by M\nIdea:\n\u007fSimulate TM configurations as strings\n\u007fUse productions to mimic TM transitions", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2508, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "44995939-02e6-4575-a6df-fc734ec4609b": {"__data__": {"id_": "44995939-02e6-4575-a6df-fc734ec4609b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1CBP3gQl7LyYFBjWz7F-hqDqiW4JPic5s", "node_type": "4", "metadata": {}, "hash": "5f473b125027cafec6efb56011fe8dfc7f7163ff1648f6631b2804edcc5530df", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nChurch Turing thesis\nChapter 5: Undecidability\nProf. Riddhi Atulkumar Mehta \nAssistant Professor \nDepartment of Computer Science and \nEngineering\n1.Learning Goals  \u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 1\n2.Introduction\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2\n3.Historical Background\u2026\u2026.\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026.. 3\n4.The Church -Turing Thesis  \u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 4\n5.Formal Models of Computation \u2026\u2026\u2026\u2026\u2026\u2026.. 5\n6.Turing Machine\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026\u2026....  6\n7.\u03bb-Calculus \u2013A Functional Perspective\u2026\u2026\u2026.. 7\n8.What Does \u201cComputable\u201d Mean? \u2026\u2026\u2026\u2026\u2026.. 8\n9.Implications of the Thesis \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 9\n10.Strong Church -Turing Thesis\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.10\n11.Quantum Church -Turing Thesis\u2026\u2026\u2026\u2026\u2026\u2026\u2026.11Content INDEX\nLearning Goals\n\u2022Understand what the Church -Turing Thesis asserts\n\u2022Explore multiple models of computation\n\u2022Learn historical developments that led to the thesis\n\u2022Appreciate the philosophical and theoretical implications\n\u2022Recognize its limits and open questions\nIntroduction\n\u2022What is a computation? What does it mean to \u201ccompute\u201d a function?\n\u2022Informally, computation involves step -by-step execution of a finite procedure \n(algorithm) to solve a problem.\n\u2022Church -Turing Thesis provides a formal answer to what is computable.\nHistorical Background\n\u2022Alonzo Church (1936 ):Introduced \u03bb-calculus ,aformal system for expressing\ncomputation viafunction abstraction and application .\n\u2022Alan Turing (1936 ):Independently developed the Turing Machine ,atheoretical\nmachine tomodel algorithmic processes .\n\u2022Both proved the same class ofcomputable functions \u2014leading tothe Church -Turing\nThesis .\nThe Church -Turing Thesis\n\u2022\u201cA function is effectively computable if and only if it is computable by a Turing \nmachine.\u201d\n\u2022\u201cEffectively computable\u201d = can be computed by a human or machine using an \nalgorithm, without intuition or guesswork.\n\u2022The thesis is not a formal theorem, but a philosophical hypothesis supported by \noverwhelming evidence.\nFormal Models of Computation\nModel Inventor Year Description\nTuring Machine Alan Turing 1936Machine with infinite \ntape and head for \nreading/writing \nsymbols\n\u03bb-Calculus Alonzo Church 1936Formal system based \non variable binding \nand substitution\nRecursive Functions G\u00f6del/Kleene 1930sFunctions built using \nbasic operations and \nrecursion\nPost Systems Emil Post 1943Production rules on \nstrings (rewriting \nsystems)\nTuring Machine\n\u2022A Turing Machine is a mathematical model of computation that operates on an \ninfinite tape with a finite set of rules.\n\u2022Capable of simulating any algorithm.\n\u2022Forms the basis of modern computing models.\n\u03bb-Calculus \u2013A Functional Perspective\n\u2022Uses variable binding and substitution.\n\u2022Core operations: abstraction (functions), application (function calls).\n\u2022Foundation for many functional programming languages (e.g., Lisp, Haskell).\nWhat Does \u201cComputable\u201d Mean?\n\u2022A function f: N\u2192N is computable if there exists an algorithm (or TM) that produces \nf(n)  for every input n.\n\u2022Example :\n\u2022Computable: Addition, multiplication, sorting\n\u2022Non-computable: Halting problem, truth of arbitrary mathematical statements\nImplications of the Thesis\n\u2022Defines the boundary of what can be computed using any physical device or \nalgorithm.\n\u2022Provides a unified model of computation used in:\n\u2022Programming language theory\n\u2022Complexity theory\n\u2022Logic and formal verification\nStrong Church -Turing Thesis\n\u201cAny reasonable model of computation can be efficiently simulated by a Turing \nmachine.\u201d\n\u2022Focuses not only on computability but also efficiency (time/space) .\n\u2022Forms the basis of complexity theory (P, NP, etc.)\nQuantum Church -Turing Thesis\n\u2022Proposes that any physically realizable computational process can be efficiently \nsimulated by a quantum computer .\n\u2022Still under investigation.\n\u2022Shor\u2019s algorithm (factoring) suggests quantum computers can outperform classical \nTMs in some tasks.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3786, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f57885be-126e-44d5-a179-1566c7e5fd2f": {"__data__": {"id_": "f57885be-126e-44d5-a179-1566c7e5fd2f", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "10J2vVm2LE41eftDu5yK7q2V0RU7E5S-Q", "node_type": "4", "metadata": {}, "hash": "1ee1d6a2a80358f1c12290dc8e89cdf8159139baddb56f902bb57850b17c7e90", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nThe Universal and Diagonalization\nLanguages\nChapter 5: Undecidability\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Learning Objectives\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 1\n2. The Universal Language \ud835\udc3f\ud835\udc62\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2\n3. Properties of \ud835\udc3f\ud835\udc62........\u2026\u2026.\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026.. 3\n4. Diagonalization Language \ud835\udc3f\ud835\udc51\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..4\n5. Diagonalization: The Idea \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.5\n6. Summary of Languages \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 6\n7. Applications \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 7ContentINDEX\nLearning Objectives\nBy the end of this lecture, you should be able to:\n\u007fDefine the universal language \ud835\udc3f\ud835\udc62L u\n\u007fDefine the diagonalization language \ud835\udc3f\ud835\udc51L d\n\u007fUnderstand the concepts of encoding, simulation, and self-reference\n\u007fUse diagonalization to prove undecidability\nThe Universal Language \ud835\udc3f\ud835\udc62\nDefinition :\n\u007fLu={ \u27e8M,w \u27e9\u2223M is a TM and M accepts w}\n\u007fIt contains all encodings of TMs and inputs such that the machine accepts the input.\n\u007fCaptures the behavior of any TM on any input.\nProperties of \ud835\udc3f\ud835\udc62\n\u007fRecursively Enumerable (RE) :\nThere exists a TM (UTM) that accepts all strings in Lu\n\u007fNot Recursive (Decidable) :\nThere is no TM that can decide for every input whether it\u2019s in Lu .\nThe Halting Problem is reducible to Lu\nDiagonalization Language \ud835\udc3f\ud835\udc51\nDefinition :\n\u007fLd={ \u27e8M\u27e9\u2223M is a TM and M does not accept \u27e8M\u27e9}\n\u007fThink of M being run on its own description .\n\u007fLd contains all TMs that do NOT accept themselves .\nDiagonalization: The Idea\n\u007fInspired by Cantor\u2019s diagonal argument\n\u007fShow that Ld  is not recursively enumerable (not RE)\n\u007fSuppose Ld  is RE\n\u007fThere is a TM D accepting it\n\u007fAsk: Does D accept \u27e8D\u27e9?\n\u007fLeads to contradiction\nSummary of Languages\n\nApplications\nForms the basis for:\n\u007fThe Halting Problem\n\u007fRice\u2019s Theorem\n\u007fProving undecidability of other decision problems\n\u007fFoundational for complexity theory and logic", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1818, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "dfe652ad-fd39-47e1-99cb-eae8e0398d5b": {"__data__": {"id_": "dfe652ad-fd39-47e1-99cb-eae8e0398d5b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1_anc6tvWYiW_riht29MJIE7A8RFTlgG3", "node_type": "4", "metadata": {}, "hash": "352c88ab0fba1e15bae9cf798689dabb4768cdcb7de3199ae0c4aa27f1de8cff", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nUniversal Turing Machine\nChapter 5: Undecidability\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Universal Turing Machine\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 1\n2. Implications of the term \"Universal\u201c \u2026\u2026\u2026\u2026 2\n3. How Does a Universal Turing Machine\nWork?........................\u2026\u2026.\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026.. 3ContentINDEX\nUniversal Turing Machine\n\u007fA Universal Turing Machine is a theoretical model that can simulate any other Turing\nmachine. Which is little complicated but we will see how it actually works.\n\u007fIf we think about a regular Turing machine as a device built to perform one specific\ntask. So, for example, we might have a Turing machine to add two numbers together\nor check if a word is a palindrome or not. These machines are task-specific; they do\none thing and do it well.\n\u007fOn the other hand, a Universal Turing Machine can perform any task that a regular\nTuring machine can do. By taking a description of that machine (let us call it M) and\nthe input for that machine (let us call it X). The Universal Turing Machine, which we\nwill denote as U, processes M and X and then outputs the result of M operating on X.\nUniversal Turing Machine\n\u007fThe functional block diagram of the machine looks like this \u2013\n\nImplications of the term \"Universal\"\n\u007fThe term \"universal\" states the machine's ability to simulate any other Turing\nmachine. Like having a single device that can mimic all other devices, just by changing\nthe instructions it follows.\n\u007fIt is similar to our modern days' computer, it can run a word processor, a web\nbrowser, or even a game, all because it can take the code (which is just instructions)\nfor these programs and execute it. The computer, in this way, is a practical example of\na Universal Turing Machine.\nHow Does a Universal Turing Machine Work?\nTo understand how a Universal Turing Machine works, let us break down its process:\n\u007fInputs \u2212The Universal Turing Machine takes two inputs:\n\u007fA description of another Turing machine (M),\n\u007fThe input that this machine should process (X).\n\u007fProcessing \u2212The Universal Turing Machine reads the description of M and interprets\nit as a set of instructions.\n\u007fSimulation \u2212Using these instructions, the Universal Turing Machine simulates the\noperations of M on the input X.\n\u007fOutput \u2212The result of this simulation is what M would produce when given X as input.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2377, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8a53ca2a-c442-4007-bcca-3be344f55bfc": {"__data__": {"id_": "8a53ca2a-c442-4007-bcca-3be344f55bfc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "17HMsm94p5WZC3m1TeEDvbLJoaBWeXALS", "node_type": "4", "metadata": {}, "hash": "8ccd05824d5b76940e3a1d3d48537187930e3f171d5ebe277e97fc5efb7d8236", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nTuring Machines as Enumerators\nChapter 4: Turing machines\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Objective\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 1\n2. What is an Enumerator? \u2026\u2026..\u2026\u2026\u2026.\u2026\u2026\u2026..... 2\n3. Key Characteristics of Enumerator Turing\nMachine\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026........  3\n4. Formal Definition \u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026.\u2026\u2026\u2026\u2026\u2026  4\n5. Language Enumerated by a TM\u2026\u2026\u2026\u2026.\u2026\u2026\u2026 5\n6. Theorem: A Language is Turing-Recognizable\n\u21d4It is Enumerable\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 6\n7. Summary \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 7ContentINDEX\nObjectives\n\u007fUnderstand the concept of a Turing machine as an enumerator\n\u007fDefine enumerable languages\n\u007fShow the equivalence between enumerability and recognizability\n\u007fPresent an example of an enumerator in action\nWhat is an Enumerator?\n\u007fAn enumerator is a Turing machine with an attached printer (output device)\n\u007fIt prints (enumerates) strings of a language L possibly in infinite sequence\n\u007fStrings may appear in any order, possibly with repetition\n\u007fThere are different variations of Turing Machines, which are quite powerful and useful\nin several cases.\n\u007fWe have a variation of the Turing machine called the Enumerator, which plays a\ndifferent but equally important role.\n\u007fIn this type of machine, instead of simply determining whether a string is in a\nlanguage, an enumerator generates or lists all the strings that belong to a language.\nWhat is an Enumerator?\nAnEnumerator is similar to a Turing machine in structure but with a distinct purpose.\n\u007fLike a Turing machine, an enumerator has a tape that extends infinitely and a finite\nstate control that guides its operations.\n\u007fThe key difference is that an enumerator also has a printer .\n\u007fThis printer allows the enumerator to produce strings, effectively generating a\nsequence of strings that make up a language.\n\nKey Characteristics of Enumerator Turing Machine\n\u007fTape \u2212The tape of an enumerator is initially empty, and unlike a standard Turing\nmachine, there is no input string provided to it.\n\u007fFinite State Control \u2212The control unit of an enumerator functions similarly to that of\na Turing machine, guiding the machine's operations based on its current state and the\nsymbols on the tape.\n\u007fPrinter \u2212The printer is a unique feature of the enumerator, enabling it to output\nstrings that belong to the language it is enumerating.\nKey Characteristics of Enumerator Turing Machine\n\u007fOperations \u2212The operation of an enumerator is straightforward. It begins with an\nempty tape and produces strings by writing them onto the tape and then printing\nthem out. The enumerator lists all the strings in a language, effectively defining that\nlanguage through enumeration.\n\u007fHalting and Looping \u2212An enumerator can either halt after producing a certain\nnumber of strings or it may continue to loop indefinitely, generating more strings. For\ninfinite languages an enumerator will run forever, printing out an endless list of\nstrings.\nFormal Definition\nAn enumerator is a Turing machine E that:\n\u007fHas no input\n\u007fPrints strings to an output tape\n\u007fThe set of strings printed is L(E) \u2014 the language enumerated by E\nLanguage Enumerated by a TM\nA language L is called Turing-enumerable or recursively enumerable (RE) if:\nThere exists a Turing machine enumerator E such that:\nL = { w | w is printed by E }\nTheorem: A Language is Turing-Recognizable \u21d4It is Enumerable\n\u007fEvery recognizable language can be enumerated by some TM\n\u007fEvery enumerator defines a recognizable language\nSummary\n\u007fEnumerators are output-producing Turing machines\n\u007fEvery RE language can be enumerated\n\u007fEnumeration and recognition are equivalent for RE languages\n\u007fCrucial in formal language and computability theory", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3674, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3d65d9ab-0a0c-490b-adf7-4d4d6f71eaa8": {"__data__": {"id_": "3d65d9ab-0a0c-490b-adf7-4d4d6f71eaa8", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1djsyCOgYW8lqSoHC1pF0EVROt3dchlVu", "node_type": "4", "metadata": {}, "hash": "8d570453c142fc44205c6c33b282929720b772055b214397a2325b556b58c465", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nVariants of Turing Machines &\nNondeterminism\nChapter 4: Turing machines\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Variations of Turing Machine\u2026\u2026\u2026.\u2026\u2026\u2026.....  1\n2. Multi-tape Turing Machine\u2026.\u2026\u2026\u2026\u2026\u2026\u2026........  2\n3. Multi-head Turing Machine\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026  3\n4. Two-way Infinite Tape Turing Machine\u2026\u2026.   4\n5. K-dimensional Turing Machine\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 5\n6. Enumerator Turing Machine\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 6\n7. Non-deterministic Turing Machine\u2026\u2026\u2026\u2026\u2026. 7ContentINDEX\nVariations of Turing Machine\n\u007fTuring machines are powerful computational models that can simulate any\nalgorithmic process.\n\u007fA standard Turing machine consists of a single tape and a single read-write head.\nHowever, there are variations of Turing machine that have been developed to address\ndifferent computational challenges.\n\u007fThese variations differ mainly in structure and operation, but they all have the same\ncomputational power as the standard Turing machine.\nMulti-tape Turing Machine\n\u007fAs the name suggests, a multi-tape Turing machine is an extension of the standard\nTuring machine where multiple tapes are available for input, output, and\ncomputation.\n\u007fEach tape has its own read-write head, and the machine's transition function is based\non the current state and the symbols read by each head.\n\nMulti-head Turing Machine\n\u007fIn a multi-head Turing machine, a single tape is used, but it has multiple read-write\nheads.\n\u007fThese heads can independently read and write symbols, enabling the machine to\nperform complex tasks more efficiently.\n\nTwo-way Infinite Tape Turing Machine\n\u007fA two-way infinite tape Turing machine allows the tape to extend infinitely in both\ndirections, unlike the standard machine where the tape extends infinitely in only one\ndirection.\n\u007fThis removes the boundary on the left side of the tape.\n\nK-dimensional Turing Machine\n\u007fA K-dimensional Turing machine extends the concept of the tape to multiple\ndimensions.\n\u007fFor example, a two-dimensional Turing machine as given in the following diagram, has\na tape that extends infinitely in both the X and Y directions.\n\nEnumerator Turing Machine\n\u007fAn enumerator Turing machine is designed to generate strings of a language. It is\nequipped with a work tape and an output tape.\n\u007fThe machine writes symbols to the output tape, which is then printed.\n\nEnumerator Turing Machine\n\u007fThe enumerator repeatedly writes symbols on the output tape based on its transition\nfunctions.\n\u007fOnce a string is completed, it is printed, and the machine resets to generate the next\nstring.\n\u007fThis type of Turing machine is useful for tasks where the goal is to list all valid strings\nof a language, such as generating all possible solutions to a problem.\nNon-deterministic Turing Machine\n\u007fIn a Non-Deterministic Turing Machine, for every state and symbol, there are a group\nof actions the TM can have.\n\u007fSo, here the transitions are not deterministic. The computation of a non-deterministic\nTuring Machine is a tree of configurations that can be reached from the start\nconfiguration.\n\u007fAn input is accepted if there is at least one node of the tree which is an accept\nconfiguration, otherwise it is not accepted.\n\u007fIf all branches of the computational tree halt on all inputs, the non-deterministic\nTuring Machine is called a Decider and if for some input, all branches are rejected, the\ninput is also rejected.\nNon-deterministic Turing Machine\nA non-deterministic Turing machine can be formally defined as a 6-tuple (Q, X, \u2211, \u03b4, q0, B,\nF) where \u2212\n\u007fQis a finite set of states\n\u007fXis the tape alphabet\n\u007f\u2211is the input alphabet\n\u007f\u03b4is a transition function;\n\u007f\u03b4: Q \u00d7 X \u2192P(Q \u00d7 X \u00d7 {Left_shift, Right_shift}).\n\u007fq0is the initial state\n\u007fBis the blank symbol\n\u007fFis the set of final states", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3744, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e07d455d-f870-4add-bc90-49e60edc18bc": {"__data__": {"id_": "e07d455d-f870-4add-bc90-49e60edc18bc", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1RXuqgHQTCBMWEIRDb_TQdLegEyLPOCn4", "node_type": "4", "metadata": {}, "hash": "94f052acd618ead900f15797be6f61563fd1523c74dfa8bdc08351cad96c6eb9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nTuring-Recognizable and Turing-\nDecidable Languages\nChapter 4: Turing machines\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Recursively Enumerable languages.\u2026\u2026\u2026.....  1\n2. Recursive Language (REC)\u2026.\u2026\u2026\u2026\u2026\u2026\u2026........  2\n3. Recognizable vs Decidable\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  3\n4. Closure Properties: Turing-Decidable\nLanguages\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026.   4\n5. Closure Properties: Turing-Recognizable\nLanguages\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.. 5ContentINDEX\nRecursively Enumerable languages\n\u007fIf any Turing Machine can be designed to accept all string of the given language, then\nthe language is called recursively enumerable language.\n\u007fRecursively enumerable languages are the formal languages that can be decide-able,\n(fully or partially).\n\u007fAccording to the Chomsky hierarchy of formal languages, we can see the recursively\nenumerable languages as type 0 languages.\n\u007fAn RE language can be accepted or recognized by Turing machine which means it will\nenter into final state for the strings of language and may or may not enter into\nrejecting state for the strings which are not part of the language.\n\u007fIt means TM can loop forever for the strings which are not a part of the language. RE\nlanguages are also called as Turing recognizable languages.\nRecursive Language (REC)\n\u007fA recursive language (subset of RE) can be decided by Turing machine which means it\nwill enter into final state for the strings of language and rejecting state for the strings\nwhich are not part of the language.\n\u007fe.g.; L= {anbncn|n>=1} is recursive because we can construct a turing machine which\nwill move to final state if the string is of the form anbncnelse move to non-final state.\n\u007fSo the TM will always halt in this case. REC languages are also called as Turing\ndecidable languages.\n\nRecognizable vs Decidable\nTuring-Decidable\n(Recursive)Turing-Recognizable (RE) Feature\nYes No Halts on all inputs?\nYes Yes Accepts members?\nYes Not guaranteed Rejects non-members?\nPalindromes (Decidable) Halting problem (RE) Example\nClosure Properties: Turing-Decidable Languages\nClosed under:\n\u007fUnion\n\u007fIntersection\n\u007fComplement\n\u007fConcatenation\n\u007fKleene star\nClosure Properties: Turing-Recognizable Languages\nClosed under:\n\u007fUnion\n\u007fIntersection\n\u007fConcatenation\n\u007fKleene star\nNot closed under: Complement", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2317, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c7ab5284-206c-48c0-bc63-27fbf8952a65": {"__data__": {"id_": "c7ab5284-206c-48c0-bc63-27fbf8952a65", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "16bWDrtClrCDT-CzkoFfFFsrdjijKrg4H", "node_type": "4", "metadata": {}, "hash": "3d672810af2658df6d445530c2aaff90d1df76d00ce4003144dd58600cc51b02", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nThe basic model for Turing machines\n(TM)\nChapter 4: Turing machines\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Turing Machine\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026.....  1\n2. Definition of a Turing Machine\u2026\u2026\u2026\u2026\u2026\u2026..... 2\n3. Tape and Head..\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  3\n4. TM vs Finite Automata\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026.   4ContentINDEX\nTuring Machine\n\u007fA Turing Machine is an accepting device which accepts the languages (recursively\nenumerable set) generated by type 0 grammars. It was invented in 1936 by Alan\nTuring.\n\u007fTuring Machines (TM) play a crucial role in the Theory of Computation (TOC). They are\nabstract computational devices used to explore the limits of what can be computed.\n\u007fTuring Machines help prove that certain languages and problems have no algorithmic\nsolution.\n\u007fA Turing Machine (TM) is a mathematical model which consists of an infinite length\ntape divided into cells on which input is given.\n\u007fIt consists of a head which reads the input tape. A state register stores the state of the\nTuring machine..\nTuring Machine\n\u007fAfter reading an input symbol, it is replaced with another symbol, its internal state is\nchanged, and it moves from one cell to the right or left.\n\u007fIf the TM reaches the final state, the input string is accepted, otherwise rejected.\n\u007fIn the context of automata theory and the theory of computation, Turing machines\nare used to study the properties of algorithms and to determine what problems can\nand cannot be solved by computers.\n\u007fThey provide a way to model the behavior of algorithms and to analyze their\ncomputational complexity, which is the amount of time and memory they require to\nsolve a problem.\n\u007fA TM can be formally described as a 7-tuple (Q, X, \u2211, \u03b4, q0, B, F)\nDefinition of a Turing Machine\nA TM can be formally described as a 7-tuple (Q, X, \u2211, \u03b4, q0, B, F) where \u2212\n\u007fQis a finite set of states\n\u007fXis the tape alphabet\n\u007f\u2211is the input alphabet\n\u007f\u03b4is a transition function; \u03b4: Q \u00d7 X \u2192Q \u00d7 X \u00d7 {Left_shift, Right_shift}.\n\u007fq0is the initial state\n\u007fBis the blank symbol\n\u007fFis the set of final states\nTape and Head\n\u007fThe tape is infinite in one or both directions\n\u007fThe head moves left (L) or right (R)\n\u007fCan read, write, and move\nTM vs Finite Automata\nTuring Machine Finite Automaton Feature\nInfinite Tape Finite Memory\nYes No Rewrite Tape\nLeft & Right Right only Move Head\nRE Languages Regular Langs Recognizes", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2402, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "93639858-14eb-4e59-b9fc-9e265d128dd5": {"__data__": {"id_": "93639858-14eb-4e59-b9fc-9e265d128dd5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1z2bbwA6M0GCtEoDsmKnNBGrDHN1g9_m9", "node_type": "4", "metadata": {}, "hash": "ec5a729ef7e3cc1c85641edad56df1caa2cfe1a343d8a894483ee83ac52264d1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nContext-Sensitive Languages: Context-\nSensitive Grammars (CSG) and Languages\nChapter 3: Grammars\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Context-Sensitive Languages (CSLs)\u2026\u2026\u2026.....  1\n2. Properties of Context-Sensitive Languages... 2\n3. Example\u2026\u2026\u2026..\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026..3\n4. Differences with Other Grammars  \u2026\u2026\u2026\u2026.   4ContentINDEX\nContext-Sensitive Languages (CSLs)\nBefore we enter context-sensitive languages, it's essential to understand the context-free\nlanguages (CFLs), as they form the foundation for our discussion.\nWhat is Context-Free Grammar?\nA context-free language is generated by a context-free grammar (CFG). In a CFG,\nproduc\u019fon rules have the form: A \u2192 X, Where \u2212\n\u007fAis a variable (non-terminal)\n\u007fXis any string of terminals or variables\nContext-Sensitive Languages (CSLs)\n\u007fCSLs are languages generated by Context-Sensitive Grammars\n\u007fCan be recognized by Linear Bounded Automata (LBA)\n\u007fProper superset of CFLs: CFL \u2282CSL\n\u007fUsed to describe more complex syntax rules, like type agreement in natural language\n\u007fThe context-sensitive languages extend the concept of CFLs by allowing production\nrules to depend on the context in which variables appear.\n\u007fThis seemingly small change leads to a significant increase in expressive power.\n\u007fA context- sensi\u019fve grammar has produc\u019fon rules of the form: \u03b1A\u03b2 \u2192 \u03b1X\u03b2, where \u2212\n\u007f\u03b1,\u03b2are strings of terminals and/or variables (can be empty)\n\u007fAis a variable\n\u007fXis a non-empty string of terminals or variables\nContext-Sensitive Languages (CSLs)\n\u007fContext Sensitive Grammar\n\u007fA context- sensi\u019fve grammar has produc\u019fon rules of the form: \u03b1A\u03b2 \u2192 \u03b1X\u03b2, where \u2212\n\u007f\u03b1,\u03b2are strings of terminals and/or variables (can be empty)\n\u007fAis a variable\n\u007fXis a non-empty string of terminals or variables\nProperties of Context-Sensitive Languages\nListed below are some of the important properties of context- sensi\u019fve languages \u2212\n\u007fContext Preservation \u2212The production process maintains the same context ( \u03b1and \u03b2)\non both sides, ensuring that the replacement of A with X only occurs within the\ndefined context.\n\u007fNon-Contracting \u2212The grammar's property X cannot be empty, ensuring it doesn't\nreduce string length during derivation. However, the start variable S can generate an\nempty string if it's part of the language.\n\u007fIncreased Expressive Power \u2212CSLs can describe patterns that CFLs cannot, such as\nmatching multiple repeated substrings.\nExample\nConsider the following CSG.\nS \u2192 abc/aAbc\nAb \u2192 bA\nAc \u2192 Bbcc\nbB \u2192 Bb\naB \u2192 aa/aaA\nWhat is the language generated by this grammar?\nExample\nSolution :\nS \u2192 aAbc\n\u2192 abAc\n\u2192 abBbcc\n\u2192 aBbbcc\n\u2192 aaAbbcc\n\u2192 aabAbcc\n\u2192 aabbAcc\n\u2192 aabbBbccc\n\u2192 aabBbbccc\nDifferences with Other Grammars\nAutomaton Example Language Grammar Type\nFinite Automaton a\u2217 Regular\nPushdown Automaton a^nb^n Context-Free (CFG)\nLinear Bounded\nAutomatonA^nb^nc^n Context-Sensitive\nTuring Machine All computable languages Recursively Enumerable", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2953, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "483e7b1a-ba9b-4f67-84d7-11bd1137b918": {"__data__": {"id_": "483e7b1a-ba9b-4f67-84d7-11bd1137b918", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1YXeDuj80R6YrxEiB7hEx8qZnoDlXP0e-", "node_type": "4", "metadata": {}, "hash": "282211713cc1e9fb81e55ece6b81e66474ab8c02d00a49727504eae94c135fb5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03b765db-0707-4d64-939b-8aa3ad228fc5", "node_type": "1", "metadata": {}, "hash": "abe1d3bc745a34a7997a2a0c611808f54b8b9b1ffea7278b6a574ff550e74cdd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nDeterministic Pushdown Automata and\nClosure Properties of CFLs\nChapter 3: Grammars\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 1\n2. What is a DPDA?................\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2\n3. Formal Definition\u2026.\u2026\u2026\u2026..\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026.. 3\n4. Example of PDA...\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.   4\n5. Difference Between NPDA and DPDA  \u2026\u2026\u2026.  5\n6. Properties of Context Free Languages \u2026....... 6ContentINDEX\nIntroduction\nThis section explores:\n\u007fFocuses on Deterministic Pushdown Automata (DPDA)\n\u007fCompares DPDA with Non-Deterministic PDA (NPDA)\n\u007fDiscusses closure properties of Context-Free Languages (CFLs)\nWhat is a DPDA?\n\u007fA pushdown automaton is a way to implement a context-free grammar in a similar\nway we design DFA for a regular grammar.\n\u007fA DFA can remember a finite amount of information, but a PDA can remember an\ninfinite amount of information.\n\u007fBasically a pushdown automaton is \u2212\n\u007f\"Finite state machine\" + \"a stack\"\n\u007fA pushdown automaton has three components \u2212\n\u007fan input tape,\n\u007fa control unit, and\n\u007fa stack with infinite size.\nWhat is a DPDA?\n\u007fThe stack head scans the top symbol of the stack.\n\u007fA stack does two opera\u019fons \u2212\n\u007fPush \u2212 a new symbol is added at the top.\n\u007fPop \u2212 the top symbol is read and removed\n\nFormal Definition\nA PDA can be formally described as a 7-tuple (Q, \u2211, S, \u03b4, q0, I, F) \u2212\n\u007fQis the finite number of states\n\u007f\u2211is input alphabet\n\u007fSis stack symbols\n\u007fis the transition function: Q \u00d7 ( \u2211\u222a{\u03b5}) \u00d7 S \u00d7 Q \u00d7 S*\n\u007fq0is the initial state (q0\u2208Q)\n\u007fIis the initial stack top symbol (I \u2208S)\n\u007fFis a set of accepting states (F \u2208Q)\nExample of PDA\nThe following diagram shows a transition in a PDA from a state q1\nto state q2, labeled as a,b \u2192 c \u2212\nThis means at state q1, if we encounter an input string a and top\nsymbol of the stack is b, then we pop b, push c on top of the stack\nand move to state q2.\n\nExample of PDA\nConstruct a PDA that accepts L = {0n 1n | n \u2265 0}\n\u007fInitially we put a special symbol $ into the empty stack.\n\u007fThen at state q2, if we encounter input 0 and top is Null, we\npush 0 into stack. This may iterate. And if we encounter input 1\nand top is 0, we pop this 0.\n\nExample of PDA\n\u007fThen at state q3, if we encounter input 1 and top is 0, we pop\nthis 0. This may also iterate. And if we encounter input 1 and top\nis 0, we pop the top element.\n\u007fIf the special symbol $ is encountered at top of the stack, it is\npopped out and it finally goes to the accepting state q4.\nExample of PDA\nConstruct a PDA that accepts L = { wwR | w = (a+b)* }\n\u007fInitially we put a special symbol $ into the empty stack.\n\u007fAt state q2, the wis being read.\n\u007fIn state q3, each 0 or 1 is popped when it matches the input. If any other input\nis given, the PDA will go to a dead state. When we reach that special symbol\n$, we go to the accepting state q4.\n\nDifference Between NPDA and DPDA\n\nProperties of Context Free Languages\n1. Union\nIf L and M are two context-free languages, then their union L \u222aM is also a CFL.\n2. Concatenation\nIf L and M are CFLs, then their concatenation LM is also a CFL.\n3. Kleene Closure\nIf L is a CFL, then its Kleene closure L* (zero or more repetitions of strings in L) is\nalso a CFL.\nProperties of Context Free Languages\n4. Reversal\n\u007fIf L is a CFL, then its reversal L^R (where each string is reversed) is also a CFL.\n5. Homomorphism\n\u007fA homomorphism is a function that replaces each symbol in a string with another\nstring.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3446, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "03b765db-0707-4d64-939b-8aa3ad228fc5": {"__data__": {"id_": "03b765db-0707-4d64-939b-8aa3ad228fc5", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1YXeDuj80R6YrxEiB7hEx8qZnoDlXP0e-", "node_type": "4", "metadata": {}, "hash": "282211713cc1e9fb81e55ece6b81e66474ab8c02d00a49727504eae94c135fb5", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "483e7b1a-ba9b-4f67-84d7-11bd1137b918", "node_type": "1", "metadata": {}, "hash": "fb8a9dc9767c1f659023958185765e1300be54f9493f7a17edb20c0e07ff8964", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "When we reach that special symbol\n$, we go to the accepting state q4.\n\nDifference Between NPDA and DPDA\n\nProperties of Context Free Languages\n1. Union\nIf L and M are two context-free languages, then their union L \u222aM is also a CFL.\n2. Concatenation\nIf L and M are CFLs, then their concatenation LM is also a CFL.\n3. Kleene Closure\nIf L is a CFL, then its Kleene closure L* (zero or more repetitions of strings in L) is\nalso a CFL.\nProperties of Context Free Languages\n4. Reversal\n\u007fIf L is a CFL, then its reversal L^R (where each string is reversed) is also a CFL.\n5. Homomorphism\n\u007fA homomorphism is a function that replaces each symbol in a string with another\nstring.\n\u007fIf L is a CFL and h is a homomorphism, then h(L) is also a CFL.\n6. Inverse Homomorphism\n\u007fIf L is a CFL and h is a homomorphism, then h \u207b\u00b9(L) is also a CFL.", "mimetype": "text/plain", "start_char_idx": 2778, "end_char_idx": 3603, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4115be13-ddb1-419a-8c6e-58af077f23f0": {"__data__": {"id_": "4115be13-ddb1-419a-8c6e-58af077f23f0", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1SPPojHd2sYla__ZMZ9i1G_BLO_lFU7tJ", "node_type": "4", "metadata": {}, "hash": "d6400b780fe25c9ca5093b259beeb3a8709753e12a4ab4e54a06950538950c3f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nParse Trees, Ambiguity in CFG, Pumping\nLemma for CFLs\nChapter 3: Grammars\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 1\n2. What is a Parse Tree?........\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2\n3. Parse Tree Example\u2026\u2026\u2026..\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026.. 3\n4. Ambiguity in CFG.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.   4\n5. Example of Ambiguity \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  5\n6. Removing Ambiguity\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026\u2026..... 6\n7. Pumping Lemma for CFLs\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 7\n8. How to Use Pumping Lemma\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 8ContentINDEX\nIntroduction\nThis section explores:\n\u007fStructural representation of derivations using parse trees\n\u007fThe concept of ambiguity in context-free grammars\n\u007fThe pumping lemma for proving that certain languages are not context-free\nWhat is a Parse Tree?\n\u007fA parse tree visually represents how a string is derived from a CFG.\n\u007fStructure:\n\u007fRoot: Start symbol\n\u007fInternal nodes: Non-terminals (variables)\n\u007fLeaves: Terminals or \u03b5 (empty string)\n\u007fReading the leaves from left to right gives the derived string.\nParse Tree Example\nGrammar:\n\ud835\udc46\u2192\ud835\udc4e\ud835\udc46\ud835\udc4f\u2223\ud835\udf00S\u2192aSb\u2223\u03b5\nString: aabb\nDerivation:\n\ud835\udc46\u21d2\ud835\udc4e\ud835\udc46\ud835\udc4f\u21d2\ud835\udc4e\ud835\udc4e\ud835\udc46\ud835\udc4f\ud835\udc4f\u21d2\ud835\udc4e\ud835\udc4e\ud835\udc4f\u21d2\ud835\udc4e\ud835\udc4e\ud835\udc4f\ud835\udc4f\nEach step replaces a non-terminal with its production.S\n/ | \\\na  S  b\n/|\\\na S b\n|\n\u03b5\nAmbiguity in CFG\n\u007fA CFG is ambiguous if there exists at least one string that has:\n\u007fMore than one parse tree , or\n\u007fMore than one leftmost or rightmost derivation\n\u007fAmbiguity leads to confusion in interpretation, especially in compilers.\nExample of Ambiguity\nGrammar:\nE\u2192E+E\u2223E\u2217E\u2223\nString: id + id * id\n\u007fTwo parse trees:\n1.Interpret as (id + id) * id\n2.Interpret as id + (id * id)\n\u007fGrammar does not enforce precedence or associativity.\nRemoving Ambiguity\n\u007fTo remove ambiguity:\n\u007fRewrite the grammar to enforce precedence (e.g., * > +)\n\u007fSeparate productions by level of precedence\nE \u2192 E + T | T\nT \u2192 T * F | F\nF \u2192 id\nPumping Lemma for CFLs\n\u007fUsed to prove that a language is not context-free\n\u007fFor every context-free language L, there exists a constant p (pumping length) such\nthat:\nThen there is a pumping length n such that any string w \u03b5L of length>=n can be written as\nfollows \u2212\n|w|>=n\nWe can break w into 5 strings, w=uvxyz, such as the ones given below\n\u007f|vxy| >=n\n\u007f|vy| # \u03b5\n\u007fFor all k>=0, the string uvkxyyz\u2208L\nHow to Use Pumping Lemma\n\u007fAssume the language is context-free.\n\u007fChoose a string s of length \u2265 p.\n\u007fTryall valid decompositions s=uvwxys\n\u007fShow that for some i , uviwxiy \u2209creating a contradiction.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2418, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "89f64757-bb1e-44e5-b81c-246399329329": {"__data__": {"id_": "89f64757-bb1e-44e5-b81c-246399329329", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12JpJVK0Nlxyee94mrp308YBzZOEJY1_W", "node_type": "4", "metadata": {}, "hash": "c8e6b51f28eafc0a91273b534d0a6e1bfd7a65458eec68921a3971cf4d5e5ce0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nNon-Deterministic Pushdown Automata\n(PDA) and Equivalence with CFG\nChapter 3: Grammars\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 1\n2. Formal Definition of NPDA\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2\n3. NPDA Transition Function\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026\u2026\u2026.. 3\n4. How NPDA Works\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  4\n5. Example of NPDA\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 5\n6. Equivalence of NPDA and CFG \u2026\u2026\u2026\u2026\u2026\u2026..... 6ContentINDEX\nIntroduction\n\u007fWhat is a Pushdown Automaton (PDA)?\nA PDA is a finite automaton equipped with a stack.\nUsed to recognize context-free languages (CFLs).\n\u007fTwo types:\nDeterministic PDA (DPDA)\nNon-deterministic PDA (NPDA)\nFormal Definition of NPDA\nNPDA is a 7-tuple:\nM=(Q, \u03a3,\u0393,\u03b4,q0,Z0,F)\nwhere:\n\u007fQ: set of states\n\u007f\u03a3: input alphabet\n\u007f\u0393: stack alphabet\n\u007f\u03b4: transition function\n\u007fq0 : start state\n\u007fZ0 : ini\u019fal stack symbol\n\u007fF: set of accepting states\nNPDA Transition Function\n\ud835\udeff:\ud835\udc44\u00d7(\u03a3\u222a{\ud835\udf16})\u00d7\u0393\u2192\ud835\udc43(\ud835\udc44\u00d7\u0393\u2217)\nMeaning:\n\u007fBased on current state, input symbol (or \u03b5), and top of the stack.\n\u007fCan move to new states and update the stack.\nHow NPDA Works\n\u007fStack enables NPDA to:\n\u007fRemember past input.\n\u007fHandle nested structures (like parentheses).\n\u007fNon-determinism:\n\u007fMultiple possible moves at each step.\n\u007fAccepts if any computation path leads to an accepting state.\nExample of NPDA\nDesign a non deterministic PDA for accepting the language L = {an bn | n>=1}, i.e.,\nL = {ab, aabb, aaabbb, aaaabbbb, \u2026\u2026}\nStack transition functions\n\ud835\udf73(q0, a, z) \u251c(q0, az) [ push a on empty stack]\n\ud835\udf73(q0, a, a) \u251c(q0, aa) [push a\u2019s ]\n\nContext-Free Grammars (CFG)\n\u007fCFG is a 4-tuple (V, \u03a3,R,S)\n\u007fV: variables (non-terminals)\n\u007f\u03a3: terminals\n\u007fR: production rules\n\u007fS: start symbol\n\u007fGenerates context-free languages (CFLs)\nEquivalence of NPDA and CFG\n\u007fTheorem: Every language accepted by a NPDA is generated by a CFG.\n\u007fAnd vice versa: For every CFG, there exists an equivalent NPDA.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1902, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "43010053-9e38-48f9-b46b-a82bc92029c4": {"__data__": {"id_": "43010053-9e38-48f9-b46b-a82bc92029c4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1riXFQ2vV22GV8q2GIjQZf3dekx5yNX6c", "node_type": "4", "metadata": {}, "hash": "fb98614a6eae6e59b7333ee32b12b056ccfe4ea3ed358da14e19ba3d4b7605fe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a3474416-f847-4ae1-b27b-475c9ca9eeea", "node_type": "1", "metadata": {}, "hash": "d7304fc6b5f4b38b75a0ca3d231d74fbcde0da157bb51c4bd1390029b41592fc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nContext-free grammars (CFG) and\nlanguages (CFL), Chomsky normal forms\nChapter 3: Grammars\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. What is a Context-Free Grammar?\u2026..\u2026\u2026\u2026\u2026.\n2\n3. Example of CFG\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.3\n4. What is a Context-Free Language (CFL)?\u2026\u2026..4\n5. Derivations in CFGs\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 5\n6. Ambiguity in CFGs\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...... 6\n7. Normal Forms in CFGs\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026  7\n8. Chomsky Normal Form (CNF)..........\u2026\u2026\u2026\u2026\u2026  8\n9. Steps to Convert CFG to CNF\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..   9\n10.Key Takeaways\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.10ContentINDEX\nIntroduction\n\u007fContext-Free Grammars (CFG) describe context-free languages (CFLs)\n\u007fCFGs are widely used in compiler design ,parsers , and natural language processing\n\u007fCNF simplifies CFGs for algorithmic analysis\nWhat is a Context-Free Grammar?\nA CFG is defined as a 4-tuple:\nG = (V, \u03a3, R, S)\n\u007fV \u2192 Set of variables (non-terminals)\n\u007f\u03a3 \u2192 Set of terminals\n\u007fR \u2192 Set of produc\u019fon rules (A \u2192 \u03b1)\n\u007fS \u2192 Start symbol (S \u2208V)\nExample of CFG\nGrammar G = ({S}, {a, b}, R, S) with:\n\u007fS \u2192 aSb | \u03b5\nGenerates strings:\n\u007f\u0395\n\u007fAb\n\u007fAabb\n\u007fAaabbb\n\u007f\n Language: L = { a \u207fb\u207f | n \u2265 0 }\nWhat is a Context-Free Language (CFL)?\n\u007fA language is CFLif it can be generated by a CFG\n\u007fCFLs are recognized by Pushdown Automata (PDA)\n\u007fCFLs can include:\n\u007fBalanced parentheses\n\u007fPalindromes\n\u007fa\u207fb\u207f, a\u207fb\u207fc\u207f (NOT CFL)\nDerivations in CFGs\nLeftmost derivation: Expand the leftmost non-terminal\nRightmost derivation: Expand the rightmost non-terminal\nParse tree visualizes the derivation\nExample for S \u2192 aSb | \u03b5\nDerivation for aaabbb:\nS\u21d2aSb\u21d2aaSbb\u21d2aaaSbbb \u21d2aaabbb\nAmbiguity in CFGs\n\u007fA grammar is ambiguous if a string has more than one parse tree\n\u007fAmbiguity is undesirable in programming languages\nExample:\nGrammar:\nS \u2192 S + S | S * S | a\nString: a + a * a\nTwo parse trees possible \u21d2ambiguous\nNormal Forms in CFGs\n\u007fNormal forms are restricted forms of CFGs used in algorithms like parsing and\nsimplification.\n\u007fTwo main types:\n1. Chomsky Normal Form (CNF)\n2. Greibach Normal Form (GNF)\nChomsky Normal Form (CNF)\nEvery production is of the form:\n1.A \u2192 BC (non-terminals only)\n2.A \u2192 a (terminal only)\n3.S \u2192 \u03b5 (if \u03b5\u2208L)\nRestrictions:\n\u007fB, C\u2208V (non-terminals), B \u2260 start symbol\n\u007fa\u2208\u03a3 (terminal)\nSteps to Convert CFG to CNF\n1.Remove \u03b5-productions (except S \u2192 \u03b5)\n2.Remove unit productions (A \u2192 B)\n3.Remove useless symbols\n4.Convert to binary productions (A \u2192 BC)\n5.Terminal replacements (replace terminals in RHS of long productions)\nSteps to Convert CFG to CNF\nStep 1 \u2212 Eliminate start symbol from right hand side (RHS)\nIf the start symbol S is at the right-hand side of any production,\nCreate a produc\u019fon as follows \u2212\nS1->S\nWhere, S1 is the new start symbol\nStep 2 \u2212 In the grammar try to remove the null, unit and useless produc\u019fons.\nStep 3 \u2212 Eliminate terminals from RHS of the produc\u019fon if they exist with other non \nterminals or terminals.\nExample \u2212 S->aA can be decomposed as follows \u2212\nS->RA\nR->a\nFinally, it is nothing but S->aA only.\nSteps to Convert CFG to CNF\nStep 4 \u2212 Eliminate the RHS with more than two non-terminals.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3122, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a3474416-f847-4ae1-b27b-475c9ca9eeea": {"__data__": {"id_": "a3474416-f847-4ae1-b27b-475c9ca9eeea", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1riXFQ2vV22GV8q2GIjQZf3dekx5yNX6c", "node_type": "4", "metadata": {}, "hash": "fb98614a6eae6e59b7333ee32b12b056ccfe4ea3ed358da14e19ba3d4b7605fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "43010053-9e38-48f9-b46b-a82bc92029c4", "node_type": "1", "metadata": {}, "hash": "e7edcfb529346ca2ba15c9c03a541539816ed5e8785c990ec2d042a62e41c2db", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Step 3 \u2212 Eliminate terminals from RHS of the produc\u019fon if they exist with other non \nterminals or terminals.\nExample \u2212 S->aA can be decomposed as follows \u2212\nS->RA\nR->a\nFinally, it is nothing but S->aA only.\nSteps to Convert CFG to CNF\nStep 4 \u2212 Eliminate the RHS with more than two non-terminals.\nExample \u2212 S->ABS can be decomposed as given below \u2212\nS->RS\nR->AB\nKey Takeaways\nA context free grammar is in CNF, if the production rules satisfy one of the following\nconditions\n\u007fIf there is start Symbol generating \u03b5. Example \u2212A->\u03b5\n\u007fIf a non-terminal generates two non-terminals. Example \u2212S->AB\n\u007fIf a non-terminal generates a terminal. Example \u2212S->a", "mimetype": "text/plain", "start_char_idx": 2828, "end_char_idx": 3470, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "30889a60-50d3-42cd-a2be-f3c4383a7fad": {"__data__": {"id_": "30889a60-50d3-42cd-a2be-f3c4383a7fad", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1iDQ-xjguFUR69Oi-egq8gOOyfy1OqE0z", "node_type": "4", "metadata": {}, "hash": "d08b5647e246d97282e242c1f7e0fba26fdc2958478e1be9101e4743cd9dda36", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nMinimization of finite automata\nChapter - 2: Regular languages and finite automata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. Why Minimize a DFA?.................\u2026..\u2026\u2026\u2026\u2026...2\n3. Minimization Procedure Using Equivalence\nTheorem\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026.3\n4. Minimization of DFA \u2013 Example..\u2026\u2026\u2026\u2026\u2026\u2026.4\n5. Properties of Minimal DFA\u2026\u2026\u2026\u2026\u2026\u2026....\u2026\u2026.5ContentINDEX\nIntroduction\n\u007fFinite Automata can have redundant states\n\u007fMinimization reduces the number of states\n\u007fResult: A minimal DFA which accepts the same language\nWhy Minimize a DFA?\n\u007f\n Reduce memory and computation cost\n\u007f\n Simplify analysis and implementation\n\u007f\n Minimal DFA is unique (up to state renaming)\n\u007f\nDFA minimization does notchange the language accepted\nMinimization Procedure Using Equivalence Theorem\n1. Eliminate Dead and Inaccessible States : Remove states that do not contribute to the\nacceptance of any string in the language.\n2. Construct Transition Table : Create a table detailing transitions for each state on every\ninput symbol.\n3. Initial Partition (P \u2080): Divide the set of states into two groups: final (accepting) and\nnon-final (non-accepting) states.\n4. Refine Partitions :\n\u007fIteratively split groups in the current partition if states within a group have transitions\non the same input symbol leading to different groups in the previous partition.\nMinimization Procedure Using Equivalence Theorem\n5. Repeat Until Stable: Continue refining partitions until no further splits occur, i.e.,\nthe partition remains unchanged between iterations.\n6. Merge Equivalent States: States that remain in the same group in the final partition\nare equivalent and can be merged.\nMinimization of DFA - Example\n\nMinimization of DFA - Example\nStep-01:\nThe given DFA contains no dead states and inaccessible states.\nStep-02:\nDraw a state transition table-b a\nq2 q1 \u2192q0\nq3 q1 q1\nq2 q1 q2\n*q4 q1 q3\nq2 q1 *q4\nMinimization of DFA - Example\nStep-03:\nNow using Equivalence Theorem, we have-\nP0= { q0, q1, q2, q3} { q4}\nP1= { q0, q1, q2} { q3} { q4}\nP2= { q0, q2} { q1} { q3} { q4}\nP3= { q0, q2} { q1} { q3} { q4}\nSince P3= P2, so we stop.\nFrom P3, we infer that states q0and q2are equivalent and can be merged together.\nMinimization of DFA - Example\nStep-03:\nSo, Our minimal DFA is-\n\nProperties of Minimal DFA\n\u007fUnique for a given regular language\n\u007fNo equivalent states\n\u007fNo unreachable states\n\u007fUsed as canonical form of a regular language", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2505, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1e698d59-bb0d-4d5f-b128-e30ae75f14ec": {"__data__": {"id_": "1e698d59-bb0d-4d5f-b128-e30ae75f14ec", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1MytvHkA9kpAK7XEnHq1FdOp7Gs-2ZY4I", "node_type": "4", "metadata": {}, "hash": "43947c406fc2e80f63d17c0af58bea7cc4cc2c8cb9cb511dc5974e902cb6b8fd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nProperties of regular languages, pumping\nlemma for regular languages\nChapter - 2: Regular languages and finite automata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. Properties of Regular Languages.\u2026..\u2026\u2026\u2026\u2026..2\n3. Example \u2013 Closure Under Union\u2026.\u2026.\u2026\u2026\u2026\u2026.3\n4. Decidability Properties\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.4\n5. Pumping Lemma \u2013 Formal Statement....\u2026\u2026.5\n6. Pumping Lemma \u2013 Example..\u2026\u2026\u2026\u2026\u2026\u2026\u2026.....6\n7. Key Takeaways\u2026\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.7ContentINDEX\nIntroduction\n\u007fRegular languages are the simplest type of languages recognized by finite automata\n\u007fWe study:\nClosure properties\nDecidability properties\nPumping lemma \u2014 a method to prove a language is not regular\nProperties of Regular Languages\nRegular languages are closed under the following operations :\nMeaning Operation\nIf L\u2081 and L \u2082 are regular, L \u2081\u222aL\u2082 is regular Union\nL\u2081\u00b7L\u2082 is regular Concatenation\nL* is regular Kleene Star\nL\u2081 \u2229 L\u2082 is regular Intersection\n\u00acL is regular Complementation\nL\u2081 - L\u2082 is regular Difference\nL\u1d3f is regular Reversal\nh(L) is regular Homomorphism\nExample \u2013 Closure Under Union\nLet:\n\u007fL\u2081 = strings over {a, b} with even number of a\u2019s\n\u007fL\u2082 = strings that end with b\nThen L \u2081\u222aL\u2082 is also regular\n Construct DFA for L \u2081, DFA for L \u2082, and combine them using\nproduct construction\nDecidability Properties\nDecision Method Problem\nCheck for reachable final state Emptiness\nCheck for cycles in FA Finiteness\nSimulate input in DFA Membership (w \u2208L?)\nMinimize and compare Equivalence of two DFAs\nUse difference and emptiness test Subset (L \u2081\u2286L\u2082?)\nPumping Lemma \u2013 Formal Statement\nTheorem:\nIfLis a regular language, then there exists a constant p > 0 (pumping length), such that\nany string s\u2208Lwith |s| \u2265 p, can be divided into 3 parts:\ns = xyz , such that:\n1.|y| > 0 (y \u2260 \u03b5)\n2.|xy| \u2264 p\n3.For all i \u2265 0, x\u00b7y \u2071\u00b7z\u2208L\nPumping Lemma \u2013 Example\nProving a Language is Not Regular:\nLanguage:\nL = { a \u207fb\u207f | n \u2265 0 }\nClaim: L is not regular\nProof by contradiction using Pumping Lemma:\n1.Assume L is regular\n2.Let pbe the pumping length\n3.Choose s = a^p b^p \u2208L\n4.s = xyz, with |xy| \u2264 p \u2192 x and y contain only a's\n5.Pump y (repeat i times): x\u00b7y \u2071\u00b7z = a^(p+i\u00b7|y|) b^p\n6.Unequal number of a's and b's \u21d2not in L\nContradic\u019fon \u2192 L is not regular\nKey Takeaways\n\u007fRegular languages are closed under many operations\n\u007fDecidability is strong for regular languages\n\u007fPumping Lemma is a powerful proof technique\n\u007fProves that a language is not regular\n\u007fWorks by contradiction\n\u007fFocuses on the inability to pump a string without violating language rules", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2590, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1b8df65e-0984-4141-b72d-38962b16469d": {"__data__": {"id_": "1b8df65e-0984-4141-b72d-38962b16469d", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1Ks294UdSygCSC69ZStPwn_MK1hEqaTHJ", "node_type": "4", "metadata": {}, "hash": "370fdf773799eea14544dc6f167d939d5bdd2b32694daaae8ecef752588a3c45", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b4db7039-71a5-4821-911c-7709922736fe", "node_type": "1", "metadata": {}, "hash": "12b01c150d5b4beb9d70286dffdaa173cd4c9388d44ad07146ba07a180aead83", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nRegular grammars and equivalence with\nfinite automata\nChapter - 2: Regular languages and finite automata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. What is a Grammar?............\u2026..\u2026.\u2026..\u2026\u2026\u2026\u2026. 2\n3. What is a Regular Grammar?.\u2026.\u2026.\u2026.\u2026\u2026\u2026\u2026. 3\n4. Example of a Regular Grammar\u2026\u2026\u2026\u2026\u2026\u2026\u2026..4\n5. Regular Grammar\n Finite Automaton..\u2026\u2026. 5\n6. DFA to RE \u2013 State Elimination\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 6\n7. Regular Grammar\n Finite Automaton\nExample\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.7\n8. Finite Automaton\n Regular Grammar\u2026\u2026\u2026..8\n9. Finite Automaton\n Regular Grammar\nExample\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..9\n10.Summary\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u202610ContentINDEX\nIntroduction\n\u007fRegular grammars are the simplest type of formal grammars in the Chomsky hierarchy\n\u007fThey generate regular languages\n\u007fThese languages can be recognized by Finite Automata (FA)\n\u007fThis section explores:\nDefinition of regular grammars\nExamples\nEquivalence with finite automata\nWhat is a Grammar?\nAgrammar G is defined as a 4-tuple:\nG = (V, \u03a3, P, S)\nWhere:\n\u007fV: Set of variables (non-terminals)\n\u007f\u03a3: Set of terminals\n\u007fP: Set of productions/rules\n\u007fS: Start symbol (S \u2208V)\nWhat is a Regular Grammar?\nA grammar is regular if all production rules are of one of the following forms:\nRight Linear Grammar:\n\u007fA \u2192 aB\n\u007fA \u2192 a\n\u007fA \u2192 \u03b5\nLeft Linear Grammar:\n\u007fA \u2192 Ba\n\u007fA \u2192 a\n\u007fA \u2192 \u03b5\nWhere A, B \u2208V and a \u2208\u03a3\nExample of a Regular Grammar\nGrammar G:\n\u007fV = {S, A}\n\u007f\u03a3 = {0, 1}\n\u007fP:\n\u007fS \u2192 0S\n\u007fS \u2192 1A\n\u007fA \u2192 0A\n\u007fA \u2192 1A\n\u007fA \u2192 \u03b5\n\u007fStart Symbol = S\nLanguage Generated: Strings that start with any number of 0\u2019s or a single 1, followed by\nany combination of 0\u2019s and 1\u2019s\nRegular Grammar\n Finite Automaton\nSteps:\n1.For each produc\u019fon of the form A \u2192 aB, add transi\u019fon from state A to state B on \ninput a\n2.For each A \u2192 a, add transi\u019fon from state A to \ufb01nal state on input a\n3. For each A \u2192 \u03b5, mark A as a \ufb01nal state\nRegular Grammar\n Finite Automaton Example\nEliminating Epsilon Productions: A Step-by-Step Approach:\nS \u2192 a, aA | bB\nA \u2192 aA | aS\nB \u2192 cS\nS \u2192 \u03b5\nB \u2192 \u03b5\nStep 1: Identifying Epsilon Productions\nFirst, we iden\u019ffy the epsilon produc\u019fons in our grammar. In this case, they are \u2212\nS \u2192 \u03b5\nB \u2192 \u03b5\nRegular Grammar\n Finite Automaton Example\nStep 2: Generating Non-Epsilon Productions\nWe list all the productions that do not involve epsilon. These are the productions that\nform the basis of our epsilon-free grammar \u2212\nS \u2192 a, aA | bB\nA \u2192 aA | aS\nB \u2192 cS\nRegular Grammar\n Finite Automaton Example\nStep 3: Replacing Epsilon Productions\nNow, we systematically replace all occurrences of non-terminals with epsilon productions\nin the right-hand sides of our productions.\n\u007fIn 'A \u2192aA | aS', replacing 'S' with ' \u03b5' yields 'A \u2192aA | \u03b5'. Since ' \u03b5' is the empty string,\nwe can simplify this to 'A \u2192aA'.\n\u007fIn 'B \u2192cS', replacing 'S' with ' \u03b5' yields 'B \u2192c'.\n\u007fIn 'S \u2192aA | bB', replacing 'B' with ' \u03b5' yields 'S \u2192aA | b'.\n\u007fThe final productions will be like,\nS\u2192a ,a A|b\nA\u2192a A|a S|a\nB\u2192c S|c\nRegular Grammar\n Finite Automaton Example\nStep 4: Handling the Start Symbol\n\u007fThe start symbol 'S' has an epsilon production. This means that the start symbol can\nderive the empty string, which is often acceptable in finite automata.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3196, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b4db7039-71a5-4821-911c-7709922736fe": {"__data__": {"id_": "b4db7039-71a5-4821-911c-7709922736fe", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1Ks294UdSygCSC69ZStPwn_MK1hEqaTHJ", "node_type": "4", "metadata": {}, "hash": "370fdf773799eea14544dc6f167d939d5bdd2b32694daaae8ecef752588a3c45", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1b8df65e-0984-4141-b72d-38962b16469d", "node_type": "1", "metadata": {}, "hash": "90d5ee19690aeaf871120f335b3b56175ed447a04ae9d5bde5744db4c0c99470", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u007fIn 'A \u2192aA | aS', replacing 'S' with ' \u03b5' yields 'A \u2192aA | \u03b5'. Since ' \u03b5' is the empty string,\nwe can simplify this to 'A \u2192aA'.\n\u007fIn 'B \u2192cS', replacing 'S' with ' \u03b5' yields 'B \u2192c'.\n\u007fIn 'S \u2192aA | bB', replacing 'B' with ' \u03b5' yields 'S \u2192aA | b'.\n\u007fThe final productions will be like,\nS\u2192a ,a A|b\nA\u2192a A|a S|a\nB\u2192c S|c\nRegular Grammar\n Finite Automaton Example\nStep 4: Handling the Start Symbol\n\u007fThe start symbol 'S' has an epsilon production. This means that the start symbol can\nderive the empty string, which is often acceptable in finite automata.\n\u007fHowever, if the start symbol has an epsilon production, we need to add a new start\nsymbol ('S1' in our example) that inherits all the productions of the original start\nsymbol, including the epsilon production. This new start symbol ensures that the\nempty string can be accepted by the automata.\nS1\u2192a|a A|b|b B| \u03b5\nS\u2192a ,a A|b\nA\u2192a A|a S|a\nB\u2192c S|c\nRegular Grammar\n Finite Automaton Example\n\nFinite Automaton\n Regular Grammar\nSteps:\n1.For each transi\u019fon from state A to B on input a, add produc\u019fon A \u2192 aB\n2.For each \ufb01nal state F, add produc\u019fon F \u2192 \u03b5\nLet\u2019s consider a Finite automaton (FA) as given below \u2212\n\nFinite Automaton\n Regular Grammar Example\nPick the start state A and output is on symbol \u2018a\u2019 going to state B\nA\u2192aB\nNow we will pick state B and then we will go on each output\ni.e B \u2192aB\nB\u2192bB\nB\u2192\u03b5\nTherefore,\nFinal grammar is as follows \u2212\nA\u2192aB\nB\u2192aB/bB/ \u03b5\n\nSummary\n\u007fRegular grammars are defined by linear productions\n\u007fThey generate regular languages\n\u007fRegular grammars and finite automata are equivalent in power\n\u007fConversion between grammar and automaton is systematic\n\u007fUseful in real-world applications like compilers and text scanners", "mimetype": "text/plain", "start_char_idx": 2655, "end_char_idx": 4330, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "11fbd3ad-f31b-4b41-8cae-7b4f97605c85": {"__data__": {"id_": "11fbd3ad-f31b-4b41-8cae-7b4f97605c85", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1UdzW7tbP0u6OxgDAWp1ZTXyxaw_kB8fG", "node_type": "4", "metadata": {}, "hash": "9081a76e6ee56cfb9af450f8403d7de04b0b0d7c6c2a0c64db8a799452d25d6d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nNon-Deterministic Finite automata (NFA)\nand equivalence with DFA\nChapter - 2: Regular languages and finite automata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. What is NFA?..........\u2026\u2026\u2026..\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026.2\n3. Formal Definition of NFA\u2026\u2026\u2026.\u2026.\u2026.\u2026\u2026\u2026\u2026\u20263\n4. Example NFA \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..4\n5. DFA vs NFA \u2013 Key Differences\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026. 5\n6. NFA to DFA\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 6\n7. NFA to DFA Example\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..7ContentINDEX\nIntroduction\nFinite Automata (FA) are computational models for recognizing regular languages\nThere are two types:\n\u007fDeterministic Finite Automata (DFA)\n\u007fNon-Deterministic Finite Automata (NFA)\nIn this section, we focus on:\n\u007fDefining NFAs\n\u007fComparing NFAs with DFAs\n\u007fProving equivalence through conversion\nWhat is NFA?\n\u007fAn NFA allows:\nMultiple transitions for the same input symbol\nEpsilon ( \u03b5) transitions (optional for \u03b5-NFA)\n\u007fAccepts input if any path leads to an accepting state\n\u007fThink of it as \"multiple possibilities\" at each step\nFormal Definition of NFA\nAn NFA is a 5-tuple:\nM = (Q, \u03a3, \u03b4, q\u2080, F)\nWhere:\n\u007fQ: Finite set of states\n\u007f\u03a3: Input alphabet\n\u007f\u03b4: Transition function ( \u03b4: Q \u00d7 \u03a3 \u2192 2^Q)\n\u007fq\u2080: Initial state (q \u2080\u2208Q)\n\u007fF: Set of accepting/final states (F \u2286Q)\nExample NFA\nNFA with \u2211 = {0, 1} accepts all strings with 01.\nNext State of\nInput 1Next state for\nInput 0Present State\n\u03b5 q1 \u2192q0\nq2 \u03b5 q1\nq2 q2 *q2\nExample NFA\nDesign an NFA with \u2211 = {0, 1} accepts all string ending with 01.\n\nDFA vs NFA \u2013 Key Differences\nNFA DFA Feature\n\u03b4: Q \u00d7 \u03a3 \u2192 2^Q \u03b4: Q \u00d7 \u03a3 \u2192 Q Transition Func\nMultiple/zero paths\nallowedExactly one path Determinism\nAllowed (in \u03b5-NFA)\n Not allowed Epsilon Moves\nEasier to designHarder for complex\nlanguagesDesign\nNeeds conversion before\nexecutionEasier to implement Execution\nNFA to DFA\nThere are four basic steps for the conversion of NFA to DFA.\nStep 01: Draw an NFA Graph or diagram if it is not given.\nStep 02: Draw the NFA transition Table.\nStep 03: Convert the NFA transition Table to the DFA transition Table.\nIf any new state appears while converting the NFA to DFA then it will be added to the\nstate column of the DFA Table.\nIf \u201cx\u201d was the final state in NFA, then all those states will be the final in DFA where \u201cx\u201d\nexists.\nStep 04: Convert the DFA table to the DFA Diagram.\nNFA to DFA \u2013 Example\nStep 01: Draw NFA Graph\nThe following is the NFA graph that needs to be converted to a DFA.\nStep 02: Draw the NFA transition Table.\nThe following is the NFA transition table which is derived from the given NFA.\n\nNFA to DFA \u2013 Example\nStep 03: Conversion of NFA To DFA\ntransition TableStep 4: Now draw DFA according to the\nDFA transition table", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2705, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "18a38475-8e38-4451-9197-bd745deb490b": {"__data__": {"id_": "18a38475-8e38-4451-9197-bd745deb490b", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1yuiFL8iDBWMLijHQRgEpXVYNT3OyRfAa", "node_type": "4", "metadata": {}, "hash": "ac375b27f7836b1f0e28de87002c51ee26e51dfab0cf663b5e870da2d3d96d6a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nMoore machines and mealy machines,\nConversion from Mealy to Moore and vice\nversa\nChapter - 2: Regular languages and finite automata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Introduction to Finite State Machines with\nOutput\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. Moore Machine \u2013 Definition..\u2026.\u2026..\u2026\u2026\u2026\u2026\u2026.2\n3. Moore Machine \u2013 Example \u2026\u2026.\u2026.\u2026.\u2026\u2026\u2026\u2026. 3\n4. Mealy Machine \u2013 Definition\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 4\n5. Mealy Machine \u2013 Example\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026. 5\n6. Conversion: Mealy \u2192 Moore\u2026\u2026\u2026\u2026\u2026\u2026\u2026.....6\n7. Conversion: Moore \u2192 Mealy\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..7ContentINDEX\nIntroduction to Finite State Machines with Output\nFinite Automata produce accept/reject, but some models produce output for each input.\nTwo such machines are:\n\u007fMoore Machine: Output depends only on current state\n\u007fMealy Machine: Output depends on current state and input\nMoore Machine \u2013 Definition\nA Moore Machine is a 6-tuple:\nM = (Q, \u03a3, \u0394, \u03b4, \u03bb, q\u2080)\nWhere:\n\u007fQ = set of states\n\u007f\u03a3 = input alphabet\n\u007f\u0394 = output alphabet\n\u007f\u03b4: Q \u00d7 \u03a3 \u2192 Q (transition function)\n\u007f\u03bb: Q \u2192 \u0394 (output function)\n\u007fq\u2080 = initial state\nOutput depends on state only\nMoore Machine \u2013 Example\nDesign a Moore machine to generate 1\u2019s complement of a given binary number.\n\nMealy Machine \u2013 Definition\nA Mealy Machine is a 6-tuple:\nM = (Q, \u03a3, \u0394, \u03b4, \u03bb, q\u2080)\nWhere:\n\u007fQ = set of states\n\u007f\u03a3 = input alphabet\n\u007f\u0394 = output alphabet\n\u007f\u03b4: Q \u00d7 \u03a3 \u2192 Q (transition function)\n\u007f\u03bb: Q \u00d7 \u03a3 \u2192 \u0394 (output func\u019fon depends on state and input)\n\u007fq\u2080 = initial state\nOutput occurs during transition\nMealy Machine \u2013 Example\nDesign a Mealy machine to generate the first complement of any given binary input.\n\nMoore vs Mealy \u2013 Comparison Table\n\nConversion: Mealy \u2192 Moore\nSteps:\n1. For each (state, input) with unique output, create a new Moore state\n2. Adjust transitions to link these new states\n3. Assign outputs to the new states accordingly\n4. Initial output added before processing input\nConversion: Mealy \u2192 Moore Example\nConsider the following Mealy Machine\nAs in the above Mealy Machine,\n\u007fq0 is the start state, (0,1) are inputs, and \u201ca\u201d is the output.\n\u007fEvery entering input in the state q0 having the similar output \u201ca\u201d.\n\u007fSo, simply cut the output \u201ca\u201d over the arrow and place it along with the state \u201cq0\u201d.\n\nConversion: Mealy \u2192 Moore Example\nAfter conversion, the Moore Machine is given under\n\nConversion: Moore \u2192 Mealy\nSteps:\n1. Use the state output of the target state as transition output\n2. No need to duplicate states\n3. Output moves from states to transitions\nFewer states than Moore equivalent\nConversion: Moore to Mealy Example\nConsider the following Moore Machine", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2611, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4e5ae694-6e18-4a8a-85b8-1219f633885e": {"__data__": {"id_": "4e5ae694-6e18-4a8a-85b8-1219f633885e", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1pasibODDKv9HEVClYghx9bAaQ8CXjICm", "node_type": "4", "metadata": {}, "hash": "2dfb398dc44cfcb602b4ec19d5cb02a11e3457dcc646575a1fbca70efc3df10a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nDeterministic Finite Automata -(DFA) and\nequivalence with regular expressions\nChapter - 2: Regular languages and finite automata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. DFA\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.1\n2. Formal Definition of DFA\u2026\u2026\u2026..\u2026.\u2026..\u2026\u2026\u2026\u2026. 2\n3. DFA Example\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026.\u2026.\u2026\u2026\u2026\u2026. 3\n4. Equivalence of DFA and Regular Expressions 4\n5. RE to DFA\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..\u2026\u2026\u2026\u2026\u2026. 5\n6. DFA to RE \u2013 State Elimination\u2026\u2026\u2026\u2026\u2026\u2026\u2026..... 6ContentINDEX\nWhat is a DFA?\nDefinition:\nA Deterministic Finite Automaton (DFA) is a mathematical model of computation used to\nrecognize regular languages.\nKey Feature:\nFor each state and input symbol, there is exactly one transition.\nFormal Definition of DFA\nA DFA is a 5-tuple:\nM = (Q, \u03a3, \u03b4, q\u2080, F)\nWhere:\n\u007fQ = finite set of states\n\u007f\u03a3 = input alphabet\n\u007f\u03b4 = transition function ( \u03b4: Q \u00d7 \u03a3 \u2192 Q)\n\u007fq\u2080 = start state (q \u2080\u2208Q)\n\u007fF = set of accept (final) states (F \u2286Q)\nDFA Example\nAlphabet : \u03a3 = {0, 1}\nLanguage : Strings ending with '01\u2019\nStates: Q = {q \u2080, q\u2081, q\u2082}\nStart state: q \u2080\nAccept state: q \u2082\nTransitions:\n\u03b4(q\u2080, 0) = q \u2080\n\u03b4(q\u2080, 1) = q \u2081\n\u03b4(q\u2081, 0) = q \u2082\n\u03b4(q\u2081, 1) = q \u2081\n\u03b4(q\u2082, 0/1) = q \u2080 (or dead state)\n\nDFA Example\nDraw a DFA for the language accepting strings starting with \u2018ab\u2019 over input alphabets \u2211\n= {a, b}\nRegular expression for the given language = ab(a + b)*\n\nDFA Example\nDraw a DFA for the language accepting strings starting with \u2018a\u2019 over input alphabets \u2211 =\n{a, b}\nRegular expression for the given language = a(a + b)*\n\nEquivalence of DFA and Regular Expressions\nA language is regular if it can be represented by a DFA or a Regular Expression.\nExample:\nConversions:\n\u007fRE \u2192 DFA:\n\u007fConvert RE to NFA\n\u007fConvert NFA to DFA\n\u007fDFA \u2192 RE:\nUse state elimination method or GNFA construction\nRE to DFA \u2013 Steps\nConvert RE \u2192NFA (using Thompson\u2019s Construction)\nNFA \u2192DFA (subset construction)\nDFA \u2192minimized DFA (optional)\nExample:\nRE = (a + b)*ab\n\u2192Build NFA\n\u2192Convert to DFA that accepts strings ending in \"ab\"\nDFA to RE \u2013 State Elimination\nBasic Steps:\n1. Add new start and end states (if needed)\n2. Eliminate states one by one\n3. Update transitions using Res\n4. Final expression between new start and end is the RE", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2215, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ca29a2af-d0e3-4b6b-ae09-e766a0206c62": {"__data__": {"id_": "ca29a2af-d0e3-4b6b-ae09-e766a0206c62", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1cX2ONBT9K6zdbFitoF52TTgRB0BcBxul", "node_type": "4", "metadata": {}, "hash": "81cbb5d067aa564a441075dd183d8909d23f2b52f5f9d59edfa37064d0125e6d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with\nESP8266\nRegular expressions and languages\nChapter - 2: Regular languages and finite\nautomata\nProf. Riddhi Atulkumar Mehta\nAssistant Professor\nDepartment of Computer Science and\nEngineering\n1. Regular Expression\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 1\n2. Symbols in Regular Expressions\u2026.\u2026..\u2026\u2026\u2026\u2026. 2\n3. Regular Expression Operators\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026. 3\n4. Examples of Regular Expressions.\u2026\u2026\u2026\u2026\u2026.. 4\n5. Language of a Regular Expression\u2026\u2026\u2026\u2026\u2026\u2026. 5\n6. Regular Expressions and Finite Automata..... 6\n7. Closure Properties of Regular Languages\u2026\u2026  7\n8. Applications of Regular Expressions\u2026\u2026\u2026\u2026\u2026  8ContentINDEX\nWhat is a Regular Expression?\nDefinition:\nA Regular Expression (RE) is a formal way to describe a set of strings (a language) using\npattern-matching rules.\nPurpose:\nTo specify regular languages, which are the simplest class in the Chomsky hierarchy.\nBasic Symbols in Regular Expressions\nMeaning Symbol\nThe character 'a' a\nThe empty string \u03b5\nEmpty language (no string) \u2205\nRegular Expression Operators\nDescription Syntax Operator\nEither R \u2081 or R \u2082 (alternation) R\u2081 + R\u2082 Union\nR\u2081 followed by R \u2082 R\u2081R\u2082 Concatenation\nZero or more repetitions of R R* Kleene Star\nOne or more repetitions of R R\u207a Plus\nZero or one occurrence of R R? Optional\nExamples of Regular Expressions\n\u007fa* \u2192 {\u03b5, a, aa, aaa, ...}\n\u007f(a + b)* \u2192 All strings over {a, b}\n\u007fa(b + c)* \u2192 Starts with 'a', followed by any combo of b and c\n\u007f1(0 + 1)* \u2192 Binary strings star\u019fng with 1\nLanguage of a Regular Expression\nDefinition:\nIf R is a regular expression, then L(R) is the language denoted by R \u2014 the set of all strings\nit matches.\nExample:\nR = (ab)*\n\u2192 L(R) = { \u03b5, ab, abab, ababab, ...}\nRegular Expressions and Finite Automata\nEvery regular expression corresponds to a Finite Automaton, and vice versa.\n\u007fRE\u2192FA (Construction possible)\n\u007fFA\u2192RE (Using state elimination method)\nImplication:\nREs and FAs recognize the same class of languages: Regular Languages\nClosure Properties of Regular Languages\nExplanation Operation\nL\u2081\u222aL\u2082 is regular Union\nL\u2081L\u2082 is regular Concatenation\nL* is regular Kleene Star\nIf L is regular, so is its complement Complementation\nL\u2081 \u2229 L\u2082 is regular Intersection\nL\u2081 - L\u2082 is regular Difference\nApplications of Regular Expressions\n\u007fText editors (search and replace)\n\u007fLexical analyzers (tokenization in compilers)\n\u007fPattern matching in programming (e.g., Python, JavaScript, grep)\n\u007fValidation (email, password formats)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2384, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "31d9f59e-058b-4e91-833d-7def8bb1019a": {"__data__": {"id_": "31d9f59e-058b-4e91-833d-7def8bb1019a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1vJNRWl68wKXevBTH7WpeB2DkcSLTaYDz", "node_type": "4", "metadata": {}, "hash": "1739700216efb852cb7eebd0a3bb270be95b7aa70982757c68f6cfd406b74212", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nChomsky hierarchy of languages \nChapter -1: Introduction\nProf. Riddhi Atulkumar Mehta \nAssistant Professor \nDepartment of Computer Science and \nEngineering\n1.Chomsky Hierarchy\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 1\n2.The Four Types of Grammars\u2026\u2026.\u2026..\u2026\u2026\u2026\u2026. 2\n3.Type 0 \u2013Unrestricted Grammars\u2026\u2026..\u2026\u2026\u2026.  3\n4.Type 1 \u2013Context -Sensitive Grammars\u2026\u2026\u2026.. 4\n5.Type 2 \u2013Context -Free Grammars (CFGs).\u2026.. 5\n6.Type 3 \u2013Regular Grammars\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..6\n7.Summary\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.7Content INDEX\nWhat is the Chomsky Hierarchy?\nDefinition:\nThe Chomsky Hierarchy, introduced by Noam Chomsky in 1956, classifies formal \nlanguages into four types based on generative grammars.\nPurpose:\nTo understand the power and limitations of different types of grammars and machines.\nThe Four Types of Grammars\nType Grammar Name Recognized By\nType 0 Unrestricted Grammar Turing Machine\nType 1 Context -Sensitive Grammar Linear Bounded Automaton (LBA)\nType 2 Context -Free Grammar Pushdown Automaton (PDA)\nType 3 Regular Grammar Finite Automaton (DFA/NFA)\nType 0 \u2013Unrestricted Grammars\n\u2022Most powerful type\n\u2022Production Rule Form : \u03b1 \u2192 \u03b2\n\u2022No restriction, except \u03b1 \u2260 \u03b5\n\u2022Generated Language : Recursively Enumerable Language (REL)\n\u2022Machine Model: Turing Machine\n\u2022Example :\nS \u2192 aSb | SS | \u03b5\nType 1 \u2013Context -Sensitive Grammars\n\u2022Production Rule Form: \u03b1A\u03b2 \u2192 \u03b1\u03b3\u03b2\n\u2022\u03b3 is non -empty and | \u03b3| \u2265 | A|\n\u2022Context on both sides of A determines its replacement\nGenerated Language : Context -Sensitive Language (CSL)\nMachine Model : Linear Bounded Automaton (LBA)\nExample:\na\u207fb\u207fc\u207f (n \u2265 1)\nType 2 \u2013Context -Free Grammars (CFGs)\nProduction Rule Form : A \u2192 \u03b3\n\u2022A is a single non -terminal\n\u2022\u03b3 \u2208(V \u222a\u03a3)*\nGenerated Language : Context -Free Language (CFL)\nMachine Model : Pushdown Automaton (PDA)\nCommon Use : Programming languages, compilers\nExample:\nS \u2192 aSb | \u03b5\n\u2192 Generates: {a\u207fb\u207f | n \u2265 0}\nType 3 \u2013Regular Grammars\nProduction Rule Form:\n\u2022A \u2192 aBor A \u2192 a\n\u2022Only one non -terminal on the left, and one terminal + optional non -terminal on \nthe right\nGenerated Language : Regular Language\nMachine Model: Finite Automaton (DFA/NFA)\nUse Case: Text searching, lexical analysis\nExample :\nS \u2192 aS| bS| \u03b5\nSummary Table", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2157, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d297da2c-49e6-46ef-82f0-a1884f194087": {"__data__": {"id_": "d297da2c-49e6-46ef-82f0-a1884f194087", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "12I7aQKuBsQgLABEE2iiG5eTb9ca3T0rZ", "node_type": "4", "metadata": {}, "hash": "451f2ff3ffe7a9d427848d17adae7324e00f5db2876f5a56cc6fa09b39258378", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nProductions and Derivation \nChapter -1: Introduction\nProf. Riddhi Atulkumar Mehta \nAssistant Professor \nDepartment of Computer Science and \nEngineering\n1.Basics of Grammar\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 1\n2.Productions.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026..\u2026\u2026\u2026\u2026. 2\n3.Derivation\u2026..\u2026.\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026..\u2026\u2026\u2026.  3\n4.Derivation Example\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026.. 4\n5.Leftmost and Rightmost Derivation.\u2026\u2026\u2026\u2026.. 5Content INDEX\nBasics of Grammar\nA grammar G is defined as:\nG = (V, \u03a3, P, S)\nWhere:\n\u2022V = Set of variables (non -terminals)\n\u2022\u03a3 = Set of terminals (alphabet symbols)\n\u2022P = Set of production rules\n\u2022S = Start symbol\nWhat are Productions? \nProductions (P):\nRules used to replace variables (non -terminals) with other variables or terminal strings.\nGeneral Form :\nA\u2192\u03b1\nWhere :\n\u2022Aisanon-terminal (from V)\n\u2022\u03b1isastring from (V\u222a\u03a3)*\nExample:\n\u2022S \u2192 aSb\n\u2022S \u2192 \u03b5\nWhat is Derivation? \nDerivation:\nThe process of repeatedly applying production rules to derive a string from the start \nsymbol.\nGoal:\nGenerate strings belonging to the language of the grammar.\nNotation:\n\u03b1 \u21d2\u03b2 (one step derivation)\n\u03b1 \u21d2* \u03b2 ( zero or more steps)\n\u03b1 \u21d2\u207f \u03b2 (n steps)\nDerivation Example \u2013Step by Step\n\u2022Finite Language: Has a limited number of strings\n\u2022Infinite Language: Has unlimited strings (e.g., L = {a\u207f | n \u2265 0})\nGiven G=({S}, {a,b},{S\u2192aSb,S\u2192\u03b5},S)\nLet\u2019s derive aabb :\nS\n\u21d2aSb\n\u21d2aaSbb\n\u21d2aa\u03b5bb\n=aabb\nTherefore, aabb\u2208L(G)\nLeftmost and Rightmost Derivation\nLeftmost Derivation:\nAlways replace the leftmost non -terminal \nfirst.\nRightmost Derivation:\nAlways replace the rightmost non -terminal \nfirst.\nExample:\nGrammar:\n\u2022S \u2192 aSb | abLeftmost Derivation for aabb :\n1.S\n2.\u21d2aSb\n3.\u21d2aaSbb\n4.\u21d2aabb\nRightmost Derivation:\n1.S\n2.\u21d2aSb\n3.\u21d2aabSb\n4.\u21d2aabb", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1681, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c6f163a2-99c1-4151-88e1-6d2921865730": {"__data__": {"id_": "c6f163a2-99c1-4151-88e1-6d2921865730", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1wYuB4bqDH9kqGlPjwg81z8YkMf3sglzE", "node_type": "4", "metadata": {}, "hash": "63fbce185119cbef9c837da8d5c46d4a6185a3a647793fd884ffae049fc803ee", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Introduction & Programming with \nESP8266\nIntroduction to Alphabet, languages and \ngrammars \nChapter -1: Introduction\nProf. Riddhi Atulkumar Mehta \nAssistant Professor \nDepartment of Computer Science and \nEngineering\n1.Introduction to TOC\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. 1\n2.Alphabet\u2026..\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026..\u2026\u2026\u2026\u2026. 2\n3.Strings and Their Properties\u2026.\u2026\u2026.\u2026.\u2026\u2026\u2026\u2026. 3\n4.Language\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\u2026\u2026\u2026\u2026\u2026.. 4\n5.Language Construction Methods\u2026\u2026\u2026\u2026\u2026\u2026\u20265\n6.Grammar\u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.........................6Content INDEX\nWhat is Theory of Computation? \nTheory ofComputation isthebranch ofcomputer science that deals with how problems\ncanbesolved using algorithms and how efficiently they canbesolved .\nMain Areas :\n\u2022Automata Theory :Study ofabstract machines (finite automata, pushdown automata,\netc.)\n\u2022Formal Languages :Study ofsyntax and structure oflanguages\n\u2022Computability Theory :What problems canbesolved\n\u2022Complexity Theory :How efficiently problems canbesolved\nAlphabet ( \u03a3)\nDefinition :\nAnalphabet isafinite, non-empty setofsymbols .\nNotation :\n\u03a3(Greek letter sigma)\nExamples:\n\u2022\u03a3 = {0, 1} \u2192 Binary alphabet\n\u2022\u03a3 = { a, b, c, ..., z} \u2192 English alphabet\n\u2022\u03a3 = {+, *, (, ), a, b}\nStrings and Their Properties \nString:\nA finite sequence of symbols taken from a given alphabet.\nExamples:\nIf \u03a3 = { a, b}, then \"ab\", \" aab\", and \" bbaaa \" are strings over \u03a3.\nKey Concepts:\nLength (|w|): Number of symbols in string w\n|\"abc\"| = 3\nEmpty String ( \u03b5): A string with zero symbols\n|\u03b5| = 0\nLanguage\nDefinition:\nA language is a set of strings formed using the symbols of a given alphabet.\nExamples:\n\u2022L = {\u201ca\u201d, \u201cab\u201d, \u201c abc\u201d}\n\u2022Over \u03a3 = {0, 1}, L = {\u03b5, 0, 11, 101} is a binary language\nTypes of Languages:\n\u2022Finite Language: Has a limited number of strings\n\u2022Infinite Language: Has unlimited strings (e.g., L = {a\u207f | n \u2265 0})\nLanguage Construction Methods\nImportant Operations on Languages:\n1.Union (L \u2081 \u222aL\u2082):\nSet of strings that belong to L \u2081 or L\u2082 or both\n2.Concatenation (L \u2081 \u00b7 L\u2082):\nAll strings formed by taking a string from L \u2081 followed by a string from L \u2082\n3.Kleene Star (L*):\nSet of all strings including \u03b5, formed by zero or more concatenations of strings from L\nExample:\nIf L = {a}, then L* = { \u03b5, a, aa, aaa, ...}\nGrammar\nDefinition:\nA grammar is a formal set of rules used to generate strings in a language.\nA grammar G is a 4 -tuple:\nG = (V, \u03a3, P, S)\nWhere:\n\u2022V: Set of variables (non -terminals)\n\u2022\u03a3: Set of terminals (alphabet symbols)\n\u2022P: Set of production rules\n\u2022S: Start symbol (S \u2208V)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2434, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8d4cfdf8-9b3c-4a92-9b03-3bceb68bb9b4": {"__data__": {"id_": "8d4cfdf8-9b3c-4a92-9b03-3bceb68bb9b4", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1pz9Tj__OP_x5r7BYajHMjxiUbTCzyJ43", "node_type": "4", "metadata": {}, "hash": "cf3991691f99909ff672d7c0d7ea246983389e962382cbe92af10a2e9af6feaa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Page 1 of 2 Seat No: ______________        Enrollment No: ____________________  \nPARUL UNIVERSITY  \nFACULTY OF ENGINEERING & TECHNOLOGY  \nB.Tech  / Int. Btech Summer 202 4 - 25 Examination  \n \nSemester:  5/9         Date: 13-05-2025  \nSubject Code: 303105306        Time: 10 :30 am to 1 :00 pm  \nSubject Name: Theory of Computation      Total Marks: 60  \n \nInstructions:   \n1. This question paper comprises of two section s. Write answer of both the section s in separate answer book s. \n2. From Section A, Q.1 is compulsory , From Section B , Q.1 is compulsory . \n3. Figures to the right indicate full marks.  \n4. Draw neat and clean drawings & Make suitable assumptions wherever necessary.  \n5. Start new question on new page.  \n6. BT- Blooms Taxonomy Levels \u2013 Remember -1, Understand -2, Apply -3, Analyse -4, Evaluate -5, Create -6 \n \n \nSECTION -A Marks  CO BT \nQ.1 Answer the Following Questions     \n A. Provide a brief explanation of the following:  \n1. What is a regular expression?   \n2. Write  a regular expression for strings ending with \"01\" over \n{0,1}.  \n3. List Chomsky\u2019s hierarchy of grammars.      [06] 1 1,2,3  \n \n B. Answer the following questions in detail:  \n1. What is a Turing Machine (TM)?  \n2. Construct a DFA for the language L = {w | w starts with 'a'}.  \n3. Construct a DFA for the language L = {w | w contains at least one \u2018b\u2019}.   [06] 4 3 \nQ.2  A. State the differences between regular grammar and context -free grammar  \n(CFG).   [04] 3 2 \n B. Define an \u03b5 -NFA (Epsilon -NFA) and explain how it differs from an NFA \nand DFA.   [05] 2 2 \n                                                                      OR     \n  B.  Convert the following Epsilon NFA  to DFA\n    [05] 2 3 \nQ.3  A. State the difference between DFA and NFA with an example.   [04] 2 2 \n B. What is the pumping  lemma for regular languages?   [05] 2 2 \n                                                                      OR     \n B.  State the difference between a Finite Automaton, Pushdown Automaton, \nand Turing Machine.   [05] 1 2 \nSECTION -B    \nQ.1 Answer the Following Questions     \n A. Explain the following  \n1. Define Kleene Closure with an example.  \n2. Define Positive Closure and explain how it differs from Kleene \nClosure.  \n3. State the closure properties of regular languages.     [06] 2 1 \n\n   Page 2 of 2  B.  Construct simple regular expressions using Kleene Closure.  \na) Write a regular expression for all binary strings (0s and 1s).  \nb) Write a regular expression for strings that start with 'a' and contain any \nnumber of 'b'.  \nc) Write a regular expression for strings that end in '01' over {0,1}.   [06] 2 3 \nQ.2  A. Construct a DFA for the language L = {w | w starts with 'a' and ends with \n'b'}.  [04] 2 3 \n B. Draw a DFA for the language accepting strings starting with \u2018ab\u2019 over \ninput alphabets  \u2211 = {a, b}   [05] 2 3 \n                                                                       OR     \n  B. Construct a PDA that accepts L = {0n 1n | n \u2265 0}     [05] 3 3 \nQ.3  A. Differentiate between \u03b5 -NFA, NFA, and DFA with an example.   [04] 2 2 \n B. Show that L = {0\u207f1\u207f | n \u2265 1} is not regular using the pumping lemma.   [05] 2 4 \n                                                                     OR     \n B. Describe the 7 -tuple formal definition of a Turing Machine (TM) with an \nexample.   [05] 4 2 \n \n---x---", "mimetype": "text/plain", "start_char_idx": 3, "end_char_idx": 3354, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "92d843bc-c575-450c-a3db-ea3f71966690": {"__data__": {"id_": "92d843bc-c575-450c-a3db-ea3f71966690", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1KSE2Q708areAAjdbn6iH8HOmw8cWgnWN", "node_type": "4", "metadata": {}, "hash": "7147074154bed83fd495e96736f30a53ff99f3eb51230291cf6cb932f6afe45f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1. Compare and contrast the four types of grammars in the Chomsky hierarchy in terms of their \ngenerative power.  \n2. Design a DFA that accepts strings over {0,1} that contain an even number of 0s and an odd \nnumber of 1s.  \n3. Explain what a grammar is and list the types of grammars as per Chomsky hierarchy.  \n4. Write the rules to convert any CFG to Greibach Normal Form (GNF).  \n5. For the grammar G=(V, \u03a3,R,S) with productions S\u2192aSb \u2223\u03f5,  list the strings generated by GGG of \nlength 4.  \n6. Explain why nondeterministic Turing machines are not more powerful than deterministic \nones.  \n7. Draw the Chomsky hierarchy and explain each level with examples.  \n8. Differentiate between language, grammar, and automaton.  \n9. Convert the regular expression (a+b) \u2217abb into a DFA.  \n10. Design a Moore machine to detect the sequence \"101\" in an input bit stream.  \n11. Given the following NFA, convert it into an equivalent DFA:  \na. States: {q0, q1}  \nb. Alphabet: {0,1}  \nc. Transitions: \u03b4(q0,0) = {q0,q1}, \u03b4(q0,1) = {q0}, \u03b4(q1,1) = {q1}  \n12. Write a regular grammar corresponding to the language L={anbm\u2223n,m\u22650}. \n13. Use the pumping lemma to prove that the language L={anbn\u2223n\u22650} is not regular.  \n14. Minimize the following DFA (provide a transition table):  \na. States: {A, B, C, D}  \nb. Alphabet: {0,1}  \nc. Transitions: A\u21920\u2192B, A\u21921\u2192C, B\u21920\u2192A, B\u21921\u2192D, C\u21920\u2192D, C\u21921\u2192A, D\u21920\u2192C, \nD\u21921\u2192B  \n15. List and prove closure properties of regular languages under union, concatenation, and \nKleene star.  \n \n16. Construct a CFG for the language L={anbn\u2223n\u22650}. \n17. Convert the following CFG into Chomsky Normal Form:  \na. S\u2192ASA\u2223aB \nb. A\u2192B\u2223S \nc. B\u2192b\u2223\u03f5 \n18. Draw parse trees for the string \"aabb\" using the grammar from Q1.  \n19. Explain ambiguity with an example grammar and show how to remove ambiguity.  \n20. Prove using the pumping lemma that the language L={anbncn\u2223n\u22650} is not context -free.  \n21. Design a PDA that accepts the language L={anbn\u2223n\u22650} by empty stack method.  \n22. State closure properties of CFLs and give examples where closure fails.  \n23. Differentiate between deterministic and nondeterministic PDA with examples.  \n24. Explain context -sensitive languages and give an example grammar for the language \n{anbncn\u2223n\u22651} \n25. Design a TM that accepts the language L={anbn\u2223n\u22651}. \n26. Explain the difference between Turing -decidable and Turing -recognizable languages with \nexamples.  \n27. Prove that the class of Turing -decidable languages is closed under union and intersection.  \n28. Describe the working of a nondeterministic Turing machine and explain its equivalence with \ndeterministic TM.  \n29. Show that unrestricted grammars are equivalent in power to Turing machines.  \n30. Explain the concept of TM as an enumerator with an example.  \n31. Write the formal definition of a Turing machine and explain each component.  \n32. State and explain the Church -Turing thesis.  \n33. Describe the construction of a universal Turing machine.  \n34. Explain the diagonalization language and how it proves certain languages are undecidable.  \n35. List at least three undecidable problems and explain why they are undecidable.  \n36. Discuss the halting problem and prove its undecidability.  \n37. Explain the significance of universal Turing machine in computability theory.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3270, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c543c9fc-2835-444f-88d9-2df16797c204": {"__data__": {"id_": "c543c9fc-2835-444f-88d9-2df16797c204", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1ODAs1Osx55qxzcOuGEBU8PnV2AQAnx_z", "node_type": "4", "metadata": {}, "hash": "dae9c65944896c8ea3174ab84e70b6af5ba2aa0dfa64866a9d49233b0d813b41", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Page 1 of 2 Seat No: ______________                 Enrollment No: ____________________  \nPARUL UNIVERSITY \nFACULTY OF ENGINEERING & TECHNOLOGY \nB.Tech. winter 2022 - 23 Examination \nSemester: 5          Date: 14/10/2022 \nSubject Code: 203108301       Time: 10:30am to 1:00pm \nSubject Name: Theory of Computation                 Total Marks: 60 \n \nInstructions:  \n1. All questions are compulsory. \n2. Figures to the right indicate full marks.  \n3. Make suitable assumptions wherever necessary. \n4. Start new question on new page. \n \nQ.1 Objective Type Questions  -   (All are compulsory)  (Each of one mark) (15) \n 1.In Chomsky hierarchy of languages, Context Sensitive Languages come under \n    a) Type-3          b) Type-2           c) Type-1       d) Type-0  \n 2. Pick the incorrect one wrt Positive Closure of (a+b). \n    a) { \u03f5,a,b\u2026.}                 b) { a,b\u2026.}         c) {a,b,aa,bb\u2026\u2026.}       d) {a,b,aa,bb,ab,ba\u2026.}           \n 3. if n-state NFA then equivalent DFA would have______ maximum no of states. \n     a) 1          b) n            c) 2n               d) nn  \n 4.Pick the correct option in following relationships. \n     a) CFG \u2282 Regular          b) CSG \u2282 CFG          c) Regular \u2282 CSG               d)  REC \u2282 CSG  \n 5. If Language A pass the Pumping lemma test for context free languages then A would be always \n    a) Context Free            b) not Context Free          c) undecidable         d) none of these   \n 6. Minimization of NFA is also Possible same as DFA (True/False)  \n 7. Number of languages are accepted by NFA and DFA would be same (True/False)  \n 8. L= { anbn|n>1} would be accepted by Finite automata (True/False)   \n 9. Every NPDA can be converted to equivalent DPDA (True/False)    \n 10. Moore Machine acts as output generator (True/False)    \n 11. Finite Automata +  Memory= _____________ Automata  \n 12. L= { an|n>1}is a________________Language  \n 13. Dead state is possible only in________automata  \n 14. Any Finite Automata having no self-loop and cycle accept always _________Language.  \n 15. Write the production rule for Context free Grammar.  \nQ.2 Answer the following questions. (Attempt any three) (15) \n A) Explain Pumping lemma for Context free Languages.  \n B) Design DFA for Language L={an bm | n,m>0}  \n C) Write the Grammar for Language L={an bn | n>0}  \n D) Write down the name of output generators? Explain any one output generator with example.  \nQ.3 A) Minimize the Following DFA. \n \n (07) \n B) Explain Turing Machine with all variants and also design Turing Machine for L={an bn | n>0}. (08) \n OR  \n B) Consider the following Grammar and construct the parse tree in both fashion i.e Top-down and \nBottom up for following string id +id*id. \n A\uf0e0A+A/A*A/id (08) \nQ.4 A) Explain Push-Down Automata and how is it better than Finite Automata. Design DPDA for given (07) \n\n   Page 2 of 2 language L={0n 1n | n>=0} \n \n OR  \n A) Explain Context Sensitive Grammar with Production rule and also write down the Normal form of \nCFG with example. (07) \n B) Explain about decidable and undecidable problem and also tell the ambiguity in CFG and \nmembership for Recursive enumerable languages are decidable or not justify. (08)", "mimetype": "text/plain", "start_char_idx": 3, "end_char_idx": 3173, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0deb60d3-6704-43b0-a7af-7d2729780b5a": {"__data__": {"id_": "0deb60d3-6704-43b0-a7af-7d2729780b5a", "embedding": null, "metadata": {}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1hX8-Ai2RPVyKXPL_M415ii2av6wHFG8V", "node_type": "4", "metadata": {}, "hash": "95725a28de5d813d9316248580b7517f94329c8a8a9d45554c94243c70f79f31", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Page 1 of 2 Seat No : ______________                 Enrollment No: _______ _____________  \nPARUL UNIVERSITY  \nFACULTY OF ENGINEERING & TECHNOLOGY  \nB.Tech.  Winter  2021 - 22 Examination  \nSemester:  5         Date: 22-10-2021  \nSubject Code: 203108301        Time: 10:30 am to 01:00  pm \nSubject Name: Theory of Computation      Total Marks: 60 \nInstructions:   \n1. All questions are compulsory.  \n2. Figures to the right indicate full marks.  \n3. Make suitable assumptions wherever necessary.  \n4. Start new question on new page.  \n \nQ.1 Objective Type Questions  - (Each of one mark)  (15) \n 1. The Gr ammar can be defined as: G=(V, T, P, S),In t he given definition, what does P represents?  \na) Productive  \nb) Product  \nc) Production  \nd) None of these   \n 2. Concatenation Operation refers to which of the following set  operations:  \na) Union  \nb) Dot  \nc) Kleene  \nd) None of the above   \n 3. Which of the following statement is correct?  \na) All Regular grammar are co ntext free but not vice versa  \nb) All context free grammar are regu lar grammar but not vice versa  \nc) Regular grammar and  context fr ee grammar are the same entity  \nd) None of the mentioned   \n  4. Turing machine in more powerful than:  \na) Finite Autmeta  \nb) Push Down Autometa  \nc) Both (a) and (b)  \nd) None of these   \n 5. A recursive language is also called  \n     a) Decidable  \n     b) Undecidable  \n     c) Both (a) and (b)  \n     d) None of these   \n 6. A language is regular if it can be expresse d in terms of _______________  expression.   \n 7. The most restricted grammar is________   \n 8. Power of DPDA and NPDA are equal? ________   \n 9. Type ___________  grammar is also called unrestricted grammar according to Chomsky hierarchy   \n 10. A problem  can be solved  by an algorithm  if and only if it can be solved  by a ___________   \n 11. For converting Finite autometa to Regular Expression which method you will follow?   \n 12. Difference Between string  and alphabet ?  \n 13. LBA  have more  power  than NPDA  but less power  than Turing  Machine.  Is it true/false?   \n 14. How many tuples does Turing Machine contains?   \n 15. Is Post Correspondence Problem (PCP)  is Decidable or Undecidable?   \nQ.2 Answer the following questions. (Attempt any three)  \n (15) \n A) Is it possible to construct push down autometa for a language L = anbncm / n>m.? If it\u2019s possible \nthen draw a pushdown autometa for language L, otherwise explain how it\u2019s not possible.  \n  \n B) What is Reducibility? Explain with an example . \n  \n C) Explain Variants ( Different types) of Turing Machine.  \n \n \n \n  \n   Page 2 of 2  D) Write a regular expression for given finite autometa . \n  \nQ.3 A) Convert the given NFA to DFA.  \n (07) \n B) Draw a Push Down Autometa for a language L = wwR / w\u2208(a,b)+  \n (08) \n OR  \n B) Draw  a Turing Machine for a language L=  anbncn / n>=1. (08) \nQ.4 A) Minimize the given finte autometa  \n (07) \n OR  \n A) Is Turing Machine is equivalent to a computer? If it\u2019s Yes then what is the name of the turing              \nmachine and also explain the working operation of Turing Machine which acts as a computer , \nOtherwise explain how it\u2019s not.  (07) \n B) Convert the following CFG(Context Free Grammar) to CNF( Chomsky Normal Form )  \n     S\uf0e0ASA|aB  \n     A\uf0e0B|S \n     B\uf0e0b|\u03b5 (08)", "mimetype": "text/plain", "start_char_idx": 3, "end_char_idx": 3291, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}}